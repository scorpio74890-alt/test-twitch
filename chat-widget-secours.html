<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Widget Streamlabs</title>
    <!--
    ========================================
    COMMANDES DE CHAT DISPONIBLES
    ========================================

    üîÑ !chatreload      - Recharge la page (cache conserv√©) (Mod√©rateurs + VIPs uniquement)
    üîÑ !chatrefresh     - Recharge la page (cache conserv√©) (Mod√©rateurs + VIPs uniquement)
    üîÑ !chatforcereload - Recharge la page avec vidage du cache (Mod√©rateurs + VIPs uniquement)
    üóëÔ∏è !chatclearbadges - Vide le cache badges et recharge depuis l'API sans recharger la page (Mod√©rateurs + VIPs uniquement)
    üîß Si l'overlay reste cass√© apr√®s crash: ajouter ?forcereset=1 √† l'URL dans OBS puis rafra√Æchir la source.

    üëÆ MOD√âRATEURS AUTORIS√âS:
    fugu_fps, wizebot, wzbot, emmamachou, gamlno, d3vilsfr,
    pogo__fps, babouille__, spoutnik_le_puant, z4apox, kudji__,
    kc_biolxzy, silaaaxe, streamelements, nutelloush, mustee___,
    ze1sh, vincent_maes12, dragonk_fps, chloedsx, maeniiaaa,
    g4li_fps, xiress_gp, prodigymarketing, chaima_2808,
    lea_ackermann, darkoootv

    üëë VIPS AUTORIS√âS:
    sc0rpio74890

    üß™ TESTS (Console):
    window.chatWidget.testCommandPermissions('username')
    window.chatWidget.testReload()
    window.chatWidget.clearBadgeCacheAndReload()  ‚Äî vide le cache badges et recharge depuis l'API (sans reload)
    ========================================
    -->
    <style>
        @font-face {
            font-family: 'Sea Regular Fugu';
            src: url('https://raw.githubusercontent.com/scorpio74890-alt/test-twitch/main/police/sea-regular-fugu.otf') format('opentype'),
                 url('police/sea-regular-fugu.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        /* Test de chargement de police */
        .font-test {
            font-family: 'Sea Regular Fugu', monospace;
            position: absolute;
            left: -9999px;
            font-size: 72px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Sea Regular Fugu', 'Comic Sans MS', 'Trebuchet MS', 'Arial Black', Arial, sans-serif;
            background: transparent;
            color: #ffffff;
            overflow: hidden;
        }

        #chat-container {
            height: 100vh;
            width: 100%;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: 10px;
            overflow: hidden;
        }

        .chat-message {
            margin-bottom: 10px;
            display: block;
            animation: slideIn 0.3s ease-out;
            opacity: 0;
            transform: translateX(-20px);
            animation-fill-mode: forwards;
        }

        .username {
            font-weight: bold;
            color: #00ff88;
            display: inline;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 28px;
            line-height: 32px; /* Alignement avec la hauteur des badges */
        }

        .message-content {
            display: inline;
            word-wrap: break-word;
            word-break: break-word;
            line-height: 1.5;
            font-size: 28px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .separator {
            margin-right: 5px;
            font-weight: bold;
            color: #ffffff;
            font-size: 28px;
        }

        .badge-display {
            margin-right: 5px;
            font-size: 28px;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            height: 32px; /* Hauteur fixe pour aligner avec le username */
            vertical-align: bottom;
        }

        .badge-image {
            width: 28px; /* Badges plus grands */
            height: 28px; /* Badges plus grands */
            display: inline-block;
            vertical-align: middle;
            object-fit: contain; /* Garde les proportions */
        }

        .emote-7tv {
            max-height: 28px;
            height: auto;
            max-width: 56px; /* Permet aux emotes larges d'√™tre plus grandes */
            width: auto;
            display: inline-block;
            vertical-align: middle;
            margin: 0 2px;
            object-fit: contain; /* Garde les proportions */
        }

        .emote-twitch {
            width: 28px;
            height: 28px;
            display: inline-block;
            vertical-align: middle;
            margin: 0 2px;
        }

        /* Animation pour l'arriv√©e des messages */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }



        /* Couleurs diff√©rentes pour les pseudos */
        .username.color-1 { color: #ff6b6b; }
        .username.color-2 { color: #4ecdc4; }
        .username.color-3 { color: #45b7d1; }
        .username.color-4 { color: #96ceb4; }
        .username.color-5 { color: #ffeaa7; }
        .username.color-6 { color: #dda0dd; }
        .username.color-7 { color: #98d8c8; }
        .username.color-8 { color: #f7dc6f; }
        .username.color-9 { color: #bb8fce; }
        .username.color-10 { color: #85c1e9; }

        /* Style pour les messages de mod√©rateurs */
        .moderator {
            color: #00ff00 !important;
        }

        /* Style pour les messages VIP */
        .vip {
            color: #ff69b4 !important;
        }

        /* Style pour les messages de subscribers */
        .subscriber {
            color: #9146ff !important;
        }

        /* Style pour les messages de predictions */
        .predictions {
            color: #ff6600 !important;
        }

        /* Style pour les messages premium/prime */
        .premium {
            color: #9146ff !important;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .username, .separator {
                font-size: 28px;
            }

            .message-content {
                font-size: 26px;
            }

            #chat-container {
                padding: 5px;
            }

            .chat-message {
                margin-bottom: 8px;
            }
        }
    </style>
</head>
<body>
    <div id="chat-container"></div>

    <script>
        // URL Parameter: ?debug-badges=true - Hide all logs and enable badge-only logging
        const urlParams = new URLSearchParams(window.location.search);
        const debugBadgesMode = urlParams.get('debug-badges') === 'true';

        // Set to track unique badges (format: "badgeType/version")
        const uniqueBadges = new Set();

        // Store original console methods
        const originalConsole = {
            log: console.log.bind(console),
            warn: console.warn.bind(console),
            error: console.error.bind(console),
            info: console.info.bind(console)
        };

        // Override console methods if debug-badges mode is enabled
        if (debugBadgesMode) {
            console.log = () => {};
            console.warn = () => {};
            console.error = () => {};
            console.info = () => {};

            // Log badge extraction function
            const logUniqueBadge = (badgeType, version) => {
                const badgeKey = `${badgeType}/${version || '1'}`;
                if (!uniqueBadges.has(badgeKey)) {
                    uniqueBadges.add(badgeKey);
                    originalConsole.log(`üè∑Ô∏è Badge trouv√©: ${badgeType}${version ? ` (version ${version})` : ''}`);
                }
            };

            // Make logUniqueBadge available globally
            window.logUniqueBadge = logUniqueBadge;
        }

        class ChatWidget {
            constructor() {
                this.container = document.getElementById('chat-container');
                this.maxMessages = 50; // Nombre maximum de messages affich√©s
                this.messages = new Map(); // Store messages with unique IDs for deletion
                this.messageCounter = 0; // Counter for unique message IDs
                this.userColors = new Map(); // Pour garder une couleur consistente par utilisateur
                this.colorIndex = 0;
                this.colors = ['color-1', 'color-2', 'color-3', 'color-4', 'color-5',
                              'color-6', 'color-7', 'color-8', 'color-9', 'color-10'];

                // Cache pour les emotes 7TV
                this.sevenTVEmotes = new Map();
                this.globalSevenTVEmotes = new Map();

                // Cache pour les infos de cha√Ænes Twitch
                this.channelCache = new Map();

                // Chat partag√© - v√©rifier s'il y a d'autres participants
                this.sharedChatParticipants = new Set();
                this.isSharedChatActive = false;

                // Twitch API credentials pour les badges
                this.twitchClientId = 'gp762nuuoqcoxypju8c569th9wz7q5';
                this.twitchAuthToken = 'xrugdtwxy33q6p1dw0tg3nlkehj422';
                this.broadcasterId = '140846786';

                // Cache pour les badges Twitch
                this.badgeCache = new Map();
                this.globalBadgeCache = new Map();

                // Cache pour les images de badges charg√©es depuis le CDN
                this.badgeImageCache = new Map(); // URL -> Image element (pr√©charg√©e)

                // Track unknown badges to avoid spam logging
                this.unknownBadgesLogged = new Set();

                // Cache pour les mod√©rations (√©viter de retraiter les m√™mes bans)
                this.moderationCache = new Map();
                this.lastModerationCheck = 0;

                // Debug mode pour capturer tous les messages IRC
                this.debugMode = true;
                this.ircMessageLog = [];

                // Listes des mod√©rateurs et VIPs pour les commandes
                this.moderators = [
                    'fugu_fps', // Channel owner
                    'wizebot',
                    'wzbot',
                    'emmamachou',
                    'gamlno',
                    'd3vilsfr',
                    'pogo__fps',
                    'babouille__',
                    'spoutnik_le_puant',
                    'z4apox',
                    'kudji__',
                    'kc_biolxzy',
                    'silaaaxe',
                    'streamelements',
                    'nutelloush',
                    'mustee___',
                    'ze1sh',
                    'vincent_maes12',
                    'dragonk_fps',
                    'chloedsx',
                    'maeniiaaa',
                    'g4li_fps',
                    'xiress_gp',
                    'prodigymarketing',
                    'chaima_2808',
                    'lea_ackermann',
                    'darkoootv'
                ];

                this.vips = [
                    'sc0rpio74890',
                ];

                this.blacklist = [
                    'banned_user1',
                    'banned_user2'
                ];

                // Charger les badges Twitch
                this.loadTwitchBadges();

                // Refresh badges every 6 hours to catch new badges (less frequent since we have localStorage cache)
                setInterval(() => {
                    console.log('üîÑ Rafra√Æchissement automatique des badges Twitch...');
                    this.loadTwitchBadges(true); // Force refresh
                }, 6 * 60 * 60 * 1000); // 6 hours (reduced from 1 hour since we have localStorage cache)

                // Charger les emotes 7TV
                this.loadSevenTVEmotes();

                // D√©marrer la v√©rification du chat partag√©
                this.startSharedChatCheck();

                // D√©marrer la v√©rification p√©riodique de mod√©ration
                this.startModerationCheck();

                // Connexion directe au chat Twitch de fugu_fps
                this.connectToTwitchChat();

                // Initialiser l'√©coute des √©v√©nements Streamlabs (en backup)
                this.initStreamlabsEvents();

                // Log des permissions de commandes
                console.log(`üîê Syst√®me de commandes initialis√©:`);
                console.log(`   üëÆ Mod√©rateurs: ${this.moderators.length} (${this.moderators.join(', ')})`);
                console.log(`   üëë VIPs: ${this.vips.length} (${this.vips.join(', ')})`);
                console.log(`   üö´ Blacklist: ${this.blacklist.length} (${this.blacklist.join(', ')})`);

                // Initialize message deletion system
                console.log('üóëÔ∏è Syst√®me de suppression de messages initialis√©');
            }

            // Generate unique message ID
            generateMessageId() {
                return `msg_${++this.messageCounter}_${Date.now()}`;
            }

            // Remove message by username (for bans/timeouts)
            removeMessagesByUsername(username) {
                let removedCount = 0;
                const usernameLower = username.toLowerCase();

                for (const [messageId, messageData] of this.messages.entries()) {
                    if (messageData.username.toLowerCase() === usernameLower) {
                        // Remove from DOM
                        if (messageData.element && messageData.element.parentNode) {
                            messageData.element.parentNode.removeChild(messageData.element);
                        }
                        // Remove from storage
                        this.messages.delete(messageId);
                        removedCount++;
                    }
                }

                if (removedCount > 0) {
                    console.log(`üóëÔ∏è Supprim√© ${removedCount} messages de ${username} (ban/timeout)`);
                }
            }

            // Remove specific message by ID (for message deletions)
            removeMessageById(messageId) {
                const messageData = this.messages.get(messageId);
                if (messageData) {
                    // Remove from DOM
                    if (messageData.element && messageData.element.parentNode) {
                        messageData.element.parentNode.removeChild(messageData.element);
                    }
                    // Remove from storage
                    this.messages.delete(messageId);
                    console.log(`üóëÔ∏è Message supprim√©: ${messageId}`);
                    return true;
                }
                return false;
            }

            // Clean up old messages from storage - limit to 50 messages maximum
            cleanupOldMessages() {
                const maxStoredMessages = 50; // Maximum 50 messages in storage
                if (this.messages.size > maxStoredMessages) {
                    const sortedMessages = Array.from(this.messages.entries())
                        .sort((a, b) => a[1].timestamp - b[1].timestamp);

                    const toRemove = sortedMessages.slice(0, this.messages.size - maxStoredMessages);
                    toRemove.forEach(([messageId, messageData]) => {
                        // Remove from storage
                        this.messages.delete(messageId);
                        // Also remove from DOM if element still exists
                        if (messageData.element && messageData.element.parentNode) {
                            messageData.element.parentNode.removeChild(messageData.element);
                        }
                    });

                    console.log(`üßπ Nettoyage: ${toRemove.length} anciens messages supprim√©s (limite 50 atteinte)`);
                }
            }

            async startSharedChatCheck() {
                console.log('üîÑ D√©marrage de la v√©rification du chat partag√©...');

                // V√©rifier imm√©diatement
                await this.checkSharedChat();

                // Puis v√©rifier toutes les 5 secondes
                setInterval(async () => {
                    await this.checkSharedChat();
                }, 5000);
            }

                                    // Start periodic moderation check
            startModerationCheck() {
                console.log('üõ°Ô∏è D√©marrage de la v√©rification p√©riodique de mod√©ration...');

                // Check every second for moderation events
                setInterval(() => {
                    console.log('‚è∞ Intervalle de mod√©ration d√©clench√©');
                    this.checkModerationEvents();
                }, 1000);

                console.log('‚úÖ Intervalle de mod√©ration configur√© pour toutes les secondes');
            }

                        // Check for moderation events and clean up
            checkModerationEvents() {
                // Debug: log that this method is running
                console.log('üîÑ checkModerationEvents() appel√©');

                // Check for recent bans/timeouts every second
                this.checkRecentModerations();

                // Log storage status every 10 seconds for debugging
                if (Date.now() % 10000 < 1000) { // Every ~10 seconds
                    console.log(`üìä Status stockage: ${this.messages.size}/50 messages stock√©s`);
                }
            }

            // Check for recent bans and timeouts using Twitch API
            async checkRecentModerations() {
                try {
                    // Get recent bans for the channel
                    const response = await fetch(`https://api.twitch.tv/helix/moderation/banned?broadcaster_id=670947482&first=100`, {
                        headers: {
                            'Client-ID': 'gp762nuuoqcoxypju8c569th9wz7q5',
                            'Authorization': 'Bearer xrugdtwxy33q6p1dw0tg3nlkehj422'
                        }
                    });

                    if (!response.ok) {
                        if (response.status === 429) {
                            console.log('‚ö†Ô∏è Rate limit atteint, pause de 5 secondes');
                            return;
                        }
                        console.error(`‚ùå Erreur API mod√©ration: ${response.status}`);
                        return;
                    }

                    const data = await response.json();

                    if (data.data && data.data.length > 0) {
                        // Process each banned user
                        data.data.forEach(banData => {
                            const username = banData.user_login;
                            const banReason = banData.reason || 'Aucune raison sp√©cifi√©e';
                            const expiresAt = banData.expires_at;

                            // Check if this is a recent ban (within last 5 minutes)
                            const banTime = new Date(banData.created_at);
                            const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);

                            if (banTime > fiveMinutesAgo) {
                                // Check if we've already processed this ban
                                const banKey = `${username}_${banData.created_at}`;
                                if (!this.moderationCache.has(banKey)) {
                                    console.log(`üõ°Ô∏è Bannissement r√©cent d√©tect√©: ${username} - Raison: ${banReason}`);

                                    // Remove all messages from this user
                                    const removedCount = this.removeMessagesByUsername(username);

                                    if (removedCount > 0) {
                                        console.log(`üóëÔ∏è ${removedCount} messages supprim√©s de ${username} (bannissement r√©cent)`);
                                    }

                                    // Cache this ban to avoid reprocessing
                                    this.moderationCache.set(banKey, {
                                        username: username,
                                        reason: banReason,
                                        timestamp: Date.now()
                                    });

                                    // Clean up old cache entries (older than 10 minutes)
                                    this.cleanupModerationCache();
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.error('üí• Erreur lors de la v√©rification des mod√©rations:', error);
                }
            }

            // Clean up old moderation cache entries
            cleanupModerationCache() {
                const tenMinutesAgo = Date.now() - 10 * 60 * 1000;
                for (const [key, data] of this.moderationCache.entries()) {
                    if (data.timestamp < tenMinutesAgo) {
                        this.moderationCache.delete(key);
                    }
                }
            }

            // Detect IRC message type for debugging
            detectIRCMessageType(rawMessage) {
                if (rawMessage.includes('CLEARMSG')) return 'CLEARMSG';
                if (rawMessage.includes('CLEARCHAT')) return 'CLEARCHAT';
                if (rawMessage.includes('USERNOTICE')) return 'USERNOTICE';
                if (rawMessage.includes('PRIVMSG')) return 'PRIVMSG';
                if (rawMessage.includes('PING')) return 'PING';
                if (rawMessage.includes('PONG')) return 'PONG';
                if (rawMessage.includes('JOIN')) return 'JOIN';
                if (rawMessage.includes('PART')) return 'PART';
                if (rawMessage.includes('MODE')) return 'MODE';
                if (rawMessage.includes('NOTICE')) return 'NOTICE';
                if (rawMessage.includes('HOSTTARGET')) return 'HOSTTARGET';
                if (rawMessage.includes('RECONNECT')) return 'RECONNECT';
                if (rawMessage.includes('ROOMSTATE')) return 'ROOMSTATE';
                if (rawMessage.includes('USERSTATE')) return 'USERSTATE';
                if (rawMessage.includes('GLOBALUSERSTATE')) return 'GLOBALUSERSTATE';
                if (rawMessage.includes('CAP')) return 'CAP';
                if (rawMessage.includes('NICK')) return 'NICK';
                if (rawMessage.includes('PASS')) return 'PASS';
                return 'UNKNOWN';
            }

            async loadTwitchBadges(forceRefresh = false) {
                try {
                    // Check localStorage cache first (unless force refresh)
                    const cacheKey = `twitch_badges_${this.broadcasterId}`;
                    const cacheTimestampKey = `twitch_badges_timestamp_${this.broadcasterId}`;
                    const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours

                    if (!forceRefresh) {
                        const cachedData = localStorage.getItem(cacheKey);
                        const cacheTimestamp = localStorage.getItem(cacheTimestampKey);

                        if (cachedData && cacheTimestamp) {
                            const age = Date.now() - parseInt(cacheTimestamp, 10);
                            if (age < CACHE_DURATION) {
                                try {
                                    const parsed = JSON.parse(cachedData);
                                    if (parsed && (parsed.channel || parsed.global)) {
                                        (parsed.channel || []).forEach(badge => {
                                            if (badge && badge.set_id) this.badgeCache.set(badge.set_id, badge);
                                        });
                                        (parsed.global || []).forEach(badge => {
                                            if (badge && badge.set_id) this.globalBadgeCache.set(badge.set_id, badge);
                                        });
                                        console.log(`‚úÖ Badges charg√©s depuis le cache (${Math.round(age / 1000 / 60)} minutes)`);
                                        console.log(`üè∑Ô∏è Total badges: ${this.badgeCache.size} cha√Æne + ${this.globalBadgeCache.size} globaux`);
                                        return; // Skip API calls
                                    }
                                } catch (parseErr) {
                                    console.warn('‚ö†Ô∏è Cache badges localStorage corrompu (ex: apr√®s crash), vidage et rechargement API:', parseErr.message);
                                    try {
                                        localStorage.removeItem(cacheKey);
                                        localStorage.removeItem(cacheTimestampKey);
                                    } catch (e) { /* ignore */ }
                                }
                            } else {
                                console.log('üîÑ Cache expir√©, rechargement depuis l\'API...');
                            }
                        }
                    }

                    console.log('üè∑Ô∏è Chargement des badges Twitch depuis l\'API...');

                    // Charger les badges de la cha√Æne
                    const channelResponse = await fetch(`https://api.twitch.tv/helix/chat/badges?broadcaster_id=${this.broadcasterId}`, {
                        headers: {
                            'Client-ID': this.twitchClientId,
                            'Authorization': `Bearer ${this.twitchAuthToken}`
                        }
                    });

                    if (channelResponse.ok) {
                        const channelData = await channelResponse.json();
                        console.log('üìä Badges de cha√Æne re√ßus:', channelData);

                        if (channelData.data) {
                            channelData.data.forEach(badge => {
                                this.badgeCache.set(badge.set_id, {
                                    id: badge.set_id,
                                    versions: badge.versions
                                });
                            });
                            console.log(`‚úÖ ${channelData.data.length} badges de cha√Æne charg√©s`);
                        }
                    } else {
                        console.error('‚ùå Erreur lors du chargement des badges de cha√Æne:', channelResponse.status);
                    }

                    // Charger les badges globaux
                    const globalResponse = await fetch('https://api.twitch.tv/helix/chat/badges/global', {
                        headers: {
                            'Client-ID': this.twitchClientId,
                            'Authorization': `Bearer ${this.twitchAuthToken}`
                        }
                    });

                    if (globalResponse.ok) {
                        const globalData = await globalResponse.json();
                        console.log('üìä Badges globaux re√ßus:', globalData);

                        if (globalData.data) {
                            globalData.data.forEach(badge => {
                                this.globalBadgeCache.set(badge.set_id, {
                                    id: badge.set_id,
                                    versions: badge.versions
                                });
                            });
                            console.log(`‚úÖ ${globalData.data.length} badges globaux charg√©s`);
                        }
                    } else {
                        console.error('‚ùå Erreur lors du chargement des badges globaux:', globalResponse.status);
                    }

                    console.log(`üè∑Ô∏è Total badges charg√©s: ${this.badgeCache.size} cha√Æne + ${this.globalBadgeCache.size} globaux`);

                    // Save to localStorage cache
                    const cacheData = {
                        channel: Array.from(this.badgeCache.values()),
                        global: Array.from(this.globalBadgeCache.values())
                    };
                    localStorage.setItem(cacheKey, JSON.stringify(cacheData));
                    localStorage.setItem(cacheTimestampKey, Date.now().toString());
                    console.log('üíæ Badges sauvegard√©s dans le cache localStorage');
                } catch (error) {
                    console.error('üí• Erreur lors du chargement des badges Twitch:', error);

                    // Try to load from cache even if API fails (only if not corrupted)
                    const cacheKey = `twitch_badges_${this.broadcasterId}`;
                    const cachedData = localStorage.getItem(cacheKey);
                    if (cachedData) {
                        try {
                            const parsed = JSON.parse(cachedData);
                            if (parsed && (parsed.channel || parsed.global)) {
                                console.log('‚ö†Ô∏è Utilisation du cache en cas d\'erreur API...');
                                (parsed.channel || []).forEach(badge => {
                                    if (badge && badge.set_id) this.badgeCache.set(badge.set_id, badge);
                                });
                                (parsed.global || []).forEach(badge => {
                                    if (badge && badge.set_id) this.globalBadgeCache.set(badge.set_id, badge);
                                });
                            }
                        } catch (parseErr) {
                            console.warn('‚ö†Ô∏è Cache de secours corrompu, ignor√©:', parseErr.message);
                            try {
                                localStorage.removeItem(`twitch_badges_${this.broadcasterId}`);
                                localStorage.removeItem(`twitch_badges_timestamp_${this.broadcasterId}`);
                            } catch (e) { /* ignore */ }
                        }
                    }
                }
            }

            getBadgeUrl(badgeType, version = '1') {
                try {
                    // Chercher d'abord dans les badges de cha√Æne
                    if (this.badgeCache.has(badgeType)) {
                        const badge = this.badgeCache.get(badgeType);
                        const badgeVersion = badge.versions.find(v => v.id === version) || badge.versions[0];
                        if (badgeVersion) {
                            return badgeVersion.image_url_1x;
                        }
                    }

                    // Chercher dans les badges globaux
                    if (this.globalBadgeCache.has(badgeType)) {
                        const badge = this.globalBadgeCache.get(badgeType);
                        const badgeVersion = badge.versions.find(v => v.id === version) || badge.versions[0];
                        if (badgeVersion) {
                            return badgeVersion.image_url_1x;
                        }
                    }

                    // Fallback: retourner null pour utiliser les images locales
                    return null;
                } catch (error) {
                    console.error('‚ùå Erreur lors de la r√©cup√©ration du badge:', error);
                    return null;
                }
            }

            // Obtenir l'URL CDN d'un badge avec mapping des IDs
            getBadgeCDNUrl(badgeType, version = '1') {
                // Mapping des types de badges vers leurs IDs CDN Twitch
                // Seulement les badges avec des IDs CDN valides sont inclus ici
                // Les autres badges utiliseront le fallback local automatiquement
                const badgeIdMap = {
                    'broadcaster': '5527c58c-fb7d-422d-b71b-f309dcb85cc1',
                    'moderator': '3267646d-33f0-4b17-b3df-f923a41db1d0',
                    'vip': 'b817aba4-fad8-49e2-b88a-7cc744dfa6ec',
                    'subscriber': '5d9f2208-5dd8-11e7-8513-2ff4adfae661',
                    'predictions': '73e8b446-2ca8-4dc7-912c-e35fc11d1c4e',
                    'bits': 'cheer', // Special case - uses cheer endpoint
                    'bits-leader': '2eb4a8b9-0f3c-4c78-b9e0-0b6145702499',
                    'founder': '511b78a9-3667-47f2-bc1c-4f3c49414969',
                    'hype-train': '43b3d9c7-4c54-4e2c-9b89-6534659f4e1a',
                    'charity': '4e25f0c1-3517-4a8b-8b58-4c0b3e5e5ab0',
                    'extension': 'df3a4a18-6097-4f94-a0f0-776b0a77c8e1',
                    // Les badges hi√©rarchiques utilisent le badge moderator
                    'admin': '3267646d-33f0-4b17-b3df-f923a41db1d0',
                    'staff': '3267646d-33f0-4b17-b3df-f923a41db1d0',
                    'global_mod': '3267646d-33f0-4b17-b3df-f923a41db1d0',
                    'lead-moderator': '0822047b-65e0-46f2-94a9-d1091d685d33', // Lead Moderator badge ID
                    'lead_moderator': '0822047b-65e0-46f2-94a9-d1091d685d33' // Support underscore format from IRC
                };

                const badgeId = badgeIdMap[badgeType];
                if (!badgeId) {
                    return null; // Pas d'ID CDN valide, retourner null pour utiliser le fallback local
                }

                // Special handling for bits/cheer badges
                if (badgeType === 'bits' && badgeId === 'cheer') {
                    return `https://static-cdn.jtvnw.net/badges/v1/cheer/${version}`;
                }

                return `https://static-cdn.jtvnw.net/badges/v1/${badgeId}/${version}`;
            }

            // Pr√©charger et mettre en cache une image de badge depuis le CDN (asynchrone en arri√®re-plan)
            cacheBadgeImage(cdnUrl) {
                // Si d√©j√† en cache, ne rien faire
                if (this.badgeImageCache.has(cdnUrl)) {
                    return;
                }

                // Marquer comme en cours de chargement pour √©viter les doublons
                this.badgeImageCache.set(cdnUrl, 'loading');

                // Pr√©charger l'image en arri√®re-plan
                const img = new Image();
                img.onload = () => {
                    // Mettre en cache l'√©l√©ment image une fois charg√©
                    this.badgeImageCache.set(cdnUrl, img);
                };
                img.onerror = () => {
                    // En cas d'erreur, retirer du cache pour permettre un nouvel essai
                    this.badgeImageCache.delete(cdnUrl);
                    console.warn(`‚ö†Ô∏è Impossible de charger le badge depuis le CDN: ${cdnUrl}`);
                };
                img.src = cdnUrl;
            }

            // Obtenir l'URL d'un badge avec priorit√©: API > CDN > Local (synchrone)
            getBadgeImageUrl(badgeType, version = '1', localFallback = null) {
                // 1. Essayer d'abord l'API Twitch
                const apiUrl = this.getBadgeUrl(badgeType, version);
                if (apiUrl) {
                    this.cacheBadgeImage(apiUrl); // Pr√©charger en arri√®re-plan
                    return apiUrl;
                }

                // 2. Essayer le CDN Twitch
                const cdnUrl = this.getBadgeCDNUrl(badgeType, version);
                if (cdnUrl) {
                    this.cacheBadgeImage(cdnUrl); // Pr√©charger en arri√®re-plan
                    return cdnUrl;
                }

                // 3. Fallback local
                return localFallback;
            }

            // M√©thodes pour g√©rer les commandes de chat
            isModerator(username) {
                return this.moderators.includes(username.toLowerCase());
            }

            isVIP(username) {
                return this.vips.includes(username.toLowerCase());
            }

            isBlacklisted(username) {
                return this.blacklist.includes(username.toLowerCase());
            }

            hasCommandPermission(username) {
                const lowerUsername = username.toLowerCase();
                return this.isModerator(lowerUsername) || this.isVIP(lowerUsername);
            }

            handleChatCommand(username, message) {
                const lowerMessage = message.toLowerCase();
                const lowerUsername = username.toLowerCase();

                // V√©rifier si l'utilisateur est mod√©rateur ou VIP
                const hasPermission = this.isModerator(lowerUsername) || this.isVIP(lowerUsername);

                if (!hasPermission) {
                    console.log(`üö´ Commande refus√©e: ${username} n'a pas les permissions (${lowerMessage})`);
                    return false;
                }

                // Commandes de rechargement
                if (lowerMessage === '!chatreload' || lowerMessage === '!chatrefresh') {
                    console.log(`üîÑ Commande de rechargement ex√©cut√©e par ${username}: ${lowerMessage}`);
                    this.executePageReload();
                    return true;
                }

                // Commande de rechargement forc√© (avec cache clear)
                if (lowerMessage === '!chatforcereload') {
                    console.log(`üîÑ Commande de rechargement FORC√â (cache clear) ex√©cut√©e par ${username}: ${lowerMessage}`);
                    this.executeForceReload();
                    return true;
                }

                // Commande pour vider le cache badges et recharger depuis l'API sans reload de la page
                // Utile quand !chatforcereload ne suffit pas (ex: CEF OBS gel√©) ou pour forcer un refetch.
                if (lowerMessage === '!chatclearbadges') {
                    console.log(`üóëÔ∏è Commande !chatclearbadges ex√©cut√©e par ${username}`);
                    this.clearBadgeCacheAndReload();
                    return true;
                }

                return false;
            }

            clearBadgeCacheAndReload() {
                try {
                    localStorage.removeItem(`twitch_badges_${this.broadcasterId}`);
                    localStorage.removeItem(`twitch_badges_timestamp_${this.broadcasterId}`);
                    this.badgeCache.clear();
                    this.globalBadgeCache.clear();
                    this.badgeImageCache.clear();
                    console.log('üóëÔ∏è Cache badges vid√© (localStorage + m√©moire), rechargement depuis l\'API...');
                    this.loadTwitchBadges(true);
                } catch (e) {
                    console.error('‚ùå Erreur clearBadgeCacheAndReload:', e);
                }
            }

            executePageReload() {
                console.log('üîÑ Rechargement simple de la page (cache conserv√©)...');
                // Rechargement simple - utilise le cache du navigateur
                window.location.reload();
            }

            executeForceReload() {
                console.log('üîÑ Rechargement FORC√â de la page (cache vid√©)...');
                // IMPORTANT: Clear badge localStorage before reload. After a PC/OBS crash, the
                // badge cache can be corrupted. A simple location.reload() would load that
                // corrupted cache again. Clearing it here forces the next load to fetch from API.
                try {
                    localStorage.removeItem(`twitch_badges_${this.broadcasterId}`);
                    localStorage.removeItem(`twitch_badges_timestamp_${this.broadcasterId}`);
                    console.log('üóëÔ∏è Cache badges localStorage vid√©');
                } catch (e) {
                    console.warn('‚ö†Ô∏è Impossible de vider le cache badges:', e);
                }
                // Rechargement forc√© avec cache-busting pour forcer le rechargement complet
                const url = new URL(window.location.href);
                url.searchParams.set('_nocache', Date.now().toString());
                window.location.replace(url.toString());
            }

            // M√©thode de test pour v√©rifier les permissions (√† appeler depuis la console)
            testCommandPermissions(username) {
                console.log(`üß™ Test des permissions pour: ${username}`);
                console.log(`   üëÆ Mod√©rateur: ${this.isModerator(username)}`);
                console.log(`   üëë VIP: ${this.isVIP(username)}`);
                console.log(`   üö´ Blacklist√©: ${this.isBlacklisted(username)}`);
                console.log(`   ‚úÖ Peut utiliser les commandes: ${this.hasCommandPermission(username)}`);
            }

            // M√©thode de test pour d√©clencher un rechargement manuellement
            testReload() {
                console.log('üß™ Test de rechargement manuel...');
                this.executePageReload();
            }

            async checkSharedChat() {
                try {
                    console.log('üîç V√©rification du chat partag√©...');

                    const response = await fetch('https://api.twitch.tv/helix/shared_chat/session?broadcaster_id=140846786', {
                        headers: {
                            'Authorization': 'Bearer xrugdtwxy33q6p1dw0tg3nlkehj422',
                            'Client-Id': 'gp762nuuoqcoxypju8c569th9wz7q5'
                        }
                    });

                    if (!response.ok) {
                        console.log('‚ùå Erreur API chat partag√©:', response.status, response.statusText);
                        this.isSharedChatActive = false;
                        this.sharedChatParticipants.clear();
                        return;
                    }

                    const data = await response.json();
                    console.log('üìä R√©ponse API chat partag√©:', data);

                    if (data.data && data.data.length > 0) {
                        const session = data.data[0];
                        const participants = session.participants || [];

                        // Mettre √† jour la liste des participants
                        this.sharedChatParticipants.clear();
                        participants.forEach(p => this.sharedChatParticipants.add(p.broadcaster_id));

                        // Chat partag√© actif s'il y a plus d'un participant
                        this.isSharedChatActive = participants.length > 1;

                        console.log(`ü§ù Chat partag√©: ${this.isSharedChatActive ? 'ACTIF' : 'INACTIF'}`);
                        console.log(`üë• Participants: ${participants.length} (${Array.from(this.sharedChatParticipants).join(', ')})`);
                    } else {
                        console.log('‚ö™ Aucune session de chat partag√© trouv√©e');
                        this.isSharedChatActive = false;
                        this.sharedChatParticipants.clear();
                    }
                } catch (error) {
                    console.error('üí• Erreur lors de la v√©rification du chat partag√©:', error);
                    this.isSharedChatActive = false;
                    this.sharedChatParticipants.clear();
                }
            }

            connectToTwitchChat() {
                // Connexion WebSocket au chat IRC de Twitch
                const socket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');

                socket.onopen = () => {
                    console.log('Connect√© au chat Twitch de fugu_fps');
                    // Connexion anonyme au chat IRC de Twitch avec support des tags
                    socket.send('CAP REQ :twitch.tv/tags twitch.tv/commands');
                    socket.send('PASS SCHMOOPIIE');
                    socket.send('NICK justinfan12345'); // Utilisateur anonyme
                    socket.send('JOIN #fugu_fps'); // Rejoindre le canal de fugu_fps
                };

                socket.onmessage = (event) => {
                    const message = event.data;

                    // R√©pondre aux PING pour maintenir la connexion
                    if (message.startsWith('PING')) {
                        socket.send('PONG :tmi.twitch.tv');
                        return;
                    }

                    // Parser les messages de chat
                    this.parseIRCMessage(message);
                };

                socket.onerror = (error) => {
                    console.error('Erreur de connexion au chat Twitch:', error);
                };

                socket.onclose = () => {
                    console.log('Connexion au chat Twitch ferm√©e');
                    // Tentative de reconnexion apr√®s 5 secondes
                    setTimeout(() => {
                        console.log('Tentative de reconnexion...');
                        this.connectToTwitchChat();
                    }, 5000);
                };
            }

            async getChannelInfo(roomId) {
                if (this.channelCache.has(roomId)) {
                    return this.channelCache.get(roomId);
                }

                try {
                    console.log(`üè¢ R√©cup√©ration des infos pour room-id: ${roomId}`);
                    const res = await fetch(`https://api.twitch.tv/helix/users?id=${roomId}`, {
                        headers: {
                            'Client-ID': 'gp762nuuoqcoxypju8c569th9wz7q5',
                            'Authorization': 'Bearer m15k59400wm8tosv4499famn76qpr3'
                        }
                    });

                    if (!res.ok) {
                        console.error(`‚ùå Erreur API Twitch: ${res.status} ${res.statusText}`);
                        return null;
                    }

                    const json = await res.json();
                    console.log(`üìä R√©ponse API pour room-id ${roomId}:`, json);

                    if (json.data && json.data[0]) {
                        const channel = {
                            displayName: json.data[0].display_name,
                            login: json.data[0].login,
                            profileImage: json.data[0].profile_image_url
                        };
                        console.log(`‚úÖ Infos channel r√©cup√©r√©es:`, channel);
                        this.channelCache.set(roomId, channel);
                        return channel;
                    } else {
                        console.log(`‚ùå Aucune donn√©e trouv√©e pour room-id ${roomId}`);
                    }
                } catch (err) {
                    console.error('üí• Erreur lors de la r√©cup√©ration du channel info pour', roomId, err);
                }

                return null;
            }

            // Handle CLEARMSG events (individual message deletions)
            handleClearMsg(rawMessage) {
                try {
                    console.log('üóëÔ∏è CLEARMSG d√©tect√© (suppression de message):', rawMessage);

                    // Extract the target message ID
                    const msgIdMatch = rawMessage.match(/target-msg-id=([^;]*)/);
                    if (!msgIdMatch) {
                        console.log('‚ùå Impossible d\'extraire l\'ID du message supprim√©');
                        return;
                    }

                    const twitchMsgId = msgIdMatch[1];
                    console.log(`üéØ ID du message supprim√©: ${twitchMsgId}`);

                    // Extract the deleted message content for verification
                    const messageMatch = rawMessage.match(/CLEARMSG #\w+ :(.+)/);
                    const deletedContent = messageMatch ? messageMatch[1].trim() : '';
                    console.log(`üìù Contenu supprim√©: "${deletedContent}"`);

                    // Remove the specific message by Twitch ID
                    const removed = this.removeMessageByTwitchId(twitchMsgId);

                    if (removed) {
                        console.log(`‚úÖ Message supprim√© avec succ√®s: ${twitchMsgId}`);
                    } else {
                        console.log(`‚ùå Message non trouv√© dans le stockage: ${twitchMsgId}`);
                    }

                } catch (error) {
                    console.error('‚ùå Erreur lors du traitement CLEARMSG:', error);
                }
            }

            // Handle CLEARCHAT events (bans, timeouts, message deletions)
            handleClearChat(rawMessage) {
                try {
                    console.log('üõ°Ô∏è CLEARCHAT d√©tect√©:', rawMessage);

                    // Extract target username and message ID
                    const targetMatch = rawMessage.match(/CLEARCHAT #\w+ :(.+)/);
                    if (!targetMatch) return;

                    const targetUsername = targetMatch[1].trim();
                    console.log(`üéØ Utilisateur cibl√© par CLEARCHAT: ${targetUsername}`);

                    // Check if it's a ban/timeout (username present) or message deletion (no username)
                    if (targetUsername && targetUsername !== '') {
                        // This is a ban or timeout - remove all messages from this user
                        this.removeMessagesByUsername(targetUsername);
                        console.log(`üóëÔ∏è Messages de ${targetUsername} supprim√©s (ban/timeout)`);
                    } else {
                        // This might be a message deletion - we'd need more context
                        console.log('üìù CLEARCHAT sans utilisateur - possible suppression de message');
                    }

                    // Enhanced: Try to extract message ID for specific deletions
                    const msgIdMatch = rawMessage.match(/target-msg-id=([^;]*)/);
                    if (msgIdMatch && msgIdMatch[1]) {
                        const twitchMsgId = msgIdMatch[1];
                        console.log(`üÜî ID du message supprim√©: ${twitchMsgId}`);
                        this.removeMessageByTwitchId(twitchMsgId);
                    }
                } catch (error) {
                    console.error('‚ùå Erreur lors du traitement CLEARCHAT:', error);
                }
            }

            // Handle USERNOTICE events (subscriptions, raids, etc.)
            handleUserNotice(rawMessage) {
                try {
                    console.log('üì¢ USERNOTICE d√©tect√©:', rawMessage);

                    // Check for message deletion notices
                    if (rawMessage.includes('msg-id=delete')) {
                        console.log('üóëÔ∏è Suppression de message d√©tect√©e');
                        // Extract message ID if available
                        const msgIdMatch = rawMessage.match(/msg-id=delete_(\w+)/);
                        if (msgIdMatch) {
                            const msgId = msgIdMatch[1];
                            console.log(`üéØ ID du message supprim√©: ${msgId}`);
                            // Note: We'd need to map this to our internal message IDs
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Erreur lors du traitement USERNOTICE:', error);
                }
            }

            // Enhanced message deletion by finding similar content
            removeMessageByContent(username, content) {
                let removedCount = 0;
                const usernameLower = username.toLowerCase();
                const contentLower = content.toLowerCase();

                for (const [messageId, messageData] of this.messages.entries()) {
                    if (messageData.username.toLowerCase() === usernameLower &&
                        messageData.text.toLowerCase().includes(contentLower)) {
                        // Remove from DOM
                        if (messageData.element && messageData.element.parentNode) {
                            messageData.element.parentNode.removeChild(messageData.element);
                        }
                        // Remove from storage
                        this.messages.delete(messageId);
                        removedCount++;
                    }
                }

                if (removedCount > 0) {
                    console.log(`üóëÔ∏è Supprim√© ${removedCount} messages de ${username} avec contenu similaire`);
                    return true;
                }
                return false;
            }

            // Remove message by Twitch message ID (for moderation)
            removeMessageByTwitchId(twitchMessageId) {
                let removedCount = 0;

                for (const [messageId, messageData] of this.messages.entries()) {
                    if (messageData.twitchMessageId === twitchMessageId) {
                        console.log(`üéØ Message trouv√© par ID Twitch: ${twitchMessageId}, supprim√©`);

                        // Remove from DOM
                        if (messageData.element && messageData.element.parentNode) {
                            messageData.element.parentNode.removeChild(messageData.element);
                        }

                        // Remove from storage
                        this.messages.delete(messageId);
                        removedCount++;
                        break; // Only remove the first match
                    }
                }

                if (removedCount > 0) {
                    console.log(`üóëÔ∏è Message supprim√© par ID Twitch: ${twitchMessageId}`);
                    return true;
                } else {
                    console.log(`‚ùå Aucun message trouv√© avec l'ID Twitch: ${twitchMessageId}`);
                    return false;
                }
            }



                        async parseIRCMessage(rawMessage) {
                // Debug: Log EVERY IRC message for analysis
                if (this.debugMode) {
                    const timestamp = new Date().toISOString();
                    const logEntry = {
                        timestamp: timestamp,
                        rawMessage: rawMessage,
                        type: this.detectIRCMessageType(rawMessage)
                    };

                    this.ircMessageLog.push(logEntry);

                    // Keep only last 100 messages in log
                    if (this.ircMessageLog.length > 100) {
                        this.ircMessageLog.shift();
                    }

                    // Log to console for real-time debugging
                    console.log(`üîç IRC DEBUG [${logEntry.type}]: ${rawMessage}`);
                }

                // Handle moderation events first
                if (rawMessage.includes('CLEARMSG')) {
                    this.handleClearMsg(rawMessage);
                    return;
                }

                if (rawMessage.includes('CLEARCHAT')) {
                    this.handleClearChat(rawMessage);
                    return;
                }

                if (rawMessage.includes('USERNOTICE')) {
                    this.handleUserNotice(rawMessage);
                    return;
                }

                // Parser les messages IRC de Twitch
                if (!rawMessage.includes('PRIVMSG')) return;

                try {
                    // Debug - afficher le message brut
                    console.log('Message brut IRC:', rawMessage);

                    // M√©thode am√©lior√©e pour extraire le nom d'utilisateur
                    // Chercher le pattern :username!username@username.tmi.twitch.tv
                    let username = 'Anonyme';

                    // Chercher le nom d'utilisateur juste avant "PRIVMSG"
                    const privmsgMatch = rawMessage.match(/\s:([^!]+)![^@]+@[^\.]+\.tmi\.twitch\.tv\s+PRIVMSG/);
                    if (privmsgMatch) {
                        username = privmsgMatch[1];
                    } else {
                        // M√©thode de fallback - chercher display-name dans les tags
                        const displayNameMatch = rawMessage.match(/display-name=([^;]*)/);
                        if (displayNameMatch && displayNameMatch[1]) {
                            username = displayNameMatch[1];
                        } else {
                            // Derni√®re m√©thode de fallback
                            const fallbackMatch = rawMessage.match(/:([^!]+)!/);
                            if (fallbackMatch) {
                                username = fallbackMatch[1];
                            }
                        }
                    }

                    // Extraire room-id pour identifier la cha√Æne d'origine
                    const roomIdMatch = rawMessage.match(/room-id=(\d+)/);
                    const roomId = roomIdMatch ? roomIdMatch[1] : null;
                    console.log(`üè† Room ID d√©tect√©: ${roomId}`);

                    // R√©cup√©rer les infos de la cha√Æne d'origine si disponible
                    let channelInfo = null;
                    if (roomId) {
                        channelInfo = await this.getChannelInfo(roomId);
                        if (channelInfo) {
                            console.log(`üè¢ Cha√Æne d'origine: ${channelInfo.displayName}`);
                        }
                    }

                    // Extraire les emotes Twitch depuis les tags IRC
                    let twitchEmotes = null;
                    const emotesMatch = rawMessage.match(/emotes=([^;]*)/);
                    if (emotesMatch && emotesMatch[1] && emotesMatch[1] !== '') {
                        twitchEmotes = emotesMatch[1];
                    }

                    // M√©thode plus simple pour extraire le message
                                    // Chercher tout ce qui suit "PRIVMSG #fugu_fps :"
                const privmsgIndex = rawMessage.indexOf('PRIVMSG #fugu_fps :');
                let messageText = '';

                if (privmsgIndex !== -1) {
                    messageText = rawMessage.substring(privmsgIndex + 'PRIVMSG #fugu_fps :'.length);
                        // Nettoyer les caract√®res de fin de ligne
                        messageText = messageText.replace(/\r\n?|\n/g, '');
                    }

                    // Extraire les badges depuis les tags IRC
                    const badges = this.extractBadges(rawMessage);

                    // Extraire la couleur personnalis√©e de l'utilisateur
                    // console.log('üéØ Appel extractUserColor pour:', username);
                    let userColor = null;
                    try {
                        userColor = this.extractUserColor(rawMessage);
                        // console.log('üéØ R√©sultat extractUserColor pour', username, ':', userColor);
                    } catch (error) {
                        // console.error('‚ùå Erreur dans extractUserColor:', error);
                        userColor = null;
                    }

                    // Extraire l'ID du message Twitch pour la mod√©ration
                    let twitchMessageId = null;
                    const messageIdMatch = rawMessage.match(/id=([^;]*)/);
                    if (messageIdMatch && messageIdMatch[1]) {
                        twitchMessageId = messageIdMatch[1];
                        console.log(`üÜî ID du message Twitch: ${twitchMessageId}`);
                    }

                    // Debug - afficher les messages pars√©s
                    console.log('Message pars√©:', { username, messageText, badges, twitchEmotes, userColor, channelInfo, twitchMessageId });

                    // V√©rifier et traiter les commandes de chat
                    if (messageText.trim() && (messageText.startsWith('!chatreload') || messageText.startsWith('!chatrefresh') || messageText.startsWith('!chatforcereload') || messageText.startsWith('!chatclearbadges'))) {
                        const commandHandled = this.handleChatCommand(username, messageText);
                        if (commandHandled) {
                            // console.log(`‚úÖ Commande trait√©e par ${username}: ${messageText}`);
                            return; // Ne pas afficher la commande dans le chat
                        }
                    }

                    // Ajouter le message au chat seulement s'il y a du texte
                    if (messageText.trim()) {
                        this.addMessage({
                            nick: username,
                            text: messageText,
                            badges: badges,
                            twitchEmotes: twitchEmotes,
                            userColor: userColor,
                            originChannel: channelInfo, // facultatif si null
                            twitchMessageId: twitchMessageId // ID Twitch pour la mod√©ration
                        });
                    }
                } catch (error) {
                    // console.error('Erreur lors du parsing du message:', error);
                }
            }

            async loadSevenTVEmotes() {
                try {
                    // console.log('üöÄ D√©but du chargement des emotes 7TV...');

                    // Charger les emotes globales 7TV
                    // console.log('üì° R√©cup√©ration des emotes globales...');
                    const globalResponse = await fetch('https://7tv.io/v3/emote-sets/global');
                    // console.log('üåê R√©ponse globale:', globalResponse.status, globalResponse.statusText);

                    if (globalResponse.ok) {
                        const globalData = await globalResponse.json();
                        // console.log('üì¶ Donn√©es globales re√ßues:', globalData);

                        if (globalData.emotes && Array.isArray(globalData.emotes)) {
                            // console.log(`üìä Nombre d'emotes globales trouv√©es: ${globalData.emotes.length}`);

                            globalData.emotes.forEach((emote, index) => {
                                if (index < 5) {
                                    // console.log(`üîç Emote globale ${index}:`, emote);
                                }

                                // Nouveau format 7TV - structure diff√©rente
                                if (emote.name && emote.data && emote.data.host && emote.data.host.files) {
                                    // Construire les URLs √† partir des fichiers
                                    const urls = emote.data.host.files.map(file => `//${emote.data.host.url}/${file.name}`);

                                    this.globalSevenTVEmotes.set(emote.name, {
                                        id: emote.id,
                                        name: emote.name,
                                        urls: urls
                                    });

                                    if (index < 5) {
                                        // console.log(`‚úÖ Emote globale ${index} ajout√©e:`, emote.name, urls);
                                    }
                                } else {
                                    if (index < 5) {
                                        // console.log(`‚ùå Emote globale ${index} incompl√®te:`, emote);
                                    }
                                }
                            });
                        } else {
                            console.log('‚ùå Pas d\'emotes dans la r√©ponse globale ou format incorrect');
                        }
                    } else {
                        console.error('‚ùå √âchec de r√©cup√©ration des emotes globales:', globalResponse.status);
                    }

                                    // Charger les emotes sp√©cifiques au canal fugu_fps directement via l'ID du set
                console.log('üì° R√©cup√©ration des emotes du canal fugu_fps via le set ID...');

                    const setResponse = await fetch('https://7tv.io/v3/emote-sets/01GEG2EPE80006SAE3KT92JGK5');
                    console.log('ÔøΩ R√©ponse set d\'emotes:', setResponse.status, setResponse.statusText);

                    if (setResponse.ok) {
                        const setData = await setResponse.json();
                        console.log('üì¶ Donn√©es du set re√ßues:', setData);

                        if (setData.emotes && Array.isArray(setData.emotes)) {
                            console.log(`üìä Nombre d'emotes du canal trouv√©es: ${setData.emotes.length}`);

                            setData.emotes.forEach((emote, index) => {
                                if (index < 10) {
                                    console.log(`üîç Emote canal ${index}:`, emote);
                                }

                                // Nouveau format 7TV - structure diff√©rente
                                if (emote.name && emote.data && emote.data.host && emote.data.host.files) {
                                    // Construire les URLs √† partir des fichiers
                                    const urls = emote.data.host.files.map(file => `//${emote.data.host.url}/${file.name}`);

                                    this.sevenTVEmotes.set(emote.name, {
                                        id: emote.id,
                                        name: emote.name,
                                        urls: urls
                                    });

                                    if (index < 10) {
                                        console.log(`‚úÖ Emote canal ${index} ajout√©e:`, emote.name, urls);
                                    }
                                } else {
                                    if (index < 10) {
                                        console.log(`‚ùå Emote canal ${index} incompl√®te:`, emote);
                                    }
                                }
                            });
                        } else {
                            console.log('‚ùå Pas d\'emotes dans la r√©ponse du set ou format incorrect');
                        }
                    } else {
                        console.error('‚ùå √âchec de r√©cup√©ration des emotes du set:', setResponse.status);
                    }

                    console.log(`‚úÖ 7TV emotes charg√©es: ${this.sevenTVEmotes.size} emotes du canal + ${this.globalSevenTVEmotes.size} emotes globales`);

                    // Debug - afficher toutes les emotes du canal pour v√©rifier
                    if (this.sevenTVEmotes.size > 0) {
                        console.log('üìã Toutes les emotes du canal fugu_fps:', Array.from(this.sevenTVEmotes.keys()).sort());
                    }
                    if (this.globalSevenTVEmotes.size > 0) {
                        console.log('üìã Exemples d\'emotes globales:', Array.from(this.globalSevenTVEmotes.keys()).slice(0, 20));
                    }

                    // V√©rifier sp√©cifiquement certaines emotes
                    const testEmotes = ['WHAT', 'LeaClassic', 'Kappa', 'KEKW', 'CDEC', 'EZ'];
                    testEmotes.forEach(emote => {
                        const inChannel = this.sevenTVEmotes.has(emote);
                        const inGlobal = this.globalSevenTVEmotes.has(emote);
                        console.log(`üîé Emote "${emote}" - Canal: ${inChannel}, Global: ${inGlobal}`);

                        // Afficher l'URL de l'emote si trouv√©e
                        if (inChannel) {
                            const emoteData = this.sevenTVEmotes.get(emote);
                            console.log(`üì∏ URL emote "${emote}":`, emoteData.urls);
                        } else if (inGlobal) {
                            const emoteData = this.globalSevenTVEmotes.get(emote);
                            console.log(`üì∏ URL emote "${emote}":`, emoteData.urls);
                        }
                    });

                } catch (error) {
                    console.error('üí• Erreur lors du chargement des emotes 7TV:', error);
                    console.error('üìç Stack trace:', error.stack);
                }
            }

            parseSevenTVEmotes(message) {
                if (!message) return message;

                console.log('üîç Parsing 7TV emotes pour:', message);

                // Diviser le message en mots et traiter chaque mot individuellement
                const words = message.split(/(\s+)/); // Garde les espaces dans le tableau
                console.log('üìù Mots d√©tect√©s:', words);

                for (let i = 0; i < words.length; i++) {
                    let word = words[i].trim();
                    if (!word) continue; // Ignorer les espaces vides

                    // console.log(`üîé V√©rification du mot: "${word}"`);

                    let emoteFound = false;
                    let emoteData = null;

                    // Chercher dans les emotes du canal d'abord (priorit√©)
                    if (this.sevenTVEmotes.has(word)) {
                        emoteData = this.sevenTVEmotes.get(word);
                        emoteFound = true;
                        // console.log(`‚úÖ Emote trouv√©e dans le canal: ${word}`, emoteData);
                    }
                    // Chercher dans les emotes globales si pas trouv√© dans le canal
                    else if (this.globalSevenTVEmotes.has(word)) {
                        emoteData = this.globalSevenTVEmotes.get(word);
                        emoteFound = true;
                        // console.log(`‚úÖ Emote trouv√©e globalement: ${word}`, emoteData);
                    }

                    if (emoteFound && emoteData && emoteData.urls && Array.isArray(emoteData.urls)) {
                        // Chercher l'URL appropri√©e (priorit√© aux tailles plus grandes)
                        const imageUrl = emoteData.urls.find(url => url.includes('2x.webp')) ||
                                        emoteData.urls.find(url => url.includes('1x.webp')) ||
                                        emoteData.urls[0];

                        if (imageUrl) {
                            const fullUrl = imageUrl.startsWith('//') ? `https:${imageUrl}` : imageUrl;
                            const emoteImg = `<img class="emote-7tv" src="${fullUrl}" alt="${word}" title="${word}">`;
                            words[i] = words[i].replace(word, emoteImg);
                            // console.log(`üé® Emote remplac√©e: "${word}" ‚Üí ${fullUrl}`);
                        } else {
                            // console.log(`‚ùå Pas d'URL d'image valide pour l'emote ${word}`);
                        }
                    } else {
                        if (word.length > 2) { // √âviter le spam pour les petits mots
                            // console.log(`‚ö™ Mot normal: "${word}"`);
                        }
                    }

                    // Debug sp√©cial pour LeaClassic
                    if (word === 'LeaClassic') {
                        // console.log('üö® LeaClassic d√©tect√© ! Debug complet:');
                        // console.log('Dans canal:', this.sevenTVEmotes.has('LeaClassic'));
                        // console.log('Dans global:', this.globalSevenTVEmotes.has('LeaClassic'));

                        if (this.sevenTVEmotes.has('LeaClassic')) {
                            const emote = this.sevenTVEmotes.get('LeaClassic');
                            // console.log('Donn√©es de l\'emote LeaClassic:', emote);
                        }

                        // Chercher des emotes similaires
                        const similarEmotes = [];
                        this.sevenTVEmotes.forEach((emote, name) => {
                            if (name.toLowerCase().includes('lea') || name.toLowerCase().includes('classic')) {
                                similarEmotes.push(name);
                            }
                        });
                        // console.log('Emotes similaires trouv√©es:', similarEmotes);
                    }
                }

                const parsedMessage = words.join('');

                if (parsedMessage !== message) {
                    console.log('üèÅ Message apr√®s parsing emotes:', parsedMessage);
                }

                return parsedMessage;
            }

            parseTwitchEmotes(message, emoteData) {
                if (!message || !emoteData) return message;

                // console.log('üü£ Parsing emotes Twitch pour:', message);
                // console.log('üü£ Donn√©es emotes Twitch:', emoteData);

                let result = message;

                // Parser les emotes Twitch depuis les tags IRC
                // Format: emote_id:start_pos-end_pos,start_pos-end_pos/emote_id:start_pos-end_pos
                const emoteEntries = emoteData.split('/');

                // Collecter toutes les positions d'emotes pour les traiter en ordre inverse
                const emoteReplacements = [];

                emoteEntries.forEach(entry => {
                    const [emoteId, positions] = entry.split(':');
                    if (!emoteId || !positions) return;

                    const positionPairs = positions.split(',');
                    positionPairs.forEach(pair => {
                        const [start, end] = pair.split('-').map(Number);
                        if (isNaN(start) || isNaN(end)) return;

                        const emoteName = message.substring(start, end + 1);
                        emoteReplacements.push({
                            start,
                            end: end + 1,
                            emoteId,
                            emoteName
                        });
                    });
                });

                // Trier par position de fin en ordre d√©croissant pour remplacer de droite √† gauche
                emoteReplacements.sort((a, b) => b.start - a.start);

                // Remplacer les emotes
                emoteReplacements.forEach(replacement => {
                    const { start, end, emoteId, emoteName } = replacement;
                    const emoteUrl = `https://static-cdn.jtvnw.net/emoticons/v2/${emoteId}/default/dark/2.0`;
                    const emoteImg = `<img class="emote-twitch" src="${emoteUrl}" alt="${emoteName}" title="${emoteName}" style="width: 28px; height: 28px; vertical-align: middle; margin: 0 2px;">`;

                    result = result.substring(0, start) + emoteImg + result.substring(end);
                    console.log(`üü£ Emote Twitch remplac√©e: "${emoteName}" ‚Üí ${emoteUrl}`);
                });

                return result;
            }

            extractBadges(rawMessage) {
                const badges = {};

                // Extraire les badges depuis les tags IRC (format Twitch)
                if (rawMessage.includes('badges=')) {
                    const badgeMatch = rawMessage.match(/badges=([^;]*)/);
                    if (badgeMatch && badgeMatch[1]) {
                        const badgeList = badgeMatch[1].split(',');
                        badgeList.forEach(badge => {
                            const [type, version] = badge.split('/');

                            // Log unique badges in debug-badges mode
                            if (debugBadgesMode && window.logUniqueBadge && type) {
                                window.logUniqueBadge(type, version);
                            }

                            // R√¥les hi√©rarchiques (ordre d'importance d√©croissante)
                            if (type === 'admin') {
                                badges.admin = true;
                                badges.adminVersion = version;
                            }
                            if (type === 'staff') {
                                badges.staff = true;
                                badges.staffVersion = version;
                            }
                            if (type === 'global_mod') {
                                badges.globalMod = true;
                                badges.globalModVersion = version;
                            }
                            if (type === 'moderator') {
                                // Version 2 = Lead Moderator, Version 1 = Regular Moderator
                                if (version === '2') {
                                    badges.leadModerator = true;
                                    badges.leadModeratorVersion = version;
                                } else {
                                    badges.moderator = true;
                                    badges.moderatorVersion = version;
                                }
                            }
                            if (type === 'lead_moderator' || type === 'lead-moderator') {
                                badges.leadModerator = true;
                                badges.leadModeratorVersion = version;
                            }
                            if (type === 'vip') {
                                badges.vip = true;
                                badges.vipVersion = version;
                            }
                            if (type === 'subscriber') {
                                badges.subscriber = true;
                                badges.subscriberVersion = version;
                            }
                            if (type === 'broadcaster') {
                                badges.broadcaster = true;
                                badges.broadcasterVersion = version;
                            }
                            if (type === 'predictions') {
                                badges.predictions = true;
                                badges.predictionsVersion = version;
                            }
                            if (type === 'bits') {
                                badges.bits = true;
                                badges.bitsVersion = version;
                            }
                            if (type === 'sub-gifter') {
                                badges.subGifter = true;
                                badges.subGifterVersion = version;
                            }
                            if (type === 'sub-gift-leader') {
                                badges.subGiftLeader = true;
                                badges.subGiftLeaderVersion = version;
                            }
                            if (type === 'bits-leader') {
                                badges.bitsLeader = true;
                                badges.bitsLeaderVersion = version;
                            }
                            if (type === 'clips-leader') {
                                badges.clipsLeader = true;
                                badges.clipsLeaderVersion = version;
                            }
                            if (type === 'founder') {
                                badges.founder = true;
                                badges.founderVersion = version;
                            }
                            if (type === 'hype-train' || type === 'hype_train') {
                                badges.hypeTrain = true;
                                badges.hypeTrainVersion = version;
                            }
                            if (type === 'charity') {
                                badges.charity = true;
                                badges.charityVersion = version;
                            }
                            if (type === 'extension') {
                                badges.extension = true;
                                badges.extensionVersion = version;
                            }
                            if (type === 'sub-bomb') {
                                badges.subBomb = true;
                                badges.subBombVersion = version;
                            }
                            if (type === 'premium') {
                                badges.premium = true;
                                badges.premiumVersion = version;
                            }
                            if (type === 'turbo') {
                                badges.turbo = true;
                                badges.turboVersion = version;
                            }
                            if (type === 'verified') {
                                badges.verified = true;
                                badges.verifiedVersion = version;
                            }
                            if (type === 'partner') {
                                badges.partner = true;
                                badges.partnerVersion = version;
                            }
                            if (type === 'prime') {
                                badges.prime = true;
                                badges.primeVersion = version;
                            }
                            if (type === 'no-audio' || type === 'no_audio') {
                                badges.noAudio = true;
                                badges.noAudioVersion = version;
                            }
                            if (type === 'no-video' || type === 'no_video') {
                                badges.noVideo = true;
                                badges.noVideoVersion = version;
                            }
                            if (type === 'dj') {
                                badges.dj = true;
                                badges.djVersion = version;
                            }
                            if (type === 'ambassador') {
                                badges.ambassador = true;
                                badges.ambassadorVersion = version;
                            }
                            if (type === 'anonymous-cheerer') {
                                badges.anonymousCheerer = true;
                                badges.anonymousCheererVersion = version;
                            }
                            if (type === 'artist-badge') {
                                badges.artist = true;
                                badges.artistVersion = version;
                            }
                            // Event-specific badges - comprehensive list
                            const eventBadges = [
                                'share-the-love', 'superultracombo-2023', 'speed-does-america', 'glhf-pledge',
                                'twitch-recap-2023', 'twitch-recap-2024', 'twitch-recap-2025', 'streamer-awards-tux',
                                'streamer-awards-2024', 'low', 'subtember-2025', 'dreamcon-2024', 'gamerduo',
                                'fright-fest-2025', 'ugly-sweater', 'together-for-good-25---goodest-badge',
                                'together-for-good-25---good-badge', 'gears-of-war-superfan-badge', 'raging-wolf-helm',
                                'purple-noob', 'rplace-2023', 'minecraft-15th-anniversary-celebration',
                                'path-of-exile-2-badge', 'gone-bananas', 'chatter-cs-go-2022', 'bot-badge',
                                'raider-icon-badge', 'purple-pixel-heart---together-for-good-24',
                                'ruby-pixel-heart---together-for-good-24', 'destiny-2-final-shape-raid-race',
                                'bits-charity', 'la-velada-iv', 'la-velada-v-badge', 'fallout-season-2-ghoul',
                                'overwatch-league-insider_2019A', 'dragonscimmy', 'elden-ring-recluse',
                                'elden-ring-wylder', 'gp-explorer-3', 'hornet', 'speedons-5-badge', 'touch-grass',
                                'revedtv-stream-awards-2025', 'umbrella-corporation', 'the-first-descendant-badge',
                                'video-games-day', 'pokemon-legends-z-a-totodile', 'support-a-streamer-ho26-badge',
                                'the-game-awards-2023', 'marathon-reveal-runner', 'legendus', 'the-onryos-mask',
                                'borderlands-4-badge---vault-symbol', 'gingko-leaf', 'stream-for-humanity-2-2025'
                            ];
                            if (eventBadges.includes(type)) {
                                badges[type.replace(/-/g, '').replace(/_/g, '')] = true;
                                badges[`${type.replace(/-/g, '').replace(/_/g, '')}Version`] = version;
                            }
                            // Catch-all: Automatically handle ANY badge type from Twitch API
                            const badgeExistsInAPI = this.badgeCache.has(type) || this.globalBadgeCache.has(type);
                            const alreadyHandled = badges[type] || badges.admin || badges.staff || badges.globalMod ||
                                                  badges.moderator || badges.leadModerator || badges.vip ||
                                                  badges.subscriber || badges.broadcaster || badges.predictions ||
                                                  badges.bits || badges.founder || badges.hypeTrain || badges.charity ||
                                                  badges.extension || badges.subBomb || badges.premium || badges.turbo ||
                                                  badges.verified || badges.partner || badges.prime || eventBadges.includes(type);
                            if (!alreadyHandled && type && type.trim() !== '') {
                                if (badgeExistsInAPI) {
                                    badges[type] = true;
                                    badges[`${type}Version`] = version || '1';
                                } else {
                                    if (!badges.specialBadges) {
                                        badges.specialBadges = [];
                                    }
                                    badges.specialBadges.push({ type: type, version: version || '1' });
                                    if (!this.unknownBadgesLogged.has(type)) {
                                        console.warn(`‚ö†Ô∏è Badge inconnu d√©tect√©: ${type}/${version || '1'}`);
                                        this.unknownBadgesLogged.add(type);
                                    }
                                }
                            }
                        });
                    }
                }

                return badges;
            }

            extractUserColor(rawMessage) {
                // Extraire la couleur depuis les tags IRC (format: color=#FF4500)
                const colorMatch = rawMessage.match(/color=([^;]*)/);
                console.log('üîç Recherche de couleur dans:', rawMessage.substring(0, 200) + '...');
                console.log('üîç Match couleur trouv√©:', colorMatch);

                if (colorMatch) {
                    const color = colorMatch[1];
                    console.log('üé® Couleur brute extraite:', `"${color}" (longueur: ${color ? color.length : 0})`);

                    if (color && color !== '' && color.trim() !== '') {
                        // V√©rifier que c'est une couleur valide (commence par # et a 6 caract√®res hexad√©cimaux)
                        if (color.match(/^#[0-9A-Fa-f]{6}$/)) {
                            console.log(`‚úÖ Couleur utilisateur extraite valide: ${color}`);
                            return color;
                        } else {
                            console.log(`‚ùå Couleur invalide (format incorrect): "${color}"`);
                        }
                    } else {
                        console.log(`‚ùå Couleur vide d√©tect√©e: "${color}"`);
                    }
                } else {
                    console.log('‚ùå Aucun match trouv√© pour color= dans les tags');
                }

                // Si pas de couleur ou couleur invalide, retourner null pour utiliser le syst√®me de fallback
                console.log('‚ö™ Pas de couleur utilisateur valide, utilisation du syst√®me de fallback');
                return null;
            }

            initStreamlabsEvents() {
                // √âcouter les √©v√©nements de chat de Streamlabs OBS (en backup)
                window.addEventListener('onEventReceived', (obj) => {
                    if (obj.detail.event && obj.detail.event.type === 'message') {
                        // V√©rifier et traiter les commandes de chat
                        const eventData = obj.detail.event.data;
                        const username = eventData.nick || eventData.username || 'Utilisateur';
                        const messageText = eventData.text || eventData.message || '';

                        if (messageText.trim() && (messageText.startsWith('!chatreload') || messageText.startsWith('!chatrefresh') || messageText.startsWith('!chatforcereload') || messageText.startsWith('!chatclearbadges'))) {
                            const commandHandled = this.handleChatCommand(username, messageText);
                            if (commandHandled) {
                                console.log(`‚úÖ Commande Streamlabs trait√©e par ${username}: ${messageText}`);
                                return; // Ne pas afficher la commande dans le chat
                            }
                        }

                        this.addMessage(eventData);
                    }
                });

                // Pour les tests avec StreamElements (alternative)
                window.addEventListener('onWidgetLoad', (obj) => {
                    console.log('Widget charg√© pour fugu_fps');
                });

                console.log('Widget de chat initialis√© pour fugu_fps');
            }

            getUserColor(username) {
                if (!this.userColors.has(username)) {
                    this.userColors.set(username, this.colors[this.colorIndex % this.colors.length]);
                    this.colorIndex++;
                }
                return this.userColors.get(username);
            }

            getUserBadgeClass(badges) {
                if (!badges) return '';

                if (badges.moderator) return 'moderator';
                if (badges.vip) return 'vip';
                if (badges.subscriber) return 'subscriber';
                if (badges.predictions) return 'predictions';
                if (badges.partner) return 'partner';
                if (badges.premium || badges.prime) return 'premium';

                return '';
            }

            cleanMessage(text) {
                // Nettoyer le message des caract√®res sp√©ciaux et balises (mais garder les emotes)
                // Supprimer les caract√®res de contr√¥le IRC (notamment \u0001 pour ACTION)
                return text
                    .replace(/\u0001ACTION\s*/g, '') // Supprimer \u0001ACTION au d√©but
                    .replace(/\u0001/g, '') // Supprimer tous les autres \u0001
                    .replace(/\r\n?|\n/g, '') // Supprimer les retours √† la ligne
                    .trim();
            }

            // Escape HTML characters to prevent HTML injection
            // This preserves ONLY emote img tags (with emote-7tv or emote-twitch classes) but escapes all other HTML
            escapeHTML(text) {
                // First, temporarily replace ONLY emote img tags with placeholders
                // We only preserve img tags that have our emote classes
                const emotePlaceholders = [];
                let placeholderIndex = 0;
                // Match all img tags, then check if they contain our emote classes
                const allImgRegex = /<img[^>]*>/gi;

                let processedText = text.replace(allImgRegex, (match) => {
                    // Check if this img tag has our emote classes
                    if (match.includes('emote-7tv') || match.includes('emote-twitch')) {
                        // This is an emote img tag - preserve it
                        const placeholder = `__EMOTE_PLACEHOLDER_${placeholderIndex}__`;
                        emotePlaceholders[placeholderIndex] = match;
                        placeholderIndex++;
                        return placeholder;
                    } else {
                        // This is a user-typed img tag - escape it by returning it as-is
                        // (it will be escaped in the next step)
                        return match;
                    }
                });

                // Escape ALL HTML in the remaining text (including user-typed img tags and other HTML)
                const div = document.createElement('div');
                div.textContent = processedText;
                let escapedText = div.innerHTML;

                // Restore ONLY the emote img tags
                emotePlaceholders.forEach((emoteTag, index) => {
                    escapedText = escapedText.replace(`__EMOTE_PLACEHOLDER_${index}__`, emoteTag);
                });

                return escapedText;
            }

            addMessage(data) {
                const messageElement = document.createElement('div');
                messageElement.className = 'chat-message';

                // Generate unique message ID
                const messageId = this.generateMessageId();
                messageElement.setAttribute('data-message-id', messageId);

                const username = data.nick || data.username || 'Utilisateur';
                let message = this.cleanMessage(data.text || data.message || '');

                // Parser les emotes Twitch en premier (priorit√© aux emotes natives)
                if (data.twitchEmotes) {
                    message = this.parseTwitchEmotes(message, data.twitchEmotes);
                }

                // Ensuite parser les emotes 7TV sur le texte restant
                message = this.parseSevenTVEmotes(message);

                // Escape HTML to prevent HTML injection (after emote parsing, preserves emote img tags)
                message = this.escapeHTML(message);

                // D√©terminer la couleur - priorit√© √† la couleur utilisateur
                let userColor = '';
                console.log(`üîç Debug couleur pour ${username}:`, {
                    userColorFromData: data.userColor,
                    hasUserColor: !!data.userColor
                });

                if (data.userColor) {
                    // Utiliser la couleur choisie par l'utilisateur
                    userColor = `style="color: ${data.userColor} !important;"`;
                    console.log(`üé® Utilisation de la couleur utilisateur: ${data.userColor} pour ${username}`);
                } else {
                    // Syst√®me de fallback avec couleurs pr√©d√©finies
                    userColor = `class="${this.getUserColor(username)}"`;
                    console.log(`üé≤ Utilisation de la couleur al√©atoire pour ${username}`);
                }

                const badgeClass = this.getUserBadgeClass(data.badges);

                // Cr√©er l'affichage des badges avec CDN et cache
                // Note: Les badges sont affich√©s dans l'ordre de priorit√© (broadcaster > admin > staff > global_mod > lead_moderator > moderator > vip)
                let badgeDisplay = '';
                if (data.badges) {
                    // Badge Broadcaster (priorit√© maximale)
                    if (data.badges.broadcaster) {
                        const badgeUrl = this.getBadgeImageUrl('broadcaster', data.badges.broadcasterVersion || '1', 'broadcaster.png');
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Broadcaster" title="Broadcaster" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/5527c58c-fb7d-422d-b71b-f309dcb85cc1/1'">`;
                    }
                    // Badge Admin (priorit√© tr√®s √©lev√©e)
                    if (data.badges.admin) {
                        const badgeUrl = this.getBadgeImageUrl('admin', data.badges.adminVersion || '1', 'admin.png');
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Admin" title="Twitch Admin" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/3267646d-33f0-4b17-b3df-f923a41db1d0/1'">`;
                    }
                    // Badge Staff (priorit√© √©lev√©e)
                    if (data.badges.staff) {
                        const badgeUrl = this.getBadgeImageUrl('staff', data.badges.staffVersion || '1', 'staff.png');
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Staff" title="Twitch Staff" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/3267646d-33f0-4b17-b3df-f923a41db1d0/1'">`;
                    }
                    // Badge Global Moderator
                    if (data.badges.globalMod) {
                        const badgeUrl = this.getBadgeImageUrl('global_mod', data.badges.globalModVersion || '1', 'global-mod.png');
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Global Mod" title="Global Moderator" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/3267646d-33f0-4b17-b3df-f923a41db1d0/1'">`;
                    }
                    // Badge Lead Moderator (priorit√© sup√©rieure au Moderator normal)
                    if (data.badges.leadModerator) {
                        const leadModVersion = data.badges.leadModeratorVersion || '2';
                        const badgeUrl = this.getBadgeImageUrl('lead-moderator', leadModVersion, 'lead-moderator.png');
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Lead Moderator" title="Lead Moderator" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/0822047b-65e0-46f2-94a9-d1091d685d33/${leadModVersion}'">`;
                    }
                    // Badge Moderator (seulement si pas Lead Moderator)
                    else if (data.badges.moderator) {
                        const badgeUrl = this.getBadgeImageUrl('moderator', data.badges.moderatorVersion || '1', 'moderator.png');
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Moderator" title="Moderator" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/3267646d-33f0-4b17-b3df-f923a41db1d0/1'">`;
                    }
                    // Badge VIP
                    if (data.badges.vip) {
                        const badgeUrl = this.getBadgeImageUrl('vip', data.badges.vipVersion || '1', 'vip.png');
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="VIP" title="VIP" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/b817aba4-fad8-49e2-b88a-7cc744dfa6ec/1'">`;
                    }
                    // Badges d'abonn√© avec CDN et cache
                    if (data.badges.subscriber) {
                        const subVersion = data.badges.subscriberVersion || '0';
                        let subBadgeFile = '';
                        switch(subVersion) {
                            case '0':
                            case '1':
                                subBadgeFile = '1-mois.png';
                                break;
                            case '2':
                                subBadgeFile = '2-mois.png';
                                break;
                            case '3':
                                subBadgeFile = '3-mois.png';
                                break;
                            case '6':
                                subBadgeFile = '6-mois.png';
                                break;
                            case '9':
                                subBadgeFile = '9-mois.png';
                                break;
                            case '12':
                                subBadgeFile = '1-an.png';
                                break;
                            case '18':
                                subBadgeFile = '18-mois.png';
                                break;
                            case '24':
                                subBadgeFile = '2-ans.png';
                                break;
                            default:
                                subBadgeFile = '1-mois.png';
                        }
                        const badgeUrl = this.getBadgeImageUrl('subscriber', subVersion, subBadgeFile);
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Subscriber ${subVersion}" title="Abonn√© ${subVersion} mois" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/5d9f2208-5dd8-11e7-8513-2ff4adfae661/${subVersion}'">`;
                    }
                    // Badges Predictions avec CDN et cache
                    if (data.badges.predictions) {
                        const predVersion = data.badges.predictionsVersion || '1';
                        let predBadgeFile = '';
                        switch(predVersion) {
                            case '1':
                            case 'blue-1':
                                predBadgeFile = 'predi-1.png';
                                break;
                            case '2':
                            case 'pink-2':
                                predBadgeFile = 'predi-2.png';
                                break;
                            default:
                                predBadgeFile = 'predi-1.png';
                        }
                        const badgeUrl = this.getBadgeImageUrl('predictions', predVersion, predBadgeFile);
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Prediction ${predVersion}" title="Pr√©diction ${predVersion}" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/73e8b446-2ca8-4dc7-912c-e35fc11d1c4e/${predVersion}'">`;
                    }
                    // Badges Bits/Cheers avec CDN et cache
                    if (data.badges.bits) {
                        const bitsVersion = data.badges.bitsVersion || '1';
                        let bitsBadgeFile = '';
                        if (parseInt(bitsVersion) >= 5000000) bitsBadgeFile = 'cheer-5000000.png';
                        else if (parseInt(bitsVersion) >= 4500000) bitsBadgeFile = 'cheer-4500000.png';
                        else if (parseInt(bitsVersion) >= 4000000) bitsBadgeFile = 'cheer-4000000.png';
                        else if (parseInt(bitsVersion) >= 3500000) bitsBadgeFile = 'cheer-3500000.png';
                        else if (parseInt(bitsVersion) >= 3000000) bitsBadgeFile = 'cheer-3000000.png';
                        else if (parseInt(bitsVersion) >= 2500000) bitsBadgeFile = 'cheer-2500000.png';
                        else if (parseInt(bitsVersion) >= 2000000) bitsBadgeFile = 'cheer-2000000.png';
                        else if (parseInt(bitsVersion) >= 1750000) bitsBadgeFile = 'cheer-1750000.png';
                        else if (parseInt(bitsVersion) >= 1500000) bitsBadgeFile = 'cheer-1500000.png';
                        else if (parseInt(bitsVersion) >= 1250000) bitsBadgeFile = 'cheer-1250000.png';
                        else if (parseInt(bitsVersion) >= 1000000) bitsBadgeFile = 'cheer-1000000.png';
                        else if (parseInt(bitsVersion) >= 900000) bitsBadgeFile = 'cheer-900000.png';
                        else if (parseInt(bitsVersion) >= 800000) bitsBadgeFile = 'cheer-800000.png';
                        else if (parseInt(bitsVersion) >= 750000) bitsBadgeFile = 'cheer-750000.png';
                        else if (parseInt(bitsVersion) >= 700000) bitsBadgeFile = 'cheer-700000.png';
                        else if (parseInt(bitsVersion) >= 600000) bitsBadgeFile = 'cheer-600000.png';
                        else if (parseInt(bitsVersion) >= 500000) bitsBadgeFile = 'cheer-500000.png';
                        else if (parseInt(bitsVersion) >= 400000) bitsBadgeFile = 'cheer-400000.png';
                        else if (parseInt(bitsVersion) >= 300000) bitsBadgeFile = 'cheer-300000.png';
                        else if (parseInt(bitsVersion) >= 200000) bitsBadgeFile = 'cheer-200000.png';
                        else if (parseInt(bitsVersion) >= 100000) bitsBadgeFile = 'cheer-100000.png';
                        else if (parseInt(bitsVersion) >= 50000) bitsBadgeFile = 'cheer-50000.png';
                        else if (parseInt(bitsVersion) >= 25000) bitsBadgeFile = 'cheer-25000.png';
                        else if (parseInt(bitsVersion) >= 10000) bitsBadgeFile = 'cheer-10000.png';
                        else if (parseInt(bitsVersion) >= 5000) bitsBadgeFile = 'cheer-5000.png';
                        else if (parseInt(bitsVersion) >= 1000) bitsBadgeFile = 'cheer-1000.png';
                        else if (parseInt(bitsVersion) >= 100) bitsBadgeFile = 'cheer-100.png';
                        else bitsBadgeFile = 'cheer-1.png';
                        const badgeUrl = this.getBadgeImageUrl('bits', bitsVersion, bitsBadgeFile);
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Bits ${bitsVersion}" title="Bits ${bitsVersion}" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/cheer/${bitsVersion}'">`;
                    }
                    // Badges Sub Gift Leader avec CDN et cache
                    if (data.badges.subGiftLeader) {
                        const giftLeaderVersion = data.badges.subGiftLeaderVersion || '1';
                        let gifterBadgeFile = '';
                        switch(giftLeaderVersion) {
                            case '1':
                                gifterBadgeFile = 'gifter-1.png';
                                break;
                            case '2':
                                gifterBadgeFile = 'gifter-2.png';
                                break;
                            case '3':
                                gifterBadgeFile = 'gifter-3.png';
                                break;
                            default:
                                gifterBadgeFile = 'gifter-1.png';
                        }
                        const badgeUrl = this.getBadgeImageUrl('sub-gift-leader', giftLeaderVersion, gifterBadgeFile);
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Gift Leader ${giftLeaderVersion}" title="Gift Leader ${giftLeaderVersion}" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/d12a2e27-16f3-32d8-9ee0-1a58b46cee8a/${giftLeaderVersion}'">`;
                    }
                    // Badges Sub Gifter avec CDN et cache
                    else if (data.badges.subGifter) {
                        const giftVersion = data.badges.subGifterVersion || '1';
                        let giftBadgeFile = '';
                        if (parseInt(giftVersion) >= 5000) giftBadgeFile = 'sub-gift-5000.png';
                        else if (parseInt(giftVersion) >= 4000) giftBadgeFile = 'sub-gift-4000.png';
                        else if (parseInt(giftVersion) >= 3000) giftBadgeFile = 'sub-gift-3000.png';
                        else if (parseInt(giftVersion) >= 2000) giftBadgeFile = 'sub-gift-2000.png';
                        else if (parseInt(giftVersion) >= 1000) giftBadgeFile = 'sub-gift-1000.png';
                        else if (parseInt(giftVersion) >= 950) giftBadgeFile = 'sub-gift-950.png';
                        else if (parseInt(giftVersion) >= 900) giftBadgeFile = 'sub-gift-900.png';
                        else if (parseInt(giftVersion) >= 850) giftBadgeFile = 'sub-gift-850.png';
                        else if (parseInt(giftVersion) >= 800) giftBadgeFile = 'sub-gift-800.png';
                        else if (parseInt(giftVersion) >= 750) giftBadgeFile = 'sub-gift-750.png';
                        else if (parseInt(giftVersion) >= 700) giftBadgeFile = 'sub-gift-700.png';
                        else if (parseInt(giftVersion) >= 650) giftBadgeFile = 'sub-gift-650.png';
                        else if (parseInt(giftVersion) >= 600) giftBadgeFile = 'sub-gift-600.png';
                        else if (parseInt(giftVersion) >= 550) giftBadgeFile = 'sub-gift-550.png';
                        else if (parseInt(giftVersion) >= 500) giftBadgeFile = 'sub-gift-500.png';
                        else if (parseInt(giftVersion) >= 450) giftBadgeFile = 'sub-gift-450.png';
                        else if (parseInt(giftVersion) >= 400) giftBadgeFile = 'sub-gift-400.png';
                        else if (parseInt(giftVersion) >= 350) giftBadgeFile = 'sub-gift-350.png';
                        else if (parseInt(giftVersion) >= 300) giftBadgeFile = 'sub-gift-300.png';
                        else if (parseInt(giftVersion) >= 250) giftBadgeFile = 'sub-gift-250.png';
                        else if (parseInt(giftVersion) >= 200) giftBadgeFile = 'sub-gift-200.png';
                        else if (parseInt(giftVersion) >= 150) giftBadgeFile = 'sub-gift-150.png';
                        else if (parseInt(giftVersion) >= 100) giftBadgeFile = 'sub-gift-100.png';
                        else if (parseInt(giftVersion) >= 50) giftBadgeFile = 'sub-gift-50.png';
                        else if (parseInt(giftVersion) >= 25) giftBadgeFile = 'sub-gift-25.png';
                        else if (parseInt(giftVersion) >= 10) giftBadgeFile = 'sub-gift-10.png';
                        else if (parseInt(giftVersion) >= 5) giftBadgeFile = 'sub-gift-5.png';
                        else giftBadgeFile = 'sub-gift-1.png';
                        const badgeUrl = this.getBadgeImageUrl('sub-gifter', giftVersion, giftBadgeFile);
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Sub Gifter ${giftVersion}" title="Sub Gifter ${giftVersion}" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/d12a2e27-16f3-32d8-9ee0-1a58b46cee8a/${giftVersion}'">`;
                    }
                    // Badges Clips Leader avec CDN et cache
                    if (data.badges.clipsLeader) {
                        const clipsVersion = data.badges.clipsLeaderVersion || '1';
                        let clipsBadgeFile = '';
                        switch(clipsVersion) {
                            case '1':
                                clipsBadgeFile = 'clipe-1.png';
                                break;
                            case '2':
                                clipsBadgeFile = 'clipe-2.png';
                                break;
                            case '3':
                                clipsBadgeFile = 'clipe-3.png';
                                break;
                            default:
                                clipsBadgeFile = 'clipe-1.png';
                        }
                        const badgeUrl = this.getBadgeImageUrl('clips-leader', clipsVersion, clipsBadgeFile);
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Clips Leader ${clipsVersion}" title="Clips Leader ${clipsVersion}" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/d12a2e27-16f3-32d8-9ee0-1a58b46cee8a/${clipsVersion}'">`;
                    }
                    // Badge Prime/Premium avec CDN et cache
                    if (data.badges.prime || data.badges.premium) {
                        const badgeUrl = this.getBadgeImageUrl('prime', data.badges.primeVersion || data.badges.premiumVersion || '1', 'prime.png');
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Prime" title="Prime Gaming" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/d12a2e27-16f3-32d8-9ee0-1a58b46cee8a/1'">`;
                    }
                    // Badge Turbo avec CDN et cache
                    if (data.badges.turbo) {
                        const badgeUrl = this.getBadgeImageUrl('turbo', data.badges.turboVersion || '1', 'turbo.png');
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Turbo" title="Turbo" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/d12a2e27-16f3-32d8-9ee0-1a58b46cee8a/1'">`;
                    }
                    // Badge Verified avec CDN et cache
                    if (data.badges.verified) {
                        const badgeUrl = this.getBadgeImageUrl('verified', data.badges.verifiedVersion || '1', 'verified.png');
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Verified" title="Verified" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/d12a2e27-16f3-32d8-9ee0-1a58b46cee8a/1'">`;
                    }
                    // Badge Partner avec CDN et cache
                    if (data.badges.partner) {
                        const badgeUrl = this.getBadgeImageUrl('partner', data.badges.partnerVersion || '1', 'verified.png');
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Partner" title="Twitch Partner" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/d12a2e27-16f3-32d8-9ee0-1a58b46cee8a/1'">`;
                    }
                    // Badge No Audio avec CDN et cache
                    if (data.badges.noAudio) {
                        const badgeUrl = this.getBadgeImageUrl('no-audio', data.badges.noAudioVersion || '1', 'no-audio.png');
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="No Audio" title="Audio d√©sactiv√© - √âcoute uniquement" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/d12a2e27-16f3-32d8-9ee0-1a58b46cee8a/1'">`;
                    }
                    // Badge No Video avec CDN et cache
                    if (data.badges.noVideo) {
                        const badgeUrl = this.getBadgeImageUrl('no-video', data.badges.noVideoVersion || '1', 'listen.png');
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Listen Only" title="√âcoute uniquement - Pas de vid√©o" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/d12a2e27-16f3-32d8-9ee0-1a58b46cee8a/1'">`;
                    }
                    // Badge DJ avec CDN et cache
                    if (data.badges.dj) {
                        const badgeUrl = this.getBadgeImageUrl('dj', data.badges.djVersion || '1', 'dj.png');
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="DJ" title="Twitch DJ" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/d12a2e27-16f3-32d8-9ee0-1a58b46cee8a/1'">`;
                    }
                    // Badge Ambassador avec CDN et cache
                    if (data.badges.ambassador) {
                        const badgeUrl = this.getBadgeImageUrl('ambassador', data.badges.ambassadorVersion || '1', 'ambassador.png');
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Ambassador" title="Twitch Ambassador" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/d12a2e27-16f3-32d8-9ee0-1a58b46cee8a/1'">`;
                    }
                    // Badge Anonymous Cheerer avec CDN et cache
                    if (data.badges.anonymousCheerer) {
                        const badgeUrl = this.getBadgeImageUrl('anonymous-cheerer', data.badges.anonymousCheererVersion || '1', 'anonymous-cheerer.png');
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Anonymous Cheerer" title="Cheerer Anonyme" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/d12a2e27-16f3-32d8-9ee0-1a58b46cee8a/1'">`;
                    }
                    // Badge Artist avec CDN et cache
                    if (data.badges.artist) {
                        const badgeUrl = this.getBadgeImageUrl('artist-badge', data.badges.artistVersion || '1', 'Artist.png');
                        badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Artist" title="Artiste" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/d12a2e27-16f3-32d8-9ee0-1a58b46cee8a/1'">`;
                    }
                    // Display badges discovered from API but not explicitly handled
                    if (data.badges.specialBadges && Array.isArray(data.badges.specialBadges)) {
                        data.badges.specialBadges.forEach(specialBadge => {
                            const badgeType = specialBadge.type;
                            const badgeVersion = specialBadge.version || '1';
                            const badgeUrl = this.getBadgeImageUrl(badgeType, badgeVersion, null);
                            if (badgeUrl) {
                                badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="${badgeType}" title="${badgeType} (${badgeVersion})" onerror="this.style.display='none'">`;
                            }
                        });
                    }
                }

                // Cr√©er l'image de la cha√Æne d'origine si disponible ET si le chat partag√© est actif
                let originImageHTML = '';
                if (data.originChannel && data.originChannel.profileImage && this.isSharedChatActive) {
                    console.log(`üè¢ Affichage de l'ic√¥ne de cha√Æne d'origine (chat partag√© actif): ${data.originChannel.displayName}`);
                    originImageHTML = `<img class="badge-image origin-channel" src="${data.originChannel.profileImage}" alt="${data.originChannel.displayName}" title="Cha√Æne d'origine: ${data.originChannel.displayName}" style="width: 22px; height: 22px; border-radius: 4px; margin-right: 6px; object-fit: cover; vertical-align: middle;">`;
                } else if (data.originChannel && data.originChannel.profileImage && !this.isSharedChatActive) {
                    console.log(`üö´ Ic√¥ne de cha√Æne d'origine masqu√©e (chat partag√© inactif): ${data.originChannel.displayName}`);
                }

                messageElement.innerHTML = `
                    <span class="badge-display">
                        ${originImageHTML}
                        ${badgeDisplay}
                    </span>
                    <span class="username ${badgeClass}" ${userColor}>${username}</span>
                    <span class="separator">:</span>
                    <span class="message-content">${message}</span>
                `;

                // Ajouter le message au container
                this.container.appendChild(messageElement);

                // Store message data for potential deletion with Twitch message ID
                this.messages.set(messageId, {
                    id: messageId,
                    username: username,
                    element: messageElement,
                    timestamp: Date.now(),
                    text: message,
                    twitchMessageId: data.twitchMessageId || null, // Store Twitch message ID for moderation
                    originalData: data // Store original data for reference
                });

                // Log message storage for debugging
                if (data.twitchMessageId) {
                    console.log(`üíæ Message stock√©: ID=${messageId}, TwitchID=${data.twitchMessageId}, Username=${username}`);
                }

                // Clean up old messages from storage
                this.cleanupOldMessages();

                // Limiter le nombre de messages
                this.limitMessages();

                // Faire d√©filer vers le bas
                this.scrollToBottom();
            }

            limitMessages() {
                while (this.container.children.length > this.maxMessages) {
                    this.container.removeChild(this.container.firstChild);
                }
            }

            scrollToBottom() {
                this.container.scrollTop = this.container.scrollHeight;
            }

            // Messages de test (√† supprimer en production)
            addTestMessages() {
                setTimeout(() => {
                    const testMessages = [
                        { nick: 'StreamerPro', text: 'Bienvenue dans le stream ! üéÆ', badges: { moderator: true } },
                        { nick: 'ViewerFan', text: 'Salut tout le monde !', badges: { subscriber: true } },
                        { nick: 'GameMaster', text: 'Ce jeu a l\'air vraiment cool, j\'ai h√¢te de voir la suite de cette partie qui s\'annonce √©pique !', badges: { vip: true } },
                        { nick: 'ChatUser', text: 'GG pour ce kill !', badges: {} },
                        { nick: 'FollowerOne', text: 'Premier stream que je regarde et c\'est d√©j√† incroyable, continue comme √ßa !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!', badges: {} }
                    ];

                    testMessages.forEach((msg, index) => {
                        setTimeout(() => {
                            this.addMessage(msg);
                        }, index * 2000);
                    });
                }, 1000);
            }
        }

        // Fonction pour v√©rifier si une police est charg√©e en comparant les largeurs de texte
        function isFontLoaded(fontFamily, fallbackFont = 'monospace') {
            const testString = 'mmmmmmmmmmlli';
            const fontSize = '72px';

            // Cr√©er un √©l√©ment avec la police de fallback
            const fallbackElement = document.createElement('div');
            fallbackElement.style.fontFamily = fallbackFont;
            fallbackElement.style.fontSize = fontSize;
            fallbackElement.style.position = 'absolute';
            fallbackElement.style.left = '-9999px';
            fallbackElement.style.top = '-9999px';
            fallbackElement.style.visibility = 'hidden';
            fallbackElement.textContent = testString;
            document.body.appendChild(fallbackElement);

            const fallbackWidth = fallbackElement.offsetWidth;
            document.body.removeChild(fallbackElement);

            // Cr√©er un √©l√©ment avec notre police
            const testElement = document.createElement('div');
            testElement.style.fontFamily = `"${fontFamily}", ${fallbackFont}`;
            testElement.style.fontSize = fontSize;
            testElement.style.position = 'absolute';
            testElement.style.left = '-9999px';
            testElement.style.top = '-9999px';
            testElement.style.visibility = 'hidden';
            testElement.textContent = testString;
            document.body.appendChild(testElement);

            const testWidth = testElement.offsetWidth;
            document.body.removeChild(testElement);

            const isLoaded = fallbackWidth !== testWidth;
            console.log(`üìê Test de largeur - Fallback: ${fallbackWidth}px, Test: ${testWidth}px, Police charg√©e: ${isLoaded}`);

            return isLoaded;
        }

        // Fonction pour v√©rifier la police charg√©e
        function checkLoadedFonts() {
            console.log('üîç V√©rification des polices charg√©es...');

            // V√©rifier si l'API FontFace est disponible
            if ('fonts' in document) {
                console.log('üìã Toutes les polices charg√©es:', Array.from(document.fonts).map(font => font.family));

                // V√©rifier sp√©cifiquement notre police
                const seaFuguFont = Array.from(document.fonts).find(font =>
                    font.family.includes('Sea Regular Fugu')
                );

                if (seaFuguFont) {
                    console.log('‚úÖ Police "Sea Regular Fugu" trouv√©e:', seaFuguFont);
                    console.log('üìä Status de la police:', seaFuguFont.status);
                } else {
                    console.log('‚ùå Police "Sea Regular Fugu" non trouv√©e dans les polices charg√©es');
                }

                // Utiliser l'API moderne pour v√©rifier le chargement
                document.fonts.check('16px "Sea Regular Fugu"') ?
                    console.log('‚úÖ API fonts.check(): Police "Sea Regular Fugu" charg√©e') :
                    console.log('‚ùå API fonts.check(): Police "Sea Regular Fugu" non charg√©e');
            }

            // Test de largeur pour v√©rifier le chargement
            const fontLoadedByWidth = isFontLoaded('Sea Regular Fugu');

            // V√©rifier la police calcul√©e sur le body
            const bodyElement = document.body;
            const computedStyle = window.getComputedStyle(bodyElement);
            const actualFont = computedStyle.fontFamily;

            console.log('üéØ Police calcul√©e sur le body:', actualFont);

            // Cr√©er un √©l√©ment de test pour v√©rifier la police
            const testElement = document.createElement('div');
            testElement.style.fontFamily = '"Sea Regular Fugu", "Comic Sans MS", "Trebuchet MS", "Arial Black", Arial, sans-serif';
            testElement.style.position = 'absolute';
            testElement.style.left = '-9999px';
            testElement.textContent = 'Test Font';
            document.body.appendChild(testElement);

            const testComputedStyle = window.getComputedStyle(testElement);
            const testActualFont = testComputedStyle.fontFamily;

            console.log('üß™ Police de test calcul√©e:', testActualFont);

            // Nettoyer l'√©l√©ment de test
            document.body.removeChild(testElement);

            // V√©rifier si la police personnalis√©e est utilis√©e
            if (actualFont.includes('Sea Regular Fugu')) {
                console.log('üéâ SUCCESS: La police "Sea Regular Fugu" est active !');
            } else if (actualFont.includes('Comic Sans MS')) {
                console.log('‚ö†Ô∏è WARNING: Utilisation de la police fallback "Comic Sans MS"');
            } else {
                console.log('‚ùå ERROR: Aucune police reconnue d√©tect√©e. Police actuelle:', actualFont);
            }

            // R√©sum√© final
            console.log('üìù R√âSUM√â:');
            console.log(`   - Police charg√©e (test largeur): ${fontLoadedByWidth ? '‚úÖ' : '‚ùå'}`);
            console.log(`   - Police active dans CSS: ${actualFont.includes('Sea Regular Fugu') ? '‚úÖ' : '‚ùå'}`);
        }

        // Initialiser le widget quand la page est charg√©e
        document.addEventListener('DOMContentLoaded', () => {
            // R√©initialisation via URL: ?clearBadgeCache=1 ou ?forcereset=1 (ex: apr√®s crash PC/OBS, quand
            // l'IRC ne re√ßoit plus les commandes). Vide le cache badges localStorage et recharge sans le param.
            const url = new URL(window.location.href);
            if (url.searchParams.has('clearBadgeCache') || url.searchParams.has('forcereset')) {
                try {
                    for (let i = localStorage.length - 1; i >= 0; i--) {
                        const k = localStorage.key(i);
                        if (k && k.startsWith('twitch_badges')) localStorage.removeItem(k);
                    }
                    url.searchParams.delete('clearBadgeCache');
                    url.searchParams.delete('forcereset');
                    window.location.replace(url.toString());
                    return; // la page va recharger
                } catch (e) { console.warn('‚ö†Ô∏è forcereset/clearBadgeCache:', e); }
            }

            // Cr√©er et exposer le widget globalement pour les tests
            window.chatWidget = new ChatWidget();

            // Quand le r√©seau revient (ex: apr√®s crash/sleep), recharger les badges depuis l'API
            window.addEventListener('online', () => {
                if (window.chatWidget) {
                    console.log('üåê R√©seau de nouveau en ligne, rechargement des badges...');
                    window.chatWidget.loadTwitchBadges(true);
                }
            });

            // V√©rifier les polices imm√©diatement
            checkLoadedFonts();

            // √âcouter les √©v√©nements de chargement de polices (API moderne)
            if ('fonts' in document) {
                document.fonts.addEventListener('loadingdone', (event) => {
                    console.log('üéâ √âv√©nement loadingdone d√©clench√© - Polices charg√©es:', event.fontfaces.length);
                    event.fontfaces.forEach(font => {
                        console.log(`   - ${font.family} (${font.status})`);
                    });
                    checkLoadedFonts();
                });

                document.fonts.addEventListener('loadingerror', (event) => {
                    console.log('‚ùå Erreur de chargement de police:', event.fontfaces);
                    event.fontfaces.forEach(font => {
                        console.log(`   - ERREUR: ${font.family} (${font.status})`);
                    });
                });

                // Forcer le chargement de notre police
                document.fonts.load('16px "Sea Regular Fugu"').then(() => {
                    console.log('‚úÖ Police "Sea Regular Fugu" charg√©e explicitement via fonts.load()');
                    checkLoadedFonts();
                }).catch((error) => {
                    console.log('‚ùå Erreur lors du chargement explicite de la police:', error);
                });
            }

            // V√©rifier √† nouveau apr√®s 2 secondes (temps pour que les polices se chargent)
            setTimeout(() => {
                console.log('üîÑ Re-v√©rification des polices apr√®s 2 secondes...');
                checkLoadedFonts();
            }, 2000);

            // V√©rifier une derni√®re fois apr√®s 5 secondes
            setTimeout(() => {
                console.log('üîÑ V√©rification finale des polices apr√®s 5 secondes...');
                checkLoadedFonts();
            }, 5000);
        });

        // Fonction globale pour ajouter des messages manuellement (pour les tests)
        function addTestMessage(username, message, badges = {}) {
            if (window.chatWidget) {
                window.chatWidget.addMessage({
                    nick: username,
                    text: message,
                    badges: badges
                });
            }
        }

        // ===== SECTION DE TEST - SUPPRIMER CETTE SECTION EN PRODUCTION =====
        // Test automatique de chat partag√© toutes les 20 secondes
        /*async function testSharedChatMessage() {
            try {
                const widget = window.chatWidget;
                if (!widget || typeof widget.addMessage !== 'function') {
                    console.error('‚ùå Chat widget not found.');
                    return;
                }

                console.log('üß™ Test de message de chat partag√©...');

                // Manually fetch the channel info for room-id 48624276
                const response = await fetch('https://api.twitch.tv/helix/users?id=48624276', {
                    headers: {
                        'Client-ID': 'gp762nuuoqcoxypju8c569th9wz7q5',
                        'Authorization': 'Bearer m15k59400wm8tosv4499famn76qpr3'
                    }
                });

                const json = await response.json();
                const originChannel = json.data?.[0]
                    ? {
                        displayName: json.data[0].display_name,
                        login: json.data[0].login,
                        profileImage: json.data[0].profile_image_url
                    }
                    : null;

                widget.addMessage({
                    nick: 'sc0rpio74890',
                    text: 'Ceci est un test simul√© depuis un autre chat partag√©',
                    badges: { vip: true },
                    userColor: '#FF0000FF',
                    originChannel
                });

                console.log('‚úÖ Message de test ajout√© avec succ√®s');
            } catch (error) {
                console.error('‚ùå Erreur lors du test de chat partag√©:', error);
            }
        }

        // ===== FONCTIONS DE TEST DE MOD√âRATION =====
        // Exposer les fonctions de test de mod√©ration globalement
        window.testMessageDeletion = {
            // Tester la suppression par ID Twitch
            testDeleteByTwitchId: function(twitchMessageId) {
                if (window.chatWidget) {
                    console.log(`üß™ Test de suppression par ID Twitch: ${twitchMessageId}`);
                    const result = window.chatWidget.removeMessageByTwitchId(twitchMessageId);
                    console.log(`R√©sultat: ${result ? 'Message supprim√©' : 'Aucun message trouv√©'}`);
                    return result;
                } else {
                    console.error('‚ùå Chat widget non trouv√©');
                    return false;
                }
            },

            // Tester la suppression par nom d'utilisateur
            testDeleteByUsername: function(username) {
                if (window.chatWidget) {
                    console.log(`üß™ Test de suppression par nom d'utilisateur: ${username}`);
                    const result = window.chatWidget.removeMessagesByUsername(username);
                    console.log(`R√©sultat: ${result} messages supprim√©s`);
                    return result;
                } else {
                    console.error('‚ùå Chat widget non trouv√©');
                    return false;
                }
            },

            // Afficher le statut du stockage
            showStorageStatus: function() {
                if (window.chatWidget) {
                    console.log(`üìä Status du stockage: ${window.chatWidget.messages.size}/50 messages`);
                    console.log('üìã Messages stock√©s:');
                    for (const [id, data] of window.chatWidget.messages.entries()) {
                        console.log(`  - ID: ${id}, User: ${data.username}, TwitchID: ${data.twitchMessageId || 'N/A'}, Text: ${data.text.substring(0, 30)}...`);
                    }
                } else {
                    console.error('‚ùå Chat widget non trouv√©');
                }
            },

            // Simuler un message avec ID Twitch
            addMessageWithTwitchId: function(username, message, twitchId) {
                if (window.chatWidget) {
                    console.log(`üß™ Ajout de message de test avec ID Twitch: ${twitchId}`);
                    window.chatWidget.addMessage({
                        nick: username,
                        text: message,
                        badges: {},
                        twitchMessageId: twitchId
                    });
                } else {
                    console.error('‚ùå Chat widget non trouv√©');
                }
            },

            // Tester le syst√®me de mod√©ration API
            testModerationSystem: function() {
                if (window.chatWidget) {
                    console.log('üß™ Test du syst√®me de mod√©ration API...');
                    window.chatWidget.checkRecentModerations();
                } else {
                    console.error('‚ùå Chat widget non trouv√©');
                }
            },

            // Afficher le cache de mod√©ration
            showModerationCache: function() {
                if (window.chatWidget) {
                    console.log('üõ°Ô∏è Cache de mod√©ration:');
                    for (const [key, data] of window.chatWidget.moderationCache.entries()) {
                        console.log(`  - ${key}: ${data.username} - ${data.reason}`);
                    }
                } else {
                    console.error('‚ùå Chat widget non trouv√©');
                }
            },

            // Afficher tous les messages IRC captur√©s (pour debug)
            showIRCLog: function() {
                if (window.chatWidget) {
                    console.log('üîç Log complet des messages IRC:');
                    window.chatWidget.ircMessageLog.forEach((entry, index) => {
                        console.log(`[${index}] ${entry.timestamp} - ${entry.type}: ${entry.rawMessage}`);
                    });
                } else {
                    console.error('‚ùå Chat widget non trouv√©');
                }
            },

            // Afficher seulement les messages IRC d'un type sp√©cifique
            showIRCMessagesByType: function(type) {
                if (window.chatWidget) {
                    console.log(`üîç Messages IRC de type "${type}":`);
                    const filtered = window.chatWidget.ircMessageLog.filter(entry => entry.type === type);
                    filtered.forEach((entry, index) => {
                        console.log(`[${index}] ${entry.timestamp}: ${entry.rawMessage}`);
                    });
                    console.log(`Total: ${filtered.length} messages de type "${type}"`);
                } else {
                    console.error('‚ùå Chat widget non trouv√©');
                }
            },

            // Activer/D√©sactiver le mode debug
            toggleDebugMode: function() {
                if (window.chatWidget) {
                    window.chatWidget.debugMode = !window.chatWidget.debugMode;
                    console.log(`üîç Mode debug IRC: ${window.chatWidget.debugMode ? 'ACTIV√â' : 'D√âSACTIV√â'}`);
                } else {
                    console.error('‚ùå Chat widget non trouv√©');
                }
            }
        };

        console.log('üß™ Fonctions de test disponibles via window.testMessageDeletion');

        // D√©marrer le test automatique apr√®s initialisation du widget
        setTimeout(() => {
            console.log('üöÄ D√©marrage des tests automatiques de chat partag√© (toutes les 20 secondes)');
            // Premier test imm√©diat
            testSharedChatMessage();
            // Puis r√©p√©ter toutes les 20 secondes
            setInterval(testSharedChatMessage, 20000);
        }, 3000); // Attendre 3 secondes pour que le widget soit initialis√©
        // ===== FIN DE LA SECTION DE TEST ===== */

        // Test functions for message deletion (accessible via console)
        window.testMessageDeletion = {
            // Test removing messages by username
            removeByUsername: (username) => {
                if (window.chatWidget) {
                    window.chatWidget.removeMessagesByUsername(username);
                    console.log(`üß™ Test: Suppression des messages de ${username}`);
                } else {
                    console.log('‚ùå ChatWidget non disponible');
                }
            },

                        // Test removing specific message by ID
            removeById: (messageId) => {
                if (window.chatWidget) {
                    const removed = window.chatWidget.removeMessageById(messageId);
                    console.log(`üß™ Test: Suppression du message ${messageId}: ${removed ? 'succ√®s' : '√©chec'}`);
                } else {
                    console.log('‚ùå ChatWidget non disponible');
                }
            },

            // List all stored messages
            listMessages: () => {
                if (window.chatWidget) {
                    console.log('üìã Messages stock√©s:', Array.from(window.chatWidget.messages.entries()));
                } else {
                    console.log('‚ùå ChatWidget non disponible');
                }
            },

            // Test removing messages by content similarity
            removeByContent: (username, content) => {
                if (window.chatWidget) {
                    const removed = window.chatWidget.removeMessageByContent(username, content);
                    console.log(`üß™ Test: Suppression par contenu de ${username}: ${removed ? 'succ√®s' : '√©chec'}`);
                } else {
                    console.log('‚ùå ChatWidget non disponible');
                }
            }
        };

        console.log('üß™ Fonctions de test disponibles via window.testMessageDeletion');
    </script>
</body>
</html>
