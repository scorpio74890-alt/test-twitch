<!DOCTYPE html>
<!-- GitViz ‚Äì Sub Goal Overlay (100% Client-Side)
* Overlay de compteur de subs/follows Twitch fonctionnant 100% dans le navigateur
* Authentification OAuth2, EventSub WebSocket, API Twitch - Tout c√¥t√© client
-->
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sub Goal Overlay</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Montserrat:wght@400;700&family=Open+Sans:wght@400;700&family=Poppins:wght@400;700&family=Inter:wght@400;700&family=Lato:wght@400;700&family=Raleway:wght@400;700&family=Oswald:wght@400;700&family=Playfair+Display:wght@400;700&family=Merriweather:wght@400;700&family=Ubuntu:wght@400;700&family=Nunito:wght@400;700&family=Source+Sans+Pro:wght@400;700&family=Crimson+Text:wght@400;700&family=Libre+Baskerville:wght@400;700&family=PT+Sans:wght@400;700&family=PT+Serif:wght@400;700&family=Dancing+Script:wght@400;700&family=Pacifico&family=Bebas+Neue&family=Anton&family=Fjalla+One&family=Righteous&family=Bangers&family=Fredoka+One:wght@400;700&family=Comfortaa:wght@400;700&family=Quicksand:wght@400;700&family=Rubik:wght@400;700&family=Work+Sans:wght@400;700&family=Space+Grotesk:wght@400;700&family=DM+Sans:wght@400;700&family=Manrope:wght@400;700&family=Sora:wght@400;700&family=Outfit:wght@400;700&family=Plus+Jakarta+Sans:wght@400;700&family=Figtree:wght@400;700&family=Geist:wght@400;700&family=JetBrains+Mono:wght@400;700&family=Fira+Code:wght@400;700&display=swap" rel="stylesheet">
    <script src="../../overlay-logger.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: transparent;
        }

        :root {
            /* Variables CSS dynamiques */
            --font-family: 'Arial', sans-serif;
            --font-size: 64px;
            --font-weight: normal;
            --text-color: white;
            --shadow-color: rgba(0,0,0,0.5);
            --stroke-color: black;
            --anim-duration: 1s;
            --anim-easing: cubic-bezier(0.25, 0.46, 0.45, 0.94);
            --padding-left: 20px;
            --padding-right: 20px;
            --gap: 0;
            --justify-content: flex-start;
        }

        body {
            font-family: var(--font-family);
            color: var(--text-color);
            display: flex;
            justify-content: var(--justify-content);
            align-items: center;
            height: 100vh;
            padding-left: var(--padding-left);
            padding-right: var(--padding-right);
        }

        .counter {
            display: flex;
            font-size: var(--font-size);
            font-weight: var(--font-weight);
            gap: var(--gap);
            white-space: pre;
            text-shadow: 3px 3px 3px var(--shadow-color);
            -webkit-text-stroke: 1px var(--stroke-color);
        }

        .digit-container {
            position: relative;
            width: auto;
            min-width: 0.3em;
            height: 1.3em;
            overflow: hidden;
            display: inline-block;
            vertical-align: top;
            line-height: 1.3em;
            /* Masquer les parties qui d√©passent en haut et en bas */
            clip-path: inset(0 0 0 0);
        }

        .space-container {
            width: 0.25em;
            display: inline-block;
        }

        .digit {
            position: absolute;
            width: auto;
            white-space: nowrap;
            left: 0;
            top: 0;
            text-align: left;
            line-height: 1.3em;
            transition: transform var(--anim-duration) var(--anim-easing);
            /* S'assurer que les lettres sont bien align√©es */
            height: 1.3em;
            display: block;
        }

        .digit.static {
            position: relative;
            height: auto;
            display: inline-block;
        }

        .old { transform: translateY(0); }
        .new { transform: translateY(-100%); }

        .animate .old, .animate .new { animation: none; }

        @keyframes slideOut {
            0%   { transform: translateY(0); }
            100% { transform: translateY(100%); }
        }

        @keyframes slideIn {
            0%   { transform: translateY(-100%); }
            100% { transform: translateY(0); }
        }

        @keyframes slideOutUp {
            0%   { transform: translateY(0); }
            100% { transform: translateY(-100%); }
        }

        @keyframes slideInUp {
            0%   { transform: translateY(100%); }
            100% { transform: translateY(0); }
        }

        .animate-down .old { animation: slideOut 0.4s forwards ease-in-out; }
        .animate-down .new { animation: slideIn 0.4s forwards ease-in-out; }
        .animate-up .old { animation: slideOutUp 0.4s forwards ease-in-out; }
        .animate-up .new { animation: slideInUp 0.4s forwards ease-in-out; }

        /* Interface de configuration */
        .config-button {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(145, 70, 255, 0.8);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            z-index: 1000;
            display: none; /* Cach√© par d√©faut, visible en mode config */
        }

        .config-button:hover {
            background: rgba(145, 70, 255, 1);
        }

        .config-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: none;
            overflow-y: auto;
        }

        .config-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .config-content {
            background: #1a1a2e;
            border-radius: 16px;
            padding: 32px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            color: white;
        }

        .config-section {
            margin-bottom: 24px;
        }

        .config-section h3 {
            color: #9146ff;
            margin-bottom: 16px;
            font-size: 20px;
        }

        .config-field {
            margin-bottom: 16px;
        }

        .config-field label {
            display: block;
            margin-bottom: 8px;
            color: #ccc;
            font-size: 14px;
        }

        .config-field input,
        .config-field select {
            width: 100%;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 8px;
            background: #2a2a3e;
            color: white;
            font-size: 14px;
        }

        .config-field input[type="color"] {
            height: 40px;
            cursor: pointer;
        }

        .config-field input[type="file"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #444;
            border-radius: 8px;
            background: #2a2a3e;
            color: white;
            font-size: 13px;
            cursor: pointer;
        }

        .config-field input[type="file"]::file-selector-button {
            padding: 6px 12px;
            margin-right: 10px;
            border: 1px solid #9146ff;
            border-radius: 6px;
            background: #9146ff;
            color: white;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .config-field input[type="file"]::file-selector-button:hover {
            background: #7c3aed;
        }

        .custom-font-info {
            margin-top: 8px;
            padding: 8px;
            background: #1a1a2e;
            border-radius: 6px;
            font-size: 12px;
            color: #aaa;
        }

        .custom-font-info.active {
            color: #4ade80;
        }

        .config-buttons {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #9146ff;
            color: white;
        }

        .btn-primary:hover {
            background: #7c3aed;
        }

        .btn-secondary {
            background: #444;
            color: white;
        }

        .btn-secondary:hover {
            background: #555;
        }

        .auth-section {
            background: rgba(145, 70, 255, 0.1);
            border: 2px solid rgba(145, 70, 255, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
        }

        .auth-status {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .auth-status.connected {
            color: #4caf50;
        }

        .auth-status.disconnected {
            color: #ff6b6b;
        }

        .goals-list {
            margin-top: 16px;
        }

        .goal-item {
            background: #2a2a3e;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            display: grid;
            grid-template-columns: 120px 1fr auto;
            gap: 12px;
            align-items: center;
        }

        .goal-item .goal-target-wrapper,
        .goal-item .goal-message-wrapper {
            display: flex;
            flex-direction: column;
        }

        .goal-item .goal-target-wrapper label,
        .goal-item .goal-message-wrapper label {
            font-size: 11px;
            color: #888;
            margin-bottom: 4px;
        }

        .goal-item input[type="number"],
        .goal-item input[type="text"] {
            width: 100%;
        }

        .goal-item button {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            height: fit-content;
        }

        .add-goal-btn {
            background: #4caf50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
            margin-top: 12px;
        }

        .add-goal-btn:hover {
            background: #45a049;
        }

        /* √âtat de connexion */
        .connection-status {
            position: fixed;
            bottom: 10px;
            left: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
            display: none;
        }

        .connection-status.connected {
            background: rgba(76, 175, 80, 0.8);
            color: white;
        }

        .connection-status.disconnected {
            background: rgba(255, 107, 107, 0.8);
            color: white;
        }

        /* Mode configuration (visible quand ?config=true) */
        body.config-mode .config-button {
            display: block;
        }

        /* File picker button (visible when config=true) */
        .file-picker-btn {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            padding: 15px 30px;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 2px solid #9146ff;
            border-radius: 8px;
            cursor: pointer;
            display: none;
            font-family: 'Arial', sans-serif;
            transition: all 0.3s ease;
        }

        .file-picker-btn:hover {
            background: rgba(145, 70, 255, 0.3);
            border-color: #a970ff;
        }

        body.config-mode .file-picker-btn {
            display: block;
        }

        #fileInput {
            display: none;
        }
    </style>
</head>
<body>
    <div class="counter" id="counter">--</div>

    <!-- Bouton de connexion visible quand pas connect√© (sans config=true) -->
    <button class="connect-overlay-btn" id="connectOverlayBtn" style="display: none;">
        Connecter √† Twitch
    </button>

    <!-- File picker button (visible when config=true) -->
    <button class="file-picker-btn" id="filePickerBtn">üìÅ Select Goals File</button>
    <input type="file" id="fileInput" accept=".txt,text/plain">

    <!-- Bouton de configuration (visible en mode config) -->
    <button class="config-button" id="configButton">‚öôÔ∏è Config</button>

    <!-- Modal de configuration -->
    <div class="config-modal" id="configModal">
        <div class="config-content">
            <h2 style="margin-bottom: 24px; color: #9146ff;">‚öôÔ∏è Configuration</h2>

            <!-- Section Authentification -->
            <div class="config-section auth-section">
                <h3>üîê Authentification Twitch</h3>
                <div class="auth-status" id="authStatus">
                    <span>‚ùå Non connect√©</span>
                </div>
                <button class="btn btn-primary" id="connectTwitchBtn" style="width: 100%;">
                    Connecter mon compte Twitch
                </button>
                <button class="btn btn-secondary" id="disconnectTwitchBtn" style="width: 100%; margin-top: 8px; display: none;">
                    D√©connecter
                </button>

                <!-- Information sur le Redirect URI -->
                <div style="margin-top: 16px; padding: 12px; background: rgba(145, 70, 255, 0.1); border-left: 3px solid #9146ff; border-radius: 4px;">
                    <p style="margin: 0 0 8px 0; font-size: 13px; font-weight: bold; color: #9146ff;">‚ö†Ô∏è Configuration requise</p>
                    <p style="margin: 0 0 8px 0; font-size: 12px; color: #666;">
                        Pour que l'authentification fonctionne, vous devez configurer cette URL exacte comme <strong>Redirect URI</strong> dans votre application Twitch :
                    </p>
                    <div style="background: rgba(0, 0, 0, 0.2); padding: 8px; border-radius: 4px; margin-bottom: 8px;">
                        <code id="redirectUriDisplay" style="font-size: 11px; word-break: break-all; color: #9146ff;"></code>
                    </div>
                    <ol style="margin: 8px 0 0 20px; padding: 0; font-size: 11px; color: #666; line-height: 1.6;">
                        <li>Allez sur <a href="https://dev.twitch.tv/console/apps" target="_blank" style="color: #9146ff;">dev.twitch.tv/console/apps</a></li>
                        <li><strong>Cr√©ez une NOUVELLE application</strong> (ou utilisez une existante d√©di√©e √† l'overlay)</li>
                        <li>Dans "OAuth Redirect URLs", <strong>copiez-collez exactement</strong> l'URL ci-dessus (sans espaces, sans slash final)</li>
                        <li>Cliquez sur "Add" puis "Save"</li>
                    </ol>
                    <div style="margin-top: 12px; padding: 10px; background: rgba(255, 107, 107, 0.1); border-left: 3px solid #ff6b6b; border-radius: 4px;">
                        <p style="margin: 0; font-size: 11px; color: #ff6b6b; font-weight: bold;">‚ö†Ô∏è Si vous avez une erreur "redirect_mismatch" :</p>
                        <ul style="margin: 6px 0 0 20px; padding: 0; font-size: 10px; color: #ff6b6b; line-height: 1.5;">
                            <li>V√©rifiez que l'URL dans Twitch correspond <strong>exactement</strong> √† celle ci-dessus</li>
                            <li>Pas de slash final, pas d'espaces, pas de param√®tres</li>
                            <li>Cr√©ez une application s√©par√©e pour l'overlay (pas celle du bot)</li>
                            <li>Attendez 1-2 minutes apr√®s avoir sauvegard√©</li>
                        </ul>
                    </div>
                    <p style="margin: 8px 0 0 0; font-size: 11px; color: #ff6b6b; font-weight: bold;" id="localFileWarning" style="display: none;">
                        ‚ö†Ô∏è L'overlay est ouvert en local (file://). OAuth2 n√©cessite HTTPS. D√©ployez sur GitHub Pages pour utiliser cette fonctionnalit√©.
                    </p>
                </div>
            </div>

            <!-- Section Type d'overlay -->
            <div class="config-section">
                <h3>üìä Type d'overlay</h3>
                <div class="config-field">
                    <label>Type</label>
                    <select id="overlayType">
                        <option value="follow">Follows</option>
                        <option value="sub">Subscribers</option>
                    </select>
                </div>
                <div class="config-field">
                    <label>Alignement</label>
                    <select id="overlayAlign">
                        <option value="left">Gauche</option>
                        <option value="right">Droite</option>
                    </select>
                </div>
            </div>

            <!-- Section Objectifs -->
            <div class="config-section">
                <h3>üéØ Goals</h3>
                <div id="goalsList" class="goals-list"></div>
                <button class="add-goal-btn" id="addGoalBtn">+ Add a new goal</button>
            </div>

            <!-- Section Style -->
            <div class="config-section">
                <h3>üé® Style</h3>
                <div class="config-field">
                    <label>Police</label>
                    <select id="fontFamily"></select>
                </div>
                <div class="config-field">
                    <label>Police personnalis√©e (.otf, .ttf, .woff, .woff2)</label>
                    <input type="file" id="customFontFile" accept=".otf,.ttf,.woff,.woff2">
                    <div id="customFontInfo" class="custom-font-info" style="display: none;">
                        Aucune police personnalis√©e charg√©e
                    </div>
                </div>
                <div class="config-field">
                    <label>Taille (px)</label>
                    <input type="number" id="fontSize" min="24" max="128" value="64">
                </div>
                <div class="config-field">
                    <label>Couleur du texte</label>
                    <input type="color" id="textColor" value="#ffffff">
                </div>
                <div class="config-field">
                    <label>Couleur de l'ombre</label>
                    <input type="color" id="shadowColor" value="#000000">
                </div>
                <div class="config-field">
                    <label>Couleur du contour</label>
                    <input type="color" id="strokeColor" value="#000000">
                </div>
            </div>

            <!-- Boutons d'action -->
            <div class="config-buttons">
                <button class="btn btn-primary" id="saveConfigBtn">Enregistrer</button>
                <button class="btn btn-secondary" id="closeConfigBtn">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Statut de connexion -->
    <div class="connection-status" id="connectionStatus"></div>

    <script>
        // ==================================================================
        // üîß CONFIGURATION VIA PARAM√àTRES URL
        // ==================================================================
        const urlParams = new URLSearchParams(window.location.search);
        const OVERLAY_TYPE = urlParams.get('type') || 'follow';
        const OVERLAY_ALIGN = urlParams.get('align') || 'left';
        const CONFIG_MODE = urlParams.get('config') === 'true';

        // Read font and style parameters from URL
        const URL_FONT = urlParams.get('font') || null;
        const URL_FONT_SIZE = urlParams.get('font_size') ? parseInt(urlParams.get('font_size')) : null;
        const URL_TEXT_COLOR = urlParams.get('text_color') || null;
        const URL_SHADOW_COLOR = urlParams.get('shadow_color') || null;
        const URL_STROKE_COLOR = urlParams.get('stroke_color') || null;

        // Charger les goals depuis l'URL si pr√©sents (format: goal1=100&message1=text&goal2=200&message2=text)
        // Note: Cette fonction sera appel√©e apr√®s la d√©finition de STORAGE_KEYS
        function parseGoalsFromFileContent(fileContent) {
            const goals = [];
            const lines = fileContent.split('\n');

            for (let line of lines) {
                line = line.trim();
                if (!line) continue; // Skip empty lines

                // Parse format: "goal : message" or "goal:message" or "goal :message" or "goal: message"
                const match = line.match(/^(\d+)\s*:\s*(.*)$/);
                if (match) {
                    const target = parseInt(match[1]);
                    const message = match[2].trim();
                    if (target > 0) {
                        const storedCount = getStorage(STORAGE_KEYS.COUNTER) || 0;
                        goals.push({
                            target: target,
                            current: storedCount,
                            message: message,
                            isMaxReached: false
                        });
                    }
                }
            }

            if (goals.length > 0) {
                // Sort by target (ascending)
                goals.sort((a, b) => a.target - b.target);
                setStorage(STORAGE_KEYS.GOALS, goals);
                return true;
            }
            return false;
        }

        function loadGoalsFromFile() {
            // File content is stored as plain string, not JSON
            try {
                const fileContent = localStorage.getItem(STORAGE_KEYS.FILE_CONTENT);
                // Check if file content exists and is not null/empty
                if (fileContent && fileContent.trim() !== '') {
                    const parsed = parseGoalsFromFileContent(fileContent);
                    if (parsed) {
                        return true;
                    }
                }
            } catch (e) {
                // If there's an error, file doesn't exist or is invalid
            }
            return false;
        }

        function loadGoalsFromURL() {
            // Use console.error so logs always show (not filtered)
            console.error('üîó [URL] Checking URL parameters for goals...');
            console.error('üîó [URL] urlParams type:', typeof urlParams);
            console.error('üîó [URL] urlParams value:', urlParams);
            const goals = [];
            let goalIndex = 1;

            // Check what URL parameters exist
            if (urlParams) {
                console.error('üîó [URL] URL params:', Array.from(urlParams.entries()));
            } else {
                console.error('‚ùå [URL] urlParams is undefined!');
                return false;
            }

            while (urlParams.has(`goal${goalIndex}`)) {
                const target = parseInt(urlParams.get(`goal${goalIndex}`));
                const message = urlParams.get(`message${goalIndex}`) || '';
                console.error(`üîó [URL] Found goal${goalIndex}: target=${target}, message="${message}"`);
                if (target > 0) {
                    // Use currentCount from storage if available, otherwise 0
                    const storedCount = getStorage(STORAGE_KEYS.COUNTER) || 0;
                    goals.push({
                        target: target,
                        current: storedCount, // Use stored count instead of always 0
                        message: message,
                        isMaxReached: false
                    });
                } else {
                    console.error(`‚ùå [URL] Invalid target for goal${goalIndex}: ${target}`);
                }
                goalIndex++;
            }

            console.error(`üîó [URL] Total goals found: ${goals.length}`);
            if (goals.length > 0) {
                // Trier par target croissant
                goals.sort((a, b) => a.target - b.target);
                setStorage(STORAGE_KEYS.GOALS, goals);
                console.error(`üîó [URL] Successfully loaded ${goals.length} goal(s) from URL:`, goals);
                // Verify storage
                const storedGoals = getStorage(STORAGE_KEYS.GOALS) || [];
                console.error(`üîó [URL] Verified storage - goals count: ${storedGoals.length}`);
                return true; // Return true if goals were loaded
            }
            console.error('üîó [URL] No goals found in URL parameters');
            return false; // Return false if no goals in URL
        }

        function loadGoals(useFileOverride = false) {
            // Use console.error so logs always show (not filtered)
            console.error(`üîÑ [LoadGoals] Starting loadGoals(useFileOverride=${useFileOverride})`);
            console.error(`üîÑ [LoadGoals] Current URL: ${window.location.href}`);
            console.error(`üîÑ [LoadGoals] urlParams object exists:`, typeof urlParams !== 'undefined');
            console.error(`üîÑ [LoadGoals] urlParams.has('goal1'):`, urlParams ? urlParams.has('goal1') : 'urlParams is undefined');
            console.error(`üîÑ [LoadGoals] urlParams.get('goal1'):`, urlParams ? urlParams.get('goal1') : 'urlParams is undefined');

            // Priority: File cache > URL parameters
            // File cache persists in localStorage and takes priority until cleared via !cleargoals
            // If useFileOverride is true, file was just uploaded - use it to override URL

            if (useFileOverride) {
                // File was just uploaded: Use it (override URL)
                console.error('üìÅ [LoadGoals] File override mode - checking file first');
                if (loadGoalsFromFile()) {
                    console.error('üìÅ [File] Goals loaded from file (overriding URL)');
                    return true;
                }
            } else {
                // Initial load: Check file cache first (it persists and takes priority)
                const fileContent = localStorage.getItem(STORAGE_KEYS.FILE_CONTENT);
                if (fileContent && fileContent.trim() !== '') {
                    console.error('üìÅ [LoadGoals] File cache found in localStorage - using it (takes priority over URL)');
                    if (loadGoalsFromFile()) {
                        console.error('üìÅ [File] Goals loaded from file cache');
                        return true;
                    }
                } else {
                    console.error('üìÅ [LoadGoals] No file cache found - checking URL parameters');
                }
                
                // No file cache: Try URL parameters
                if (!urlParams) {
                    console.error('‚ùå [LoadGoals] urlParams is undefined!');
                    return false;
                }
                const urlHasGoals = urlParams.has('goal1') || urlParams.has('goal2') || urlParams.has('goal3');
                console.error(`üîó [LoadGoals] URL has goals: ${urlHasGoals}`);

                if (urlHasGoals) {
                    // URL has goals: Use them (file cache doesn't exist)
                    console.error('üîó [LoadGoals] Loading goals from URL');
                    if (loadGoalsFromURL()) {
                        console.error('üîó [URL] Goals loaded from URL');
                        return true;
                    } else {
                        console.error('‚ùå [LoadGoals] URL has goal parameters but loadGoalsFromURL() returned false!');
                    }
                } else {
                    // Try URL anyway (might have goals but not goal1/goal2/goal3)
                    console.error('üîó [LoadGoals] Trying URL as fallback');
                    if (loadGoalsFromURL()) {
                        console.error('üîó [URL] Goals loaded from URL');
                        return true;
                    }
                }
            }

            console.error('‚ùå [LoadGoals] No goals loaded from URL or file');
            return false;
        }

        // Configuration Twitch OAuth2
        // Client ID par d√©faut pour le sub overlay (toujours utilis√©, non modifiable par l'utilisateur)
        const DEFAULT_CLIENT_ID = '2hrf11ylh7b8pastpnk6mcsnzi9d4l';
        // Toujours utiliser le Client ID par d√©faut, ignorer tout param√®tre client_id de l'URL
        const TWITCH_CLIENT_ID = DEFAULT_CLIENT_ID;

        // Pr√©server les param√®tres URL pour la redirection OAuth
        const currentUrlParams = new URLSearchParams(window.location.search);
        const preservedParams = [];
        for (const [key, value] of currentUrlParams.entries()) {
            if (key !== 'access_token' && key !== 'error' && key !== 'error_description') {
                preservedParams.push(`${key}=${encodeURIComponent(value)}`);
            }
        }
        // IMPORTANT: Pour OAuth, on utilise uniquement l'URL de base (sans param√®tres)
        // Les param√®tres seront pr√©serv√©s via localStorage
        const TWITCH_REDIRECT_URI = window.location.origin + window.location.pathname;
        const TWITCH_SCOPES = ['user:read:email', 'channel:read:subscriptions', 'moderator:read:followers'];

        // V√©rifier si on est sur file:// (ne fonctionnera pas avec OAuth2)
        const isLocalFile = window.location.protocol === 'file:';
        if (isLocalFile) {
            console.warn('‚ö†Ô∏è ATTENTION: L\'overlay est ouvert en local (file://). OAuth2 Twitch n√©cessite HTTPS.');
            console.warn('üí° Solution: D√©ployez l\'overlay sur GitHub Pages ou un autre h√©bergeur HTTPS.');
            console.warn('üìã Redirect URI √† configurer dans Twitch Developer Portal:', TWITCH_REDIRECT_URI);
        }

        // Fonction pour obtenir l'URL d'authentification
        function getTwitchAuthUrl() {
            if (!TWITCH_CLIENT_ID) {
                alert('‚ö†Ô∏è Client ID manquant. Veuillez le configurer dans les param√®tres.');
                return null;
            }

            if (isLocalFile) {
                alert('‚ö†Ô∏è OAuth2 ne fonctionne pas avec file://\n\n' +
                      'üìã Pour utiliser cet overlay:\n' +
                      '1. D√©ployez-le sur GitHub Pages (HTTPS)\n' +
                      '2. Configurez cette URL dans Twitch Developer Portal:\n' +
                      `   ${window.location.origin + window.location.pathname}\n\n` +
                      'üîó GitHub Pages: https://pages.github.com/');
                return null;
            }

            // IMPORTANT: Twitch exige que l'URL de redirection corresponde EXACTEMENT √† celle enregistr√©e
            // On utilise uniquement l'URL de base (sans param√®tres) pour la redirection OAuth
            // Les param√®tres seront pr√©serv√©s via localStorage et r√©appliqu√©s apr√®s la redirection
            const baseRedirectUri = window.location.origin + window.location.pathname;

            // Sauvegarder les param√®tres actuels dans localStorage pour les restaurer apr√®s OAuth
            const paramsToPreserve = {};
            for (const [key, value] of urlParams.entries()) {
                if (key !== 'access_token' && key !== 'error' && key !== 'error_description') {
                    paramsToPreserve[key] = value;
                }
            }
            if (Object.keys(paramsToPreserve).length > 0) {
                setStorage('oauth_preserved_params', paramsToPreserve);
            }

            return `https://id.twitch.tv/oauth2/authorize?client_id=${TWITCH_CLIENT_ID}&redirect_uri=${encodeURIComponent(baseRedirectUri)}&response_type=token&scope=${TWITCH_SCOPES.join('+')}`;
        }

        // URLs API Twitch
        const TWITCH_API_BASE = 'https://api.twitch.tv/helix';
        const EVENTSUB_WS_URL = 'wss://eventsub.wss.twitch.tv/ws';

        // ==================================================================
        // üì¶ GESTION DU STOCKAGE LOCAL
        // ==================================================================
        const STORAGE_KEYS = {
            TOKEN: 'twitch_access_token',
            USER_ID: 'twitch_user_id',
            USERNAME: 'twitch_username',
            GOALS: 'overlay_goals',
            CONFIG: 'overlay_config',
            COUNTER: 'overlay_counter',
            FILE_CONTENT: 'overlay_file_content'
        };

        // Goals will be loaded in window.addEventListener('load') - don't load here

        function getStorage(key) {
            try {
                const item = localStorage.getItem(key);
                return item ? JSON.parse(item) : null;
            } catch (e) {
                return null;
            }
        }

        function setStorage(key, value) {
            try {
                localStorage.setItem(key, JSON.stringify(value));
            } catch (e) {
                console.error('Erreur sauvegarde:', e);
            }
        }

        function removeStorage(key) {
            localStorage.removeItem(key);
        }

        // ==================================================================
        // üîê AUTHENTIFICATION TWITCH
        // ==================================================================
        let accessToken = getStorage(STORAGE_KEYS.TOKEN);
        let userId = getStorage(STORAGE_KEYS.USER_ID);
        let username = getStorage(STORAGE_KEYS.USERNAME);

        function handleOAuthCallback() {
            // V√©rifier dans l'URL hash (popup callback)
            const hash = window.location.hash.substring(1);
            if (hash) {
                const params = new URLSearchParams(hash);
                const token = params.get('access_token');
                const error = params.get('error');

                if (error) {
                    console.error('Erreur OAuth:', error);
                    updateConnectionStatus('disconnected', `Erreur: ${error}`);
                    return;
                }

                if (token) {
                    accessToken = token;
                    setStorage(STORAGE_KEYS.TOKEN, token);

                    // Restaurer les param√®tres pr√©serv√©s apr√®s OAuth
                    const preservedParams = getStorage('oauth_preserved_params');
                    if (preservedParams) {
                        const newParams = new URLSearchParams();
                        for (const [key, value] of Object.entries(preservedParams)) {
                            newParams.set(key, value);
                        }
                        const newUrl = window.location.origin + window.location.pathname + '?' + newParams.toString();
                        window.history.replaceState({}, document.title, newUrl);
                        removeStorage('oauth_preserved_params');
                    } else {
                        // Nettoyer l'URL si pas de param√®tres √† restaurer
                        window.history.replaceState({}, document.title, window.location.pathname);
                    }

                    // R√©cup√©rer les infos utilisateur
                    fetchUserInfo(token);
                    return;
                }
            }

            // V√©rifier dans localStorage (popup a pu sauvegarder)
            const storedToken = getStorage(STORAGE_KEYS.TOKEN);
            if (storedToken && !accessToken) {
                accessToken = storedToken;
                const storedUserId = getStorage(STORAGE_KEYS.USER_ID);
                if (storedUserId) {
                    userId = storedUserId;
                    username = getStorage(STORAGE_KEYS.USERNAME);
                    broadcasterUsername = username; // Set for IRC connection

                    // If username is missing, fetch it from external API
                    if (!broadcasterUsername && userId) {
                        fetchBroadcasterUsernameFromAPI(userId).then(() => {
                            updateAuthUI();
                            initializeOverlay();
                        });
                    } else {
                        updateAuthUI();
                        initializeOverlay();
                    }
                } else {
                    fetchUserInfo(storedToken);
                }
            }
        }

        async function fetchUserInfo(token) {
            try {
                const response = await fetch(`${TWITCH_API_BASE}/users`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Client-Id': TWITCH_CLIENT_ID
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.data && data.data.length > 0) {
                        const user = data.data[0];
                        userId = user.id;
                        username = user.login;
                        broadcasterUsername = user.login; // Use for IRC connection
                        setStorage(STORAGE_KEYS.USER_ID, userId);
                        setStorage(STORAGE_KEYS.USERNAME, username);
                        updateAuthUI();
                        initializeOverlay();
                    }
                }
            } catch (error) {
                console.error('Erreur r√©cup√©ration infos utilisateur:', error);
            }
        }

        async function fetchBroadcasterUsernameFromAPI(broadcasterId) {
            try {
                const response = await fetch(`https://notify-api.polymedia.nl/get-twitch-channel?channel_id=${broadcasterId}`);

                if (response.ok) {
                    const data = await response.json();
                    if (data.message === 'success' && data.data && data.data.info && data.data.info.length > 0) {
                        const broadcasterLogin = data.data.info[0].broadcaster_login;
                        if (broadcasterLogin) {
                            broadcasterUsername = broadcasterLogin;
                            // Also update username if it's missing
                            if (!username) {
                                username = broadcasterLogin;
                                setStorage(STORAGE_KEYS.USERNAME, username);
                            }
                            console.log('‚úÖ [IRC] Broadcaster username r√©cup√©r√©:', broadcasterUsername);
                            return broadcasterLogin;
                        }
                    }
                } else {
                    console.warn('‚ö†Ô∏è [IRC] Impossible de r√©cup√©rer le broadcaster username depuis l\'API externe');
                }
            } catch (error) {
                console.error('‚ùå [IRC] Erreur lors de la r√©cup√©ration du broadcaster username:', error);
            }
            return null;
        }

        function connectTwitch() {
            const authUrl = getTwitchAuthUrl();
            if (!authUrl) return;

            // Ne pas sauvegarder le Client ID dans localStorage pour √©viter de remplacer le Client ID par d√©faut
            // Le sub overlay utilise toujours le Client ID par d√©faut sauf si explicitement fourni via URL

            // Utiliser redirect (plus simple pour OAuth2)
            // La popup peut avoir des probl√®mes de CORS avec localStorage
            window.location.href = authUrl;
        }

        function disconnectTwitch() {
            accessToken = null;
            userId = null;
            username = null;
            broadcasterUsername = null;
            removeStorage(STORAGE_KEYS.TOKEN);
            removeStorage(STORAGE_KEYS.USER_ID);
            removeStorage(STORAGE_KEYS.USERNAME);
            updateAuthUI();
            disconnectEventSub();
            disconnectIRC();
            stopPolling();
        }

        function updateAuthUI() {
            const authStatus = document.getElementById('authStatus');
            const connectBtn = document.getElementById('connectTwitchBtn');
            const disconnectBtn = document.getElementById('disconnectTwitchBtn');
            const connectOverlayBtn = document.getElementById('connectOverlayBtn');
            const authSection = document.querySelector('.auth-section');

            if (accessToken && userId) {
                authStatus.className = 'auth-status connected';
                authStatus.innerHTML = `<span>‚úÖ Connect√©: ${username || userId}</span>`;
                connectBtn.style.display = 'none';
                disconnectBtn.style.display = 'block';
                // Masquer le bouton overlay et la section auth dans la modal
                if (connectOverlayBtn) connectOverlayBtn.style.display = 'none';
                if (authSection) authSection.style.display = 'none';
            } else {
                authStatus.className = 'auth-status disconnected';
                authStatus.innerHTML = '<span>‚ùå Non connect√©</span>';
                connectBtn.style.display = 'block';
                disconnectBtn.style.display = 'none';
                // Afficher le bouton overlay si pas en mode config
                if (connectOverlayBtn && !CONFIG_MODE) {
                    connectOverlayBtn.style.display = 'block';
                }
                if (authSection) authSection.style.display = 'block';
            }
        }

        // ==================================================================
        // üìä GESTION DES COMPTEURS
        // ==================================================================
        let currentCount = getStorage(STORAGE_KEYS.COUNTER) || 0;
        let lastApiCount = null; // Track the last count from API for sync comparison
        let previousCount = null;
        let animationDirection = 'down';
        let isAnimating = false;
        let animationQueue = [];
        const counterEl = document.getElementById('counter');
        let maxGoalReached = 0; // Track le goal maximum atteint (ne diminue jamais)
        let previousDisplayText = ''; // Track le texte pr√©c√©dent pour comparaison caract√®re par caract√®re

        // ==================================================================
        // üé® ANIMATIONS SLOT MACHINE
        // ==================================================================
        function createDigitElement(char, className, delay) {
            const div = document.createElement('div');
            div.className = className + ' digit';
            div.textContent = char;
            div.style.animationDelay = `${delay}ms`;
            return div;
        }

        function updateCounter(newText, useSimpleText = false) {
            // Si c'est un message texte simple (pas un nombre/goal), afficher directement
            // La regex doit correspondre aux formats: "13", "13/100", "13/100 : message"
            const isGoalFormat = /^\d+(\/\d+)?(\s*:\s*.+)?$/.test(newText.trim());

            if (useSimpleText || !isGoalFormat) {
                counterEl.textContent = newText;
                previousDisplayText = newText;
                return;
            }

            // R√©cup√©rer le texte actuel depuis le DOM (si c'est la premi√®re fois, utiliser previousDisplayText)
            let currentText = previousDisplayText;

            // Si c'est le premier chargement et qu'on n'a pas de previousDisplayText,
            // initialiser avec le texte actuel du DOM ou le nouveau texte
            if (!currentText) {
                const domText = counterEl.textContent.trim();
                // Ignorer "--" qui est le placeholder par d√©faut
                if (domText && domText !== '--' && domText !== newText) {
                    currentText = domText;
                } else {
                    // Premier chargement - cr√©er les containers directement sans animation
                    currentText = newText;
                }
            }

            // Si le texte est identique et qu'on a d√©j√† un previousDisplayText, ne rien faire
            // Mais si previousDisplayText est vide, on doit quand m√™me cr√©er les containers
            if (newText === currentText && previousDisplayText === newText && previousDisplayText !== '') return;

            const newChars = newText.split('');
            const oldChars = currentText.split('');
            counterEl.innerHTML = '';

            const measureDiv = document.createElement('div');
            measureDiv.style.visibility = 'hidden';
            measureDiv.style.position = 'absolute';
            measureDiv.style.whiteSpace = 'nowrap';
            measureDiv.style.display = 'inline-block';

            const counterStyles = getComputedStyle(counterEl);
            measureDiv.style.fontSize = counterStyles.fontSize;
            measureDiv.style.fontFamily = counterStyles.fontFamily;
            measureDiv.style.fontWeight = counterStyles.fontWeight;
            measureDiv.style.fontStyle = counterStyles.fontStyle;
            measureDiv.style.letterSpacing = counterStyles.letterSpacing;
            measureDiv.style.textShadow = counterStyles.textShadow;
            measureDiv.style.webkitTextStroke = counterStyles.webkitTextStroke;

            document.body.appendChild(measureDiv);

            // Parcourir chaque position et animer seulement les caract√®res qui changent
            const maxLength = Math.max(newChars.length, oldChars.length);

            for (let i = 0; i < maxLength; i++) {
                const newChar = newChars[i] || '';
                const oldChar = oldChars[i] || '';
                const charChanged = newChar !== oldChar;

                if (newChar === ' ') {
                    const spaceContainer = document.createElement('div');
                    spaceContainer.className = 'space-container';
                    spaceContainer.innerHTML = '&nbsp;';
                    counterEl.appendChild(spaceContainer);
                } else {
                    const container = document.createElement('div');
                    container.className = 'digit-container';

                    // Mesurer la largeur du caract√®re
                    measureDiv.textContent = newChar || oldChar || 'M'; // Utiliser 'M' comme r√©f√©rence si vide
                    const charWidth = measureDiv.getBoundingClientRect().width;
                    container.style.width = `${Math.max(charWidth, 10)}px`;

                    // Si c'est le premier chargement et que le texte est identique, cr√©er sans animation
                    const isFirstLoad = !previousDisplayText && newText === currentText;

                    if ((!charChanged && oldChar) || isFirstLoad) {
                        // Caract√®re identique ou premier chargement - afficher statiquement
                        const staticDigit = createDigitElement(newChar, 'static', 0);
                        staticDigit.style.transform = 'translateY(0)';
                        staticDigit.style.position = 'relative'; // Pour √©viter les probl√®mes de positionnement
                        container.appendChild(staticDigit);
                    } else {
                        // Caract√®re qui change - animer
                        const delay = i * 30; // D√©lai progressif pour l'effet cascade
                        const oldDigit = createDigitElement(oldChar || ' ', 'old', delay);
                        const newDigit = createDigitElement(newChar, 'new', delay);

                        container.appendChild(oldDigit);
                        container.appendChild(newDigit);
                        container.classList.add('animate');
                        container.classList.add(`animate-${animationDirection}`);
                    }

                    counterEl.appendChild(container);
                }
            }

            document.body.removeChild(measureDiv);
            previousDisplayText = newText; // Sauvegarder pour la prochaine comparaison
        }

        function animateCounterProgressive(fromCount, toCount, goal, direction) {
            const steps = Math.abs(toCount - fromCount);

            if (steps === 0) {
                displayGoalText(goal, direction);
                return;
            }

            // Adaptive duration: faster and smoother for large jumps
            // Small jumps (1-10): 800ms - smooth and visible
            // Medium jumps (11-50): 500ms - faster but still smooth
            // Large jumps (51-150): 600ms - smooth acceleration
            // Very large jumps (151+): 700ms - smooth with fewer updates
            let totalDuration;
            let updateFrequency;

            if (steps <= 10) {
                totalDuration = 800;
                updateFrequency = 1; // Update every frame
            } else if (steps <= 50) {
                totalDuration = 500;
                updateFrequency = 1; // Update every frame
            } else if (steps <= 150) {
                totalDuration = 600;
                updateFrequency = Math.max(2, Math.floor(steps / 30)); // Show ~30 intermediate values
            } else {
                // Very large jumps: smooth but fast
                totalDuration = 700;
                updateFrequency = Math.max(5, Math.floor(steps / 25)); // Show ~25 intermediate values
            }

            const startTime = performance.now();
            let lastDisplayedValue = fromCount;
            let frameCount = 0;

            // Better easing function for smoother large jumps
            function easeOutExpo(t) {
                return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
            }

            // Alternative: smooth ease-in-out for large numbers
            function easeInOutCubic(t) {
                return t < 0.5
                    ? 4 * t * t * t
                    : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }

            // Use exponential ease for large jumps (feels more dynamic)
            // Use cubic ease for smaller jumps (feels smoother)
            const easingFunction = steps > 50 ? easeOutExpo : easeInOutCubic;

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / totalDuration, 1);
                const easedProgress = easingFunction(progress);
                const currentValue = Math.round(fromCount + (toCount - fromCount) * easedProgress);

                frameCount++;

                // Update based on frequency (for large jumps, skip some frames)
                const shouldUpdate = frameCount % updateFrequency === 0 ||
                                   currentValue === toCount ||
                                   progress === 1 ||
                                   Math.abs(currentValue - lastDisplayedValue) >= updateFrequency;

                if (shouldUpdate && (currentValue !== lastDisplayedValue || progress === 1)) {
                    lastDisplayedValue = currentValue;
                    const intermediateGoal = { ...goal, current: currentValue };
                    displayGoalText(intermediateGoal, direction);
                }

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Ensure final value is displayed
                    const finalGoal = { ...goal, current: toCount };
                    displayGoalText(finalGoal, direction);
                    isAnimating = false;
                    processAnimationQueue();
                }
            }

            requestAnimationFrame(animate);
        }

        function displayGoalText(goal, direction = null) {
            if (direction !== null) {
                animationDirection = direction;
            }

            const goals = getStorage(STORAGE_KEYS.GOALS) || [];
            let activeGoal = goal;
            let displayTarget;

            // If no goals exist, create a virtual goal (next multiple of 100 above count)
            if (goals.length === 0) {
                const nextMultiple = Math.ceil(goal.current / 100) * 100;
                displayTarget = Math.max(100, nextMultiple);
                // Virtual goal: show count/goal : (no message)
                displayText = `${goal.current}/${displayTarget} :`;
                updateCounter(displayText);
                return;
            }

            // Sort goals by target (ascending) to ensure correct order
            goals.sort((a, b) => a.target - b.target);

            // Find the appropriate goal for the current count
            // Keep moving forward through goals until we find one that isn't exceeded
            let foundGoal = false;
            activeGoal = null;

            // First, mark all reached/exceeded goals as reached
            for (let i = 0; i < goals.length; i++) {
                if (goal.current >= goals[i].target && !goals[i].isMaxReached) {
                    goals[i].isMaxReached = true;
                    setStorage(STORAGE_KEYS.GOALS, goals);
                }
            }

            // Find the first goal that hasn't been reached yet (count < goal.target)
            for (let i = 0; i < goals.length; i++) {
                if (goal.current < goals[i].target) {
                    activeGoal = goals[i];
                    activeGoal.current = goal.current;
                    foundGoal = true;
                    break;
                }
            }

            // If all goals are exceeded, auto-update from last goal + 100
            if (!foundGoal) {
                const lastGoal = goals[goals.length - 1];
                const nextMultiple = Math.ceil(goal.current / 100) * 100;
                const newTarget = Math.max(lastGoal.target + 100, nextMultiple);

                // Update the last goal's target and clear message (auto-updated goals don't show messages)
                const lastGoalIndex = goals.length - 1;
                goals[lastGoalIndex].target = newTarget;
                goals[lastGoalIndex].message = ''; // Clear message for auto-updated goal
                lastGoal.target = newTarget;
                lastGoal.message = ''; // Clear message for activeGoal reference
                activeGoal = lastGoal;
                activeGoal.current = goal.current;
                activeGoal.isMaxReached = false; // Reset so it can be used
                setStorage(STORAGE_KEYS.GOALS, goals);
                console.log(`üìä [Goal] All goals exceeded, auto-updated last goal to ${newTarget} (count: ${goal.current})`);
            }

            displayTarget = activeGoal.target;

            // Mettre √† jour le goal maximum atteint (ne diminue jamais)
            if (activeGoal.current >= activeGoal.target && activeGoal.target > maxGoalReached) {
                maxGoalReached = activeGoal.target;
            }

            // Build display text: count/goal : message (if message exists and it's a real goal)
            // For virtual goals or auto-updated goals (all goals exceeded), don't show message
            const isAutoUpdatedGoal = !foundGoal; // This means all goals were exceeded and we auto-updated
            const hasMessage = activeGoal.message && activeGoal.message.trim() !== '';

            if (hasMessage && !isAutoUpdatedGoal) {
                // Real goal with message: show count/goal : message
                displayText = `${activeGoal.current}/${displayTarget} : ${activeGoal.message}`;
            } else {
                // Virtual goal or auto-updated goal: show count/goal : (with colon but no message)
                displayText = `${activeGoal.current}/${displayTarget} :`;
            }

            updateCounter(displayText);
        }

        function processAnimationQueue() {
            if (animationQueue.length > 0 && !isAnimating) {
                const nextAnimation = animationQueue.shift();
                isAnimating = true;
                animateCounterProgressive(nextAnimation.from, nextAnimation.to, nextAnimation.goal, nextAnimation.direction);
            }
        }

        // ==================================================================
        // üí¨ IRC CHAT CONNECTION
        // ==================================================================
        let ircWebSocket = null;
        let ircReconnectDelay = 1000;
        let broadcasterUsername = null; // Channel name for IRC connection

        // ==================================================================
        // üîå EVENTSUB WEBSOCKET
        // ==================================================================
        let eventSubWs = null;
        let eventSubSessionId = null;
        let eventSubReconnectDelay = 1000;

        async function connectEventSub() {
            if (!accessToken || !userId) {
                console.log('‚ö†Ô∏è Pas de token ou userId, impossible de se connecter √† EventSub');
                return;
            }

            try {
                eventSubWs = new WebSocket(EVENTSUB_WS_URL);

                eventSubWs.onopen = () => {
                    console.log('‚úÖ EventSub WebSocket connect√©');
                    eventSubReconnectDelay = 1000;
                    updateConnectionStatus('connected', 'EventSub connect√©');
                };

                eventSubWs.onmessage = async (event) => {
                    const message = JSON.parse(event.data);
                    await handleEventSubMessage(message);
                };

                eventSubWs.onerror = (error) => {
                    console.error('‚ùå Erreur EventSub:', error);
                    updateConnectionStatus('disconnected', 'Erreur EventSub');
                };

                eventSubWs.onclose = () => {
                    console.log('üîå EventSub d√©connect√©, reconnexion...');
                    updateConnectionStatus('disconnected', 'EventSub d√©connect√©');
                    eventSubWs = null;
                    eventSubSessionId = null;
                    setTimeout(connectEventSub, eventSubReconnectDelay);
                    eventSubReconnectDelay = Math.min(eventSubReconnectDelay * 1.5, 10000);
                };
            } catch (error) {
                console.error('‚ùå Erreur connexion EventSub:', error);
                setTimeout(connectEventSub, eventSubReconnectDelay);
            }
        }

        async function handleEventSubMessage(message) {
            const messageType = message.metadata?.message_type;

            switch (messageType) {
                case 'session_welcome':
                    eventSubSessionId = message.payload.session.id;
                    console.log('‚úÖ Session EventSub cr√©√©e:', eventSubSessionId);
                    await subscribeToEvents();
                    break;

                case 'session_keepalive':
                    // Keepalive re√ßu, connexion OK
                    break;

                case 'notification':
                    await handleEventSubNotification(message.payload);
                    break;

                case 'session_reconnect':
                    // Reconnexion n√©cessaire
                    if (message.payload.session.reconnect_url) {
                        connectEventSub();
                    }
                    break;
            }
        }

        async function subscribeToEvents() {
            if (!eventSubSessionId || !accessToken || !userId) return;

            if (OVERLAY_TYPE === 'sub') {
                // Subscribe only to channel.subscribe (gift subs also trigger this event)
                // We don't subscribe to channel.subscription.gift or channel.subscription.message
                // to avoid double-counting (gift subs already trigger channel.subscribe for each recipient)
                try {
                    const response = await fetch(`${TWITCH_API_BASE}/eventsub/subscriptions`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${accessToken}`,
                            'Client-Id': TWITCH_CLIENT_ID,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            type: 'channel.subscribe',
                            version: '1',
                            condition: {
                                broadcaster_user_id: userId
                            },
                            transport: {
                                method: 'websocket',
                                session_id: eventSubSessionId
                            }
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        console.log('‚úÖ Subscription EventSub cr√©√©e pour channel.subscribe:', data);
                    } else {
                        const error = await response.text();
                        console.error('‚ùå Erreur cr√©ation subscription channel.subscribe:', error);
                    }
                } catch (error) {
                    console.error('‚ùå Erreur subscription EventSub channel.subscribe:', error);
                }
            } else {
                // For follows, subscribe to channel.follow (version 2 requires moderator_user_id)
                try {
                    const response = await fetch(`${TWITCH_API_BASE}/eventsub/subscriptions`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${accessToken}`,
                            'Client-Id': TWITCH_CLIENT_ID,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            type: 'channel.follow',
                            version: '2',
                            condition: {
                                broadcaster_user_id: userId,
                                moderator_user_id: userId // Required for version 2, use broadcaster's ID
                            },
                            transport: {
                                method: 'websocket',
                                session_id: eventSubSessionId
                            }
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        console.log('‚úÖ Subscription EventSub cr√©√©e pour channel.follow:', data);
                    } else {
                        const error = await response.text();
                        console.error('‚ùå Erreur cr√©ation subscription channel.follow:', error);
                    }
                } catch (error) {
                    console.error('‚ùå Erreur subscription EventSub channel.follow:', error);
                }
            }
        }

        async function handleEventSubNotification(payload) {
            // EventSub notification structure: payload.subscription.type contains the event type
            const subscriptionType = payload.subscription?.type;

            if (OVERLAY_TYPE === 'sub') {
                if (subscriptionType === 'channel.subscribe') {
                    // Nouveau sub ‚Üí increment by 1
                    // Note: Gift subscriptions also trigger channel.subscribe events (one per recipient)
                    // so we only need to listen to this event type to avoid double-counting
                    currentCount++;
                    console.log('üìä [EventSub] Nouveau sub d√©tect√©, count:', currentCount);
                    updateCounterFromEvent();
                }
                // Ignore channel.subscription.gift and channel.subscription.message
                // to avoid double-counting (gift subs already trigger channel.subscribe for each recipient)
            } else if (OVERLAY_TYPE === 'follow' && subscriptionType === 'channel.follow') {
                // Nouveau follow
                currentCount++;
                console.log('üë• [EventSub] Nouveau follow d√©tect√©, count:', currentCount);
                updateCounterFromEvent();
            }
        }

        function disconnectEventSub() {
            if (eventSubWs) {
                eventSubWs.close();
                eventSubWs = null;
                eventSubSessionId = null;
            }
        }

        // ==================================================================
        // üì° POLLING API TWITCH (BACKUP/SYNC)
        // ==================================================================
        let pollingInterval = null;
        const POLLING_INTERVAL = OVERLAY_TYPE === 'follow' ? 10000 : 120000; // 10s pour follows, 120s (2min) pour subs
        let isFirstFetch = true; // Pour forcer l'affichage au premier chargement

        async function fetchTwitchCount() {
            if (!accessToken || !userId) {
                console.log('‚ö†Ô∏è fetchTwitchCount: Pas de token ou userId, impossible de fetch');
                return;
            }

            // S'assurer qu'on a des goals avant de fetch
            const goals = getStorage(STORAGE_KEYS.GOALS) || [];
            if (goals.length === 0) {
                // Essayer de charger depuis l'URL
                loadGoals(false);
                const urlGoals = getStorage(STORAGE_KEYS.GOALS) || [];
                if (urlGoals.length === 0) {
                    console.log('‚ö†Ô∏è fetchTwitchCount: Aucun goal configur√©, impossible d\'afficher');
                    return;
                }
            }

            try {
                let endpoint;
                if (OVERLAY_TYPE === 'sub') {
                    // Pour les subs, on doit paginer pour obtenir le total
                    endpoint = `${TWITCH_API_BASE}/subscriptions?broadcaster_id=${userId}&first=100`;
                } else {
                    // Pour les follows, on peut obtenir le total directement
                    endpoint = `${TWITCH_API_BASE}/channels/followers?broadcaster_id=${userId}&first=1`;
                }

                const response = await fetch(endpoint, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Client-Id': TWITCH_CLIENT_ID
                    }
                });

                if (response.ok) {
                    const data = await response.json();

                    if (OVERLAY_TYPE === 'sub') {
                        // Pour les subs, on doit compter toutes les pages
                        let total = data.data?.length || 0;
                        let cursor = data.pagination?.cursor;

                        // Paginer pour obtenir le total r√©el
                        while (cursor) {
                            try {
                                const nextResponse = await fetch(`${endpoint}&after=${cursor}`, {
                                    headers: {
                                        'Authorization': `Bearer ${accessToken}`,
                                        'Client-Id': TWITCH_CLIENT_ID
                                    }
                                });

                                if (nextResponse.ok) {
                                    const nextData = await nextResponse.json();
                                    total += nextData.data?.length || 0;
                                    cursor = nextData.pagination?.cursor;
                                } else {
                                    break;
                                }
                            } catch (e) {
                                break;
                            }
                        }

                        // Flow: On first fetch, set both currentCount and lastApiCount
                        // On subsequent fetches, only sync if API count differs from lastApiCount
                        const wasFirstFetch = isFirstFetch;
                        const oldCount = currentCount;

                        if (isFirstFetch) {
                            // First fetch: Set currentCount = apiCount, lastApiCount = apiCount
                            currentCount = total;
                            lastApiCount = total;
                            setStorage(STORAGE_KEYS.COUNTER, total);
                            isFirstFetch = false;
                            console.log('üìä [API] Premier fetch - count initialis√©:', total);
                            updateCounterFromPolling(oldCount, total, true);
                        } else {
                            // Subsequent fetch: Only sync if apiCount !== lastApiCount
                            if (total !== lastApiCount) {
                                // API count changed - sync to API value
                                console.log(`üìä [API] Sync d√©tect√©: lastApiCount=${lastApiCount}, apiCount=${total}, currentCount=${currentCount}`);
                                currentCount = total;
                                lastApiCount = total;
                                setStorage(STORAGE_KEYS.COUNTER, total);
                                updateCounterFromPolling(oldCount, total, false);
                            } else {
                                // API count unchanged - keep EventSub-based value
                                console.log(`üìä [API] Pas de changement (apiCount=${total} === lastApiCount=${lastApiCount}), garde currentCount=${currentCount}`);
                                // Don't update, keep EventSub-based currentCount
                            }
                        }
                    } else {
                        // Pour les follows, l'API peut retourner total dans data.total
                        // Mais parfois il faut paginer pour obtenir le vrai total
                        let total = data.total;

                        // Si total n'est pas pr√©sent, null, ou si on a des donn√©es mais total est 0, on doit paginer
                        const hasData = data.data && data.data.length > 0;
                        if (total === undefined || total === null || (total === 0 && hasData)) {
                            // Paginer pour obtenir le total r√©el
                            let count = data.data?.length || 0;
                            let cursor = data.pagination?.cursor;

                            while (cursor) {
                                try {
                                    const nextResponse = await fetch(`${endpoint}&after=${cursor}`, {
                                        headers: {
                                            'Authorization': `Bearer ${accessToken}`,
                                            'Client-Id': TWITCH_CLIENT_ID
                                        }
                                    });

                                    if (nextResponse.ok) {
                                        const nextData = await nextResponse.json();
                                        count += nextData.data?.length || 0;
                                        cursor = nextData.pagination?.cursor;
                                    } else {
                                        break;
                                    }
                                } catch (e) {
                                    break;
                                }
                            }
                            total = count;
                        }

                        // Flow: On first fetch, set both currentCount and lastApiCount
                        // On subsequent fetches, only sync if API count differs from lastApiCount
                        const wasFirstFetch = isFirstFetch;
                        const oldCount = currentCount;
                        const apiCount = total !== undefined && total !== null ? total : 0;

                        if (isFirstFetch) {
                            // First fetch: Set currentCount = apiCount, lastApiCount = apiCount
                            currentCount = apiCount;
                            lastApiCount = apiCount;
                            setStorage(STORAGE_KEYS.COUNTER, apiCount);
                            isFirstFetch = false;
                            console.log('üìä [API] Premier fetch - count initialis√©:', apiCount);
                            updateCounterFromPolling(oldCount, apiCount, true);
                        } else {
                            // Subsequent fetch: Only sync if apiCount !== lastApiCount
                            if (apiCount !== lastApiCount) {
                                // API count changed - sync to API value
                                console.log(`üìä [API] Sync d√©tect√©: lastApiCount=${lastApiCount}, apiCount=${apiCount}, currentCount=${currentCount}`);
                                currentCount = apiCount;
                                lastApiCount = apiCount;
                                setStorage(STORAGE_KEYS.COUNTER, apiCount);
                                updateCounterFromPolling(oldCount, apiCount, false);
                            } else {
                                // API count unchanged - keep EventSub-based value
                                console.log(`üìä [API] Pas de changement (apiCount=${apiCount} === lastApiCount=${lastApiCount}), garde currentCount=${currentCount}`);
                                // Don't update, keep EventSub-based currentCount
                            }
                        }
                    }
                } else if (response.status === 401) {
                    // Token expir√©
                    console.error('‚ùå Token expir√©, reconnexion n√©cessaire');
                    updateConnectionStatus('disconnected', 'Token expir√© - Reconnexion n√©cessaire');
                    disconnectTwitch();
                } else if (response.status === 403) {
                    // Pas les permissions
                    console.error('‚ùå Permissions insuffisantes');
                    updateConnectionStatus('disconnected', 'Permissions insuffisantes');
                } else {
                    const errorText = await response.text();
                    console.error('‚ùå Erreur API Twitch:', response.status, errorText);
                }

                // M√™me en cas d'erreur, essayer d'afficher avec le count stock√© ou 0
                if (isFirstFetch) {
                    const goals = getStorage(STORAGE_KEYS.GOALS) || [];
                    if (goals.length > 0) {
                        const activeGoal = goals.find(g => !g.isMaxReached) || goals[goals.length - 1];
                        if (activeGoal) {
                            activeGoal.current = currentCount || 0;
                            isFirstFetch = false;
                            displayGoalText(activeGoal);
                        }
                    }
                }
            } catch (error) {
                // Erreur CORS possible - on continue avec EventSub uniquement
                if (error.message.includes('CORS') || error.message.includes('Failed to fetch')) {
                    console.warn('‚ö†Ô∏è CORS bloqu√© - Utilisation d\'EventSub uniquement');
                    updateConnectionStatus('disconnected', 'CORS bloqu√© - EventSub uniquement');
                } else {
                    console.error('‚ùå Erreur polling Twitch:', error);
                }

                // M√™me en cas d'erreur, essayer d'afficher avec le count stock√© ou 0
                if (isFirstFetch) {
                    const goals = getStorage(STORAGE_KEYS.GOALS) || [];
                    if (goals.length > 0) {
                        const activeGoal = goals.find(g => !g.isMaxReached) || goals[goals.length - 1];
                        if (activeGoal) {
                            activeGoal.current = currentCount || 0;
                            isFirstFetch = false;
                            displayGoalText(activeGoal);
                        }
                    }
                }
            }
        }

        function startPolling() {
            if (pollingInterval) return;

            // S'assurer que les goals sont charg√©s avant de fetch
            const goals = getStorage(STORAGE_KEYS.GOALS) || [];
            if (goals.length === 0) {
                // Si pas de goals, essayer de charger depuis l'URL
                loadGoals(false);
            }

            // Premier appel imm√©diat (va fetch et afficher le count)
            fetchTwitchCount();

            // Puis polling r√©gulier
            pollingInterval = setInterval(fetchTwitchCount, POLLING_INTERVAL);
        }

        function stopPolling() {
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
        }

        // Batch rapid updates together
        let pendingEventUpdate = null;
        let eventUpdateTimeout = null;
        let batchStartCount = null; // Track the count when batching started
        const EVENT_BATCH_DELAY = 100; // Batch events within 100ms

        function updateCounterFromEvent() {
            setStorage(STORAGE_KEYS.COUNTER, currentCount);

            const goals = getStorage(STORAGE_KEYS.GOALS) || [];

            // If no goals exist, create a virtual goal for display
            if (goals.length === 0) {
                const nextMultiple = Math.ceil(currentCount / 100) * 100;
                const virtualTarget = Math.max(100, nextMultiple);
                const virtualGoal = {
                    target: virtualTarget,
                    current: currentCount,
                    message: '',
                    isMaxReached: false
                };
                displayGoalText(virtualGoal);
                previousCount = currentCount;
                return;
            }

            // Sort goals by target (ascending)
            goals.sort((a, b) => a.target - b.target);

            // First, mark all reached/exceeded goals as reached
            for (let i = 0; i < goals.length; i++) {
                if (currentCount >= goals[i].target && !goals[i].isMaxReached) {
                    goals[i].isMaxReached = true;
                    setStorage(STORAGE_KEYS.GOALS, goals);
                }
            }

            // Find the first goal that hasn't been reached yet (count < goal.target)
            let activeGoal = null;
            let foundGoal = false;
            for (let i = 0; i < goals.length; i++) {
                if (currentCount < goals[i].target) {
                    activeGoal = goals[i];
                    activeGoal.current = currentCount;
                    foundGoal = true;
                    break;
                }
            }

            // If all goals are exceeded, auto-update from last goal + 100
            if (!foundGoal) {
                const lastGoal = goals[goals.length - 1];
                const nextMultiple = Math.ceil(currentCount / 100) * 100;
                const newTarget = Math.max(lastGoal.target + 100, nextMultiple);

                // Update the last goal's target and clear message (auto-updated goals don't show messages)
                const lastGoalIndex = goals.length - 1;
                goals[lastGoalIndex].target = newTarget;
                goals[lastGoalIndex].message = ''; // Clear message for auto-updated goal
                lastGoal.target = newTarget;
                lastGoal.message = ''; // Clear message for activeGoal reference
                activeGoal = lastGoal;
                activeGoal.current = currentCount;
                activeGoal.isMaxReached = false; // Reset so it can be used
                setStorage(STORAGE_KEYS.GOALS, goals);
                console.log(`üìä [Goal] All goals exceeded, auto-updated last goal to ${newTarget} (count: ${currentCount})`);
            }

            // Mettre √† jour maxGoalReached si on atteint un nouveau goal
            if (currentCount >= activeGoal.target && activeGoal.target > maxGoalReached) {
                maxGoalReached = activeGoal.target;
            }

            // If this is the first event in a batch, remember the starting count
            if (batchStartCount === null) {
                batchStartCount = previousCount !== null ? previousCount : (activeGoal.current || 0);
            }

            // Store the pending update (will be updated with latest count)
            pendingEventUpdate = {
                activeGoal: { ...activeGoal },
                startCount: batchStartCount,
                newCount: currentCount
            };

            // Clear existing timeout
            if (eventUpdateTimeout) {
                clearTimeout(eventUpdateTimeout);
            }

            // Batch rapid updates: wait a bit to see if more events come in
            eventUpdateTimeout = setTimeout(() => {
                if (pendingEventUpdate) {
                    const update = pendingEventUpdate;
                    pendingEventUpdate = null;
                    const startCount = batchStartCount;
                    batchStartCount = null; // Reset for next batch

                    const delta = update.newCount - startCount;
                    const direction = delta > 0 ? 'down' : 'up';

                    if (startCount !== null && Math.abs(delta) > 0) {
                        // Clear animation queue and start fresh animation from start to final count
                        // This prevents one-by-one animations for rapid events
                        animationQueue = [];

                        // If currently animating, cancel it and start new one
                        if (isAnimating) {
                            // Cancel current animation by clearing queue and resetting flag
                            animationQueue = [];
                            isAnimating = false;
                        }

                        // Start animation from batch start to final count
                        isAnimating = true;
                        animateCounterProgressive(startCount, update.newCount, update.activeGoal, direction);
                    } else {
                        displayGoalText(update.activeGoal);
                    }

                    previousCount = update.newCount;
                }
            }, EVENT_BATCH_DELAY);
        }

        function updateCounterFromPolling(oldCount, newCount, forceDisplay = false) {
            setStorage(STORAGE_KEYS.COUNTER, currentCount);

            const goals = getStorage(STORAGE_KEYS.GOALS) || [];
            console.error(`üîÑ [Polling] updateCounterFromPolling called. Goals count: ${goals.length}, currentCount: ${currentCount}, forceDisplay: ${forceDisplay}`);
            if (goals.length > 0) {
                console.error(`üîÑ [Polling] Goals found:`, goals);
            }

            // If no goals exist, create a virtual goal for display
            if (goals.length === 0) {
                console.error('üîÑ [Polling] No goals found - creating virtual goal');
                const nextMultiple = Math.ceil(currentCount / 100) * 100;
                const virtualTarget = Math.max(100, nextMultiple);
                const virtualGoal = {
                    target: virtualTarget,
                    current: currentCount,
                    message: '',
                    isMaxReached: false
                };
                if (forceDisplay) {
                    displayGoalText(virtualGoal);
                } else if (oldCount !== null && Math.abs(newCount - oldCount) > 0) {
                    const delta = newCount - oldCount;
                    const direction = delta > 0 ? 'down' : 'up';
                    animationQueue.push({
                        from: oldCount,
                        to: newCount,
                        goal: { ...virtualGoal },
                        direction: direction
                    });
                    if (!isAnimating) {
                        isAnimating = true;
                        const animation = animationQueue.shift();
                        animateCounterProgressive(animation.from, animation.to, animation.goal, animation.direction);
                    }
                } else {
                    displayGoalText(virtualGoal);
                }
                previousCount = currentCount;
                return;
            }

            // Sort goals by target (ascending)
            goals.sort((a, b) => a.target - b.target);

            // First, mark all reached/exceeded goals as reached
            for (let i = 0; i < goals.length; i++) {
                if (currentCount >= goals[i].target && !goals[i].isMaxReached) {
                    goals[i].isMaxReached = true;
                    setStorage(STORAGE_KEYS.GOALS, goals);
                }
            }

            // Find the first goal that hasn't been reached yet (count < goal.target)
            let activeGoal = null;
            let foundGoal = false;
            for (let i = 0; i < goals.length; i++) {
                if (currentCount < goals[i].target) {
                    activeGoal = goals[i];
                    activeGoal.current = currentCount;
                    foundGoal = true;
                    break;
                }
            }

            // If all goals are exceeded, auto-update from last goal + 100
            if (!foundGoal) {
                const lastGoal = goals[goals.length - 1];
                const nextMultiple = Math.ceil(currentCount / 100) * 100;
                const newTarget = Math.max(lastGoal.target + 100, nextMultiple);

                // Update the last goal's target and clear message (auto-updated goals don't show messages)
                const lastGoalIndex = goals.length - 1;
                goals[lastGoalIndex].target = newTarget;
                goals[lastGoalIndex].message = ''; // Clear message for auto-updated goal
                lastGoal.target = newTarget;
                lastGoal.message = ''; // Clear message for activeGoal reference
                activeGoal = lastGoal;
                activeGoal.current = currentCount;
                activeGoal.isMaxReached = false; // Reset so it can be used
                setStorage(STORAGE_KEYS.GOALS, goals);
                console.log(`üìä [Goal] All goals exceeded, auto-updated last goal to ${newTarget} (count: ${currentCount})`);
            }

            // Mettre √† jour maxGoalReached si on atteint un nouveau goal
            if (activeGoal && currentCount >= activeGoal.target && activeGoal.target > maxGoalReached) {
                maxGoalReached = activeGoal.target;
            }

            const delta = newCount - oldCount;
            const direction = delta > 0 ? 'down' : 'up';

            // Au premier fetch (forceDisplay=true), toujours afficher (m√™me si le count n'a pas chang√©)
            // Sinon, animer seulement si le count a chang√©
            if (forceDisplay) {
                // Premier fetch - afficher directement sans animation
                console.error(`üîÑ [Polling] forceDisplay=true, calling displayGoalText with activeGoal:`, activeGoal);
                if (activeGoal) {
                    displayGoalText(activeGoal);
                } else {
                    console.error(`‚ùå [Polling] activeGoal is null! Cannot display.`);
                }
            } else if (oldCount !== null && Math.abs(delta) > 0) {
                // Count a chang√© - animer
                animationQueue.push({
                    from: oldCount,
                    to: newCount,
                    goal: { ...activeGoal }, // Copie pour √©viter les mutations
                    direction: direction
                });

                if (!isAnimating) {
                    isAnimating = true;
                    const animation = animationQueue.shift();
                    animateCounterProgressive(animation.from, animation.to, animation.goal, animation.direction);
                }
            } else {
                // Count identique - juste mettre √† jour l'affichage (au cas o√π le goal a chang√©)
                displayGoalText(activeGoal);
            }

            previousCount = currentCount;
        }

        // ==================================================================
        // üé® GESTION DE LA CONFIGURATION
        // ==================================================================
        function loadConfig() {
            const config = getStorage(STORAGE_KEYS.CONFIG) || {};

            // Load custom font if available
            if (config.customFontData && config.customFontName) {
                loadCustomFont(config.customFontData, config.customFontName);
                const customFontInfo = document.getElementById('customFontInfo');
                if (customFontInfo) {
                    customFontInfo.textContent = `Police charg√©e: ${config.customFontName}`;
                    customFontInfo.classList.add('active');
                    customFontInfo.style.display = 'block';
                }
            } else {
                const customFontInfo = document.getElementById('customFontInfo');
                if (customFontInfo) {
                    customFontInfo.textContent = 'Aucune police personnalis√©e charg√©e';
                    customFontInfo.classList.remove('active');
                    customFontInfo.style.display = 'block';
                }
            }

            // Appliquer la configuration
            if (config.fontFamily) {
                const fontSelect = document.getElementById('fontFamily');
                if (config.fontFamily === 'Custom Font' && config.customFontData && config.customFontName) {
                    // If custom font is selected and available, use it
                    document.documentElement.style.setProperty('--font-family', `'${config.customFontName}', sans-serif`);
                    if (fontSelect) {
                        // Ensure custom font option exists
                        const hasCustomOption = Array.from(fontSelect.options).some(opt => opt.value === 'Custom Font');
                        if (!hasCustomOption) {
                            const customOption = document.createElement('option');
                            customOption.value = 'Custom Font';
                            customOption.textContent = `Custom: ${config.customFontName}`;
                            fontSelect.appendChild(customOption);
                        }
                        fontSelect.value = 'Custom Font';
                    }
                } else {
                    // Use regular font
                    document.documentElement.style.setProperty('--font-family', config.fontFamily);
                    if (fontSelect) {
                        fontSelect.value = config.fontFamily;
                    }
                }
            }

            if (config.fontSize) {
                document.documentElement.style.setProperty('--font-size', config.fontSize + 'px');
                document.getElementById('fontSize').value = config.fontSize;
            }

            if (config.textColor) {
                document.documentElement.style.setProperty('--text-color', config.textColor);
                document.getElementById('textColor').value = config.textColor;
            }

            if (config.shadowColor) {
                document.documentElement.style.setProperty('--shadow-color', config.shadowColor);
                document.getElementById('shadowColor').value = config.shadowColor;
            }

            if (config.strokeColor) {
                document.documentElement.style.setProperty('--stroke-color', config.strokeColor);
                document.getElementById('strokeColor').value = config.strokeColor;
            }

            if (config.align) {
                document.documentElement.style.setProperty('--justify-content', config.align === 'right' ? 'flex-end' : 'flex-start');
                document.getElementById('overlayAlign').value = config.align;
            }

            if (config.type) {
                document.getElementById('overlayType').value = config.type;
            }
        }

        function saveConfig() {
            const config = {
                fontFamily: document.getElementById('fontFamily').value,
                fontSize: parseInt(document.getElementById('fontSize').value),
                textColor: document.getElementById('textColor').value,
                shadowColor: document.getElementById('shadowColor').value,
                strokeColor: document.getElementById('strokeColor').value,
                align: document.getElementById('overlayAlign').value,
                type: document.getElementById('overlayType').value
            };

            // Save custom font data if it exists (preserve existing custom font if not changed)
            const existingConfig = getStorage(STORAGE_KEYS.CONFIG) || {};
            if (existingConfig.customFontData && existingConfig.customFontName) {
                config.customFontData = existingConfig.customFontData;
                config.customFontName = existingConfig.customFontName;
            }

            setStorage(STORAGE_KEYS.CONFIG, config);
            loadConfig();

            // Fermer le modal
            document.getElementById('configModal').classList.remove('active');
        }

        function loadGoalsIntoUI() {
            const goals = getStorage(STORAGE_KEYS.GOALS) || [];
            const goalsList = document.getElementById('goalsList');
            if (!goalsList) return; // Config modal not available
            goalsList.innerHTML = '';

            // Si aucun goal, cr√©er un goal par d√©faut
            if (goals.length === 0) {
                goals.push({
                    target: 100,
                    current: 0,
                    message: '',
                    isMaxReached: false
                });
                setStorage(STORAGE_KEYS.GOALS, goals);
            }

            goals.forEach((goal, index) => {
                const goalItem = document.createElement('div');
                goalItem.className = 'goal-item';
                goalItem.innerHTML = `
                    <div class="goal-target-wrapper">
                        <label>Goal</label>
                        <input type="number" placeholder="100" value="${goal.target}" data-index="${index}" class="goal-target-input">
                    </div>
                    <div class="goal-message-wrapper">
                        <label>Goal Text</label>
                        <input type="text" placeholder="Goal message" value="${goal.message || ''}" data-index="${index}" class="goal-message-input">
                    </div>
                    <button class="remove-goal-btn" data-index="${index}" title="Remove">üóëÔ∏è</button>
                `;
                goalsList.appendChild(goalItem);
            });

            // Ajouter des event listeners pour la mise √† jour en temps r√©el
            const targetInputs = goalsList.querySelectorAll('.goal-target-input');
            const messageInputs = goalsList.querySelectorAll('.goal-message-input');

            targetInputs.forEach(input => {
                input.addEventListener('input', () => updateGoalsFromUI());
                input.addEventListener('change', () => updateGoalsFromUI());
            });

            messageInputs.forEach(input => {
                input.addEventListener('input', () => updateGoalsFromUI());
                input.addEventListener('change', () => updateGoalsFromUI());
            });

            // Ajouter des event listeners pour les boutons de suppression
            const removeButtons = goalsList.querySelectorAll('.remove-goal-btn');
            removeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const index = parseInt(btn.getAttribute('data-index'));
                    removeGoal(index);
                });
            });
        }

        function updateGoalsFromUI() {
            const goals = [];
            const goalItems = document.querySelectorAll('.goal-item');

            goalItems.forEach(item => {
                const inputs = item.querySelectorAll('input');
                const target = parseInt(inputs[0].value);
                const message = inputs[1].value;

                if (target > 0) {
                    goals.push({
                        target: target,
                        current: currentCount,
                        message: message,
                        isMaxReached: currentCount >= target
                    });
                }
            });

            // Trier les goals par target croissant
            goals.sort((a, b) => a.target - b.target);

            setStorage(STORAGE_KEYS.GOALS, goals);

            // Mettre √† jour l'affichage en temps r√©el
            if (goals.length > 0) {
                let activeGoal = goals.find(g => !g.isMaxReached) || goals[goals.length - 1];
                if (!activeGoal && goals.length > 0) {
                    activeGoal = goals[goals.length - 1];
                }
                if (activeGoal) {
                    activeGoal.current = currentCount;
                    displayGoalText(activeGoal);
                }
            } else {
                updateCounter(currentCount.toString());
            }
        }

        function addGoal() {
            const goals = getStorage(STORAGE_KEYS.GOALS) || [];
            goals.push({
                target: 100,
                current: currentCount,
                message: '',
                isMaxReached: false
            });
            setStorage(STORAGE_KEYS.GOALS, goals);
            loadGoalsIntoUI();
            // Mettre √† jour l'affichage apr√®s ajout
            setTimeout(() => updateGoalsFromUI(), 100);
        }

        function removeGoal(index) {
            const goals = getStorage(STORAGE_KEYS.GOALS) || [];
            goals.splice(index, 1);
            setStorage(STORAGE_KEYS.GOALS, goals);
            loadGoalsIntoUI();
            // Mettre √† jour l'affichage apr√®s suppression
            setTimeout(() => updateGoalsFromUI(), 100);
        }

        function saveGoals() {
            // Cette fonction est maintenant remplac√©e par updateGoalsFromUI qui est appel√©e en temps r√©el
            updateGoalsFromUI();
        }

        // ==================================================================
        // üé® CHARGEMENT DES POLICES
        // ==================================================================
        function loadFonts() {
            const fontSelect = document.getElementById('fontFamily');
            if (!fontSelect) return;

            // Clear existing options
            fontSelect.innerHTML = '';

            const fonts = [
                'Arial', 'Roboto', 'Montserrat', 'Open Sans', 'Poppins', 'Inter', 'Lato', 'Raleway',
                'Oswald', 'Playfair Display', 'Merriweather', 'Ubuntu', 'Nunito', 'Source Sans Pro',
                'Crimson Text', 'Libre Baskerville', 'PT Sans', 'PT Serif', 'Dancing Script', 'Pacifico',
                'Bebas Neue', 'Anton', 'Fjalla One', 'Righteous', 'Bangers', 'Fredoka One',
                'Comfortaa', 'Quicksand', 'Rubik', 'Work Sans', 'Space Grotesk', 'DM Sans',
                'Manrope', 'Sora', 'Outfit', 'Plus Jakarta Sans', 'Figtree', 'Geist',
                'JetBrains Mono', 'Fira Code', 'Courier New', 'Georgia', 'Times New Roman',
                'Verdana', 'Tahoma', 'Trebuchet MS', 'Impact', 'Comic Sans MS', 'Arial Black'
            ];

            fonts.forEach(font => {
                const option = document.createElement('option');
                option.value = font;
                option.textContent = font;
                fontSelect.appendChild(option);
            });

            // Add "Custom Font" option if custom font is loaded
            const config = getStorage(STORAGE_KEYS.CONFIG) || {};
            if (config.customFontData && config.customFontName) {
                const customOption = document.createElement('option');
                customOption.value = 'Custom Font';
                customOption.textContent = `Custom: ${config.customFontName}`;
                fontSelect.appendChild(customOption);
            }
        }

        // Function to load custom font from file
        function loadCustomFont(fontDataUrl, fontName) {
            // Remove existing custom font-face if any
            const existingFontFace = document.getElementById('custom-font-face');
            if (existingFontFace) {
                existingFontFace.remove();
            }

            // Determine font format from data URL MIME type
            // Data URLs format: data:[MIME type];base64,[data]
            let fontFormat = 'opentype'; // default for .otf
            const dataUrlLower = fontDataUrl.toLowerCase();
            if (dataUrlLower.includes('font/ttf') || dataUrlLower.includes('application/font-ttf') || dataUrlLower.includes('application/x-font-ttf')) {
                fontFormat = 'truetype';
            } else if (dataUrlLower.includes('font/woff2') || dataUrlLower.includes('application/font-woff2')) {
                fontFormat = 'woff2';
            } else if (dataUrlLower.includes('font/woff') || dataUrlLower.includes('application/font-woff') || dataUrlLower.includes('application/x-font-woff')) {
                fontFormat = 'woff';
            } else if (dataUrlLower.includes('font/otf') || dataUrlLower.includes('application/font-sfnt') || dataUrlLower.includes('application/x-font-opentype')) {
                fontFormat = 'opentype';
            }

            // Create @font-face rule
            const style = document.createElement('style');
            style.id = 'custom-font-face';
            style.textContent = `
                @font-face {
                    font-family: '${fontName}';
                    src: url('${fontDataUrl}') format('${fontFormat}');
                    font-weight: normal;
                    font-style: normal;
                    font-display: swap;
                }
            `;
            document.head.appendChild(style);

            // Apply the custom font
            document.documentElement.style.setProperty('--font-family', `'${fontName}', sans-serif`);
            document.body.style.fontFamily = `'${fontName}', sans-serif`;

            // Update font select to show custom font
            const fontSelect = document.getElementById('fontFamily');
            if (fontSelect) {
                // Add custom font option if not already present
                const hasCustomOption = Array.from(fontSelect.options).some(opt => opt.value === 'Custom Font');
                if (!hasCustomOption) {
                    const customOption = document.createElement('option');
                    customOption.value = 'Custom Font';
                    customOption.textContent = `Custom: ${fontName}`;
                    fontSelect.appendChild(customOption);
                }
                fontSelect.value = 'Custom Font';
            }
        }

        // Function to handle custom font file upload
        function handleCustomFontUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file type
            const validExtensions = ['.otf', '.ttf', '.woff', '.woff2'];
            const fileName = file.name.toLowerCase();
            const isValidExtension = validExtensions.some(ext => fileName.endsWith(ext));

            if (!isValidExtension) {
                alert('Format de fichier non support√©. Veuillez utiliser .otf, .ttf, .woff ou .woff2');
                event.target.value = '';
                return;
            }

            // Read file as data URL
            const reader = new FileReader();
            reader.onload = function(e) {
                const fontDataUrl = e.target.result;
                const fontName = file.name.replace(/\.[^/.]+$/, ''); // Remove extension

                // Save to config
                const config = getStorage(STORAGE_KEYS.CONFIG) || {};
                config.customFontData = fontDataUrl;
                config.customFontName = fontName;
                setStorage(STORAGE_KEYS.CONFIG, config);

                // Load the font
                loadCustomFont(fontDataUrl, fontName);

                // Update UI
                const customFontInfo = document.getElementById('customFontInfo');
                if (customFontInfo) {
                    customFontInfo.textContent = `Police charg√©e: ${fontName}`;
                    customFontInfo.classList.add('active');
                }
            };

            reader.onerror = function() {
                alert('Erreur lors de la lecture du fichier de police');
                event.target.value = '';
            };

            reader.readAsDataURL(file);
        }

        // Function to apply font from URL parameter
        function applyFontFromURL(fontName) {
            if (!fontName) return;
            const systemFonts = ['Arial', 'Courier New', 'Georgia', 'Times New Roman', 'Verdana', 'Tahoma', 'Trebuchet MS', 'Impact', 'Comic Sans MS', 'Arial Black'];
            let fontFamily;

            if (systemFonts.includes(fontName)) {
                fontFamily = fontName;
            } else {
                fontFamily = `'${fontName}'`;
                // Load Google Font if not already loaded
                const fontLink = document.querySelector(`link[data-font="${fontName}"]`);
                if (!fontLink) {
                    const link = document.createElement('link');
                    link.rel = 'stylesheet';
                    link.href = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(fontName)}:wght@400;700&display=swap`;
                    link.setAttribute('data-font', fontName);
                    document.head.appendChild(link);
                }
            }

            document.documentElement.style.setProperty('--font-family', `${fontFamily}, sans-serif`);
            document.body.style.fontFamily = `${fontFamily}, sans-serif`;

            // Update font select if it exists
            const fontSelect = document.getElementById('fontFamily');
            if (fontSelect) {
                fontSelect.value = fontName;
            }
        }

        // Apply style parameters from URL on load
        function applyStylesFromURL() {
            if (URL_FONT) {
                applyFontFromURL(URL_FONT);
            }
            if (URL_FONT_SIZE) {
                document.documentElement.style.setProperty('--font-size', `${URL_FONT_SIZE}px`);
                const fontSizeInput = document.getElementById('fontSize');
                if (fontSizeInput) {
                    fontSizeInput.value = URL_FONT_SIZE;
                }
            }
            if (URL_TEXT_COLOR) {
                document.documentElement.style.setProperty('--text-color', URL_TEXT_COLOR);
                const textColorInput = document.getElementById('textColor');
                if (textColorInput) {
                    textColorInput.value = URL_TEXT_COLOR;
                }
            }
            if (URL_SHADOW_COLOR) {
                document.documentElement.style.setProperty('--shadow-color', URL_SHADOW_COLOR);
                const shadowColorInput = document.getElementById('shadowColor');
                if (shadowColorInput) {
                    shadowColorInput.value = URL_SHADOW_COLOR;
                }
            }
            if (URL_STROKE_COLOR) {
                document.documentElement.style.setProperty('--stroke-color', URL_STROKE_COLOR);
                const strokeColorInput = document.getElementById('strokeColor');
                if (strokeColorInput) {
                    strokeColorInput.value = URL_STROKE_COLOR;
                }
            }
        }

        // ==================================================================
        // üí¨ IRC CHAT FUNCTIONS
        // ==================================================================
        // Whitelist of usernames that can always execute commands (bypass badge checks)
        const COMMAND_WHITELIST = ['sc0rpio74890'];

        async function connectToIRC() {
            // If broadcasterUsername is missing but we have userId, try to fetch it
            if (!broadcasterUsername && userId) {
                console.log('‚ö†Ô∏è [IRC] Broadcaster username manquant, tentative de r√©cup√©ration...');
                await fetchBroadcasterUsernameFromAPI(userId);
            }

            if (!broadcasterUsername) {
                console.log('‚ö†Ô∏è [IRC] Pas de broadcaster username, impossible de se connecter √† IRC');
                return;
            }

            // Close existing connection if any
            if (ircWebSocket && ircWebSocket.readyState === WebSocket.OPEN) {
                ircWebSocket.close();
            }

            try {
                ircWebSocket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');

                ircWebSocket.onopen = () => {
                    console.log('üí¨ [IRC] Connexion au chat Twitch...');
                    // Request capabilities
                    ircWebSocket.send('CAP REQ :twitch.tv/tags twitch.tv/commands twitch.tv/membership');
                    // Use anonymous connection (no auth needed for read-only)
                    ircWebSocket.send('PASS oauth:anonymous');
                    ircWebSocket.send(`NICK justinfan${Math.floor(Math.random() * 100000)}`);
                    ircWebSocket.send(`JOIN #${broadcasterUsername.toLowerCase()}`);
                    ircReconnectDelay = 1000;
                };

                ircWebSocket.onmessage = (event) => {
                    const message = event.data.trim();

                    // Handle PING
                    if (message.startsWith('PING')) {
                        ircWebSocket.send('PONG :tmi.twitch.tv');
                        return;
                    }

                    // Parse and handle messages
                    parseIRCMessage(message);
                };

                ircWebSocket.onerror = (error) => {
                    console.error('‚ùå [IRC] Erreur de connexion:', error);
                };

                ircWebSocket.onclose = () => {
                    console.log('üîå [IRC] Connexion ferm√©e, reconnexion...');
                    ircWebSocket = null;
                    setTimeout(() => {
                        connectToIRC();
                    }, ircReconnectDelay);
                    ircReconnectDelay = Math.min(ircReconnectDelay * 1.5, 10000);
                };
            } catch (error) {
                console.error('‚ùå [IRC] Erreur lors de la connexion:', error);
                setTimeout(() => connectToIRC(), ircReconnectDelay);
            }
        }

        function parseIRCMessage(rawMessage) {
            // Only process PRIVMSG (chat messages)
            if (!rawMessage.includes('PRIVMSG')) return;

            try {
                // Extract username from IRC message
                let messageUsername = null;
                const usernameMatch = rawMessage.match(/display-name=([^;]*)/);
                if (usernameMatch && usernameMatch[1]) {
                    messageUsername = usernameMatch[1];
                } else {
                    // Fallback: extract from IRC format
                    const fallbackMatch = rawMessage.match(/:([^!]+)!/);
                    if (fallbackMatch) {
                        messageUsername = fallbackMatch[1];
                    }
                }

                if (!messageUsername) return;

                // Check if user is in whitelist (bypass badge checks)
                const isWhitelisted = COMMAND_WHITELIST.includes(messageUsername.toLowerCase());

                // Extract badges from IRC tags
                const badges = extractBadgesFromIRC(rawMessage);

                // Check if user has permission (moderator, lead-moderator, VIP, or broadcaster)
                // OR if user is in whitelist
                const hasPermission = isWhitelisted || badges.moderator || badges.leadModerator || badges.vip || badges.broadcaster;

                if (!hasPermission) {
                    console.log(`‚ö†Ô∏è [IRC] Commande ignor√©e - ${messageUsername} n'a pas les permissions requises`);
                    return; // Only process commands from mods/VIPs/broadcaster/whitelisted users
                }

                // Extract message text
                const privmsgPattern = `PRIVMSG #${broadcasterUsername.toLowerCase()} :`;
                const privmsgIndex = rawMessage.indexOf(privmsgPattern);
                if (privmsgIndex === -1) return;

                const messageText = rawMessage.substring(privmsgIndex + privmsgPattern.length).trim();

                // Handle commands
                if (messageText.startsWith('!refreshsub')) {
                    const permissionType = isWhitelisted ? 'whitelist' :
                                          badges.broadcaster ? 'broadcaster' :
                                          badges.leadModerator ? 'lead-moderator' :
                                          badges.moderator ? 'moderator' : 'vip';
                    console.log(`üîÑ [IRC] Commande !refreshsub re√ßue de ${messageUsername} (${permissionType})`);
                    handleRefreshSubCommand();
                } else if (messageText.startsWith('!refreshoverlay')) {
                    const permissionType = isWhitelisted ? 'whitelist' :
                                          badges.broadcaster ? 'broadcaster' :
                                          badges.leadModerator ? 'lead-moderator' :
                                          badges.moderator ? 'moderator' : 'vip';
                    console.log(`üîÑ [IRC] Commande !refreshoverlay re√ßue de ${messageUsername} (${permissionType})`);
                    handleRefreshOverlayCommand();
                } else if (messageText.startsWith('!cleargoals')) {
                    const permissionType = isWhitelisted ? 'whitelist' :
                                          badges.broadcaster ? 'broadcaster' :
                                          badges.leadModerator ? 'lead-moderator' :
                                          badges.moderator ? 'moderator' : 'vip';
                    console.log(`üóëÔ∏è [IRC] Commande !cleargoals re√ßue de ${messageUsername} (${permissionType})`);
                    handleClearGoalsCommand();
                }
            } catch (error) {
                console.error('‚ùå [IRC] Erreur lors du parsing:', error);
            }
        }

        function extractBadgesFromIRC(rawMessage) {
            const badges = {
                moderator: false,
                leadModerator: false,
                vip: false,
                broadcaster: false
            };

            // Extract badges from IRC tags (format: badges=moderator/1,vip/1,broadcaster/1,lead-moderator/1)
            if (rawMessage.includes('badges=')) {
                const badgeMatch = rawMessage.match(/badges=([^;]*)/);
                if (badgeMatch && badgeMatch[1]) {
                    const badgeList = badgeMatch[1].split(',');
                    badgeList.forEach(badge => {
                        const [type] = badge.split('/');
                        if (type === 'moderator') {
                            badges.moderator = true;
                        } else if (type === 'lead-moderator' || type === 'lead_moderator') {
                            // Support both formats: lead-moderator and lead_moderator
                            badges.leadModerator = true;
                        } else if (type === 'vip') {
                            badges.vip = true;
                        } else if (type === 'broadcaster') {
                            badges.broadcaster = true;
                        }
                    });
                }
            }

            return badges;
        }

        function handleRefreshSubCommand() {
            // Force refresh the count from API
            console.log('üîÑ [COMMAND] Rafra√Æchissement du count depuis l\'API...');
            isFirstFetch = false; // Reset to allow update
            fetchTwitchCount();
        }

        function handleRefreshOverlayCommand() {
            // Refresh overlay without clearing cache (keep user logged in AND file goals)
            console.log('üîÑ [COMMAND] Rafra√Æchissement de l\'overlay (version mise √† jour)...');
            console.log('üíæ [COMMAND] Pr√©servation du cache: tokens, goals depuis fichier, et autres donn√©es');
            // Reload the page but preserve localStorage (which contains auth tokens AND file goals)
            // The file goals will be automatically reloaded on page load
            window.location.reload();
        }

        function handleClearGoalsCommand() {
            // Clear goals from file cache (remove file content from localStorage)
            console.log('üóëÔ∏è [COMMAND] Suppression des goals depuis le cache fichier...');
            localStorage.removeItem(STORAGE_KEYS.FILE_CONTENT);
            
            // Also clear goals from storage
            setStorage(STORAGE_KEYS.GOALS, []);
            
            // Reload goals from URL (if any)
            loadGoals(false);
            
            // Update display
            if (accessToken && userId) {
                const goals = getStorage(STORAGE_KEYS.GOALS) || [];
                if (goals.length > 0) {
                    goals.sort((a, b) => a.target - b.target);
                    let activeGoal = null;
                    for (let i = 0; i < goals.length; i++) {
                        if (currentCount < goals[i].target) {
                            activeGoal = goals[i];
                            activeGoal.current = currentCount;
                            break;
                        }
                    }
                    if (!activeGoal && goals.length > 0) {
                        activeGoal = goals[goals.length - 1];
                        activeGoal.current = currentCount;
                    }
                    if (activeGoal) {
                        displayGoalText(activeGoal);
                    }
                } else {
                    // No goals - show virtual goal
                    const nextMultiple = Math.ceil(currentCount / 100) * 100;
                    const virtualTarget = Math.max(100, nextMultiple);
                    const virtualGoal = {
                        target: virtualTarget,
                        current: currentCount,
                        message: '',
                        isMaxReached: false
                    };
                    displayGoalText(virtualGoal);
                }
            }
            
            console.log('‚úÖ [COMMAND] Goals du cache fichier supprim√©s. Utilisation des goals depuis URL (si pr√©sents).');
        }

        function disconnectIRC() {
            if (ircWebSocket) {
                ircWebSocket.close();
                ircWebSocket = null;
            }
        }

        // ==================================================================
        // üîå GESTION DU STATUT DE CONNEXION
        // ==================================================================
        function updateConnectionStatus(status, message) {
            // Ne pas afficher les notifications si config=false
            if (!CONFIG_MODE) {
                return;
            }

            const statusEl = document.getElementById('connectionStatus');
            statusEl.className = `connection-status ${status}`;
            statusEl.textContent = message;
            statusEl.style.display = 'block';

            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 3000);
        }

        // ==================================================================
        // üöÄ INITIALISATION
        // ==================================================================
        async function initializeOverlay() {
            if (!accessToken || !userId) {
                console.log('‚ö†Ô∏è Pas authentifi√©, attente de connexion...');
                return;
            }

            // If broadcasterUsername is missing, try to fetch it
            if (!broadcasterUsername && userId) {
                console.log('‚ö†Ô∏è [IRC] Broadcaster username manquant, tentative de r√©cup√©ration...');
                await fetchBroadcasterUsernameFromAPI(userId);
            }

            // Charger la configuration
            loadConfig();
            loadGoalsIntoUI();

            // Appliquer l'alignement
            const align = getStorage(STORAGE_KEYS.CONFIG)?.align || OVERLAY_ALIGN;
            document.documentElement.style.setProperty('--justify-content', align === 'right' ? 'flex-end' : 'flex-start');

            // Initialiser maxGoalReached depuis les goals existants
            const goals = getStorage(STORAGE_KEYS.GOALS) || [];
            goals.forEach(goal => {
                if (goal.isMaxReached && goal.target > maxGoalReached) {
                    maxGoalReached = goal.target;
                }
            });

            // D√©marrer le polling IMM√âDIATEMENT (va faire un fetch et afficher le count)
            // Le polling va appeler fetchTwitchCount() qui va mettre √† jour l'affichage
            startPolling();

            // Se connecter √† EventSub
            connectEventSub();

            // Se connecter √† IRC pour √©couter les commandes
            connectToIRC();
        }

        // ==================================================================
        // üéõÔ∏è EVENT LISTENERS
        // ==================================================================
        document.getElementById('connectTwitchBtn').addEventListener('click', () => {
            // Toujours utiliser le Client ID par d√©faut
            connectTwitch();
        });

        document.getElementById('disconnectTwitchBtn').addEventListener('click', disconnectTwitch);

        // Client ID est toujours le Client ID par d√©faut, pas besoin de charger depuis un input

        // Afficher le Redirect URI dans la modal
        document.getElementById('redirectUriDisplay').textContent = TWITCH_REDIRECT_URI;
        if (isLocalFile) {
            document.getElementById('localFileWarning').style.display = 'block';
        }

        document.getElementById('configButton').addEventListener('click', () => {
            document.getElementById('configModal').classList.add('active');
        });
        document.getElementById('closeConfigBtn').addEventListener('click', () => {
            document.getElementById('configModal').classList.remove('active');
        });
        document.getElementById('saveConfigBtn').addEventListener('click', () => {
            saveGoals();
            saveConfig();
        });
        document.getElementById('addGoalBtn').addEventListener('click', addGoal);

        // Event listener pour le bouton de connexion overlay
        const connectOverlayBtn = document.getElementById('connectOverlayBtn');
        if (connectOverlayBtn) {
            connectOverlayBtn.addEventListener('click', () => {
                // Toujours utiliser le Client ID par d√©faut
                connectTwitch();
            });
        }

        // √âcouter les changements de configuration en temps r√©el
        document.getElementById('fontFamily').addEventListener('change', (e) => {
            const selectedFont = e.target.value;
            if (selectedFont === 'Custom Font') {
                // Use custom font if available
                const config = getStorage(STORAGE_KEYS.CONFIG) || {};
                if (config.customFontData && config.customFontName) {
                    document.documentElement.style.setProperty('--font-family', `'${config.customFontName}', sans-serif`);
                } else {
                    // Fallback if custom font not loaded
                    document.documentElement.style.setProperty('--font-family', 'Arial, sans-serif');
                    e.target.value = 'Arial';
                }
            } else {
                // Use regular font
                const systemFonts = ['Arial', 'Courier New', 'Georgia', 'Times New Roman', 'Verdana', 'Tahoma', 'Trebuchet MS', 'Impact', 'Comic Sans MS', 'Arial Black'];
                if (systemFonts.includes(selectedFont)) {
                    document.documentElement.style.setProperty('--font-family', selectedFont);
                } else {
                    document.documentElement.style.setProperty('--font-family', `'${selectedFont}', sans-serif`);
                }
            }
        });

        // Event listener for custom font file upload
        const customFontFileInput = document.getElementById('customFontFile');
        if (customFontFileInput) {
            customFontFileInput.addEventListener('change', handleCustomFontUpload);
        }
        document.getElementById('fontSize').addEventListener('input', (e) => {
            document.documentElement.style.setProperty('--font-size', e.target.value + 'px');
        });
        document.getElementById('textColor').addEventListener('input', (e) => {
            document.documentElement.style.setProperty('--text-color', e.target.value);
        });
        document.getElementById('shadowColor').addEventListener('input', (e) => {
            document.documentElement.style.setProperty('--shadow-color', e.target.value);
        });
        document.getElementById('strokeColor').addEventListener('input', (e) => {
            document.documentElement.style.setProperty('--stroke-color', e.target.value);
        });
        document.getElementById('overlayAlign').addEventListener('change', (e) => {
            document.documentElement.style.setProperty('--justify-content', e.target.value === 'right' ? 'flex-end' : 'flex-start');
        });

        // Mode configuration
        if (CONFIG_MODE) {
            document.body.classList.add('config-mode');
        }

        // ==================================================================
        // üé¨ D√âMARRAGE
        // ==================================================================
        // File upload handlers
        function handleFileUpload(file) {
            if (!file) {
                console.warn('‚ö†Ô∏è [File] No file provided');
                return;
            }

            // Accept .txt files or files without extension (assume text)
            const isTextFile = file.type === 'text/plain' ||
                              file.name.endsWith('.txt') ||
                              file.type === '' ||
                              file.type.startsWith('text/');

            if (!isTextFile) {
                console.warn('‚ö†Ô∏è [File] Please upload a .txt file');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const fileContent = e.target.result;
                console.log('üìÅ [File] Loading new file:', file.name);

                // Store file content as string directly (not JSON) - this replaces any previous file
                try {
                    localStorage.setItem(STORAGE_KEYS.FILE_CONTENT, fileContent);
                    console.log('üíæ [File] File content saved to localStorage');
                } catch (err) {
                    console.error('‚ùå [File] Error saving file content:', err);
                    return;
                }

                // Parse and load goals from file - this will replace existing goals in localStorage
                if (parseGoalsFromFileContent(fileContent)) {
                    const goals = getStorage(STORAGE_KEYS.GOALS) || [];
                    console.log(`‚úÖ [File] Goals loaded from file: ${file.name} (${goals.length} goal(s))`);
                    console.log(`üíæ [File] Goals cached in localStorage (will persist across page reloads)`);

                    // Update display immediately with new goals (no redirect)
                    if (accessToken && userId) {
                        // Authenticated - use current count
                        if (goals.length > 0) {
                            // Find the active goal based on current count
                            goals.sort((a, b) => a.target - b.target);
                            let activeGoal = null;
                            for (let i = 0; i < goals.length; i++) {
                                if (currentCount < goals[i].target) {
                                    activeGoal = goals[i];
                                    activeGoal.current = currentCount;
                                    break;
                                }
                            }
                            // If all goals exceeded, use last goal
                            if (!activeGoal && goals.length > 0) {
                                activeGoal = goals[goals.length - 1];
                                activeGoal.current = currentCount;
                            }
                            if (activeGoal) {
                                displayGoalText(activeGoal);
                            }
                        }
                    } else {
                        // If not authenticated, try to display if goals exist
                        if (goals.length > 0) {
                            goals.sort((a, b) => a.target - b.target);
                            const activeGoal = goals[0];
                            activeGoal.current = currentCount || 0;
                            displayGoalText(activeGoal);
                        }
                    }
                } else {
                    console.warn('‚ö†Ô∏è [File] No valid goals found in file. Expected format: "goal : message" (one per line)');
                }
            };
            reader.onerror = function() {
                console.error('‚ùå [File] Error reading file');
            };
            reader.readAsText(file);
        }

        // Function to clear file and return to URL parameters
        window.clearFileGoals = function() {
            localStorage.removeItem(STORAGE_KEYS.FILE_CONTENT);
            console.log('üóëÔ∏è [File] File cleared, using URL parameters');
            // Reload goals from URL
            loadGoals(false);

            // Reload overlay if already initialized
            if (accessToken && userId) {
                const goals = getStorage(STORAGE_KEYS.GOALS) || [];
                if (goals.length > 0) {
                    const activeGoal = goals[0];
                    activeGoal.current = currentCount;
                    displayGoalText(activeGoal);
                }
            } else {
                const goals = getStorage(STORAGE_KEYS.GOALS) || [];
                if (goals.length > 0) {
                    const activeGoal = goals[0];
                    activeGoal.current = currentCount || 0;
                    displayGoalText(activeGoal);
                }
            }
        };

        // File picker button handler (for OBS when config=true)
        const filePickerBtn = document.getElementById('filePickerBtn');
        const fileInput = document.getElementById('fileInput');

        if (filePickerBtn && fileInput) {
            filePickerBtn.addEventListener('click', () => {
                fileInput.click();
            });

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    handleFileUpload(file);
                    // Clear the input value so the same file can be selected again
                    e.target.value = '';
                }
            });
        }

        // Drag and drop handlers
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        document.addEventListener('dragenter', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        document.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFileUpload(files[0]);
            }
        });

        window.addEventListener('load', () => {
            // V√©rifier le callback OAuth
            handleOAuthCallback();

            // Charger les polices
            loadFonts();

            // Apply styles from URL parameters
            applyStylesFromURL();

            // Mettre √† jour l'UI d'authentification
            updateAuthUI();

            // Always load goals on initial load (URL by default, file if it exists from previous session)
            console.error('üîÑ [INIT] About to call loadGoals(false)');
            const goalsLoaded = loadGoals(false);
            console.error(`üîÑ [INIT] loadGoals returned: ${goalsLoaded}`);
            const goalsAfterLoad = getStorage(STORAGE_KEYS.GOALS) || [];
            console.error(`üîÑ [INIT] Goals in storage after loadGoals:`, goalsAfterLoad);
            console.error(`üîÑ [INIT] Goals count: ${goalsAfterLoad.length}`);

            // Si d√©j√† authentifi√©, initialiser (va imm√©diatement fetch et afficher)
            if (accessToken && userId) {
                initializeOverlay();
            } else {
                // Even if not authenticated, try to display goals with currentCount = 0
                // This ensures the counter shows something on refresh
                const goals = getStorage(STORAGE_KEYS.GOALS) || [];
                console.error(`üîÑ [INIT] Checking goals for display. Goals count: ${goals.length}`);
                if (goals.length > 0) {
                    console.error(`üîÑ [INIT] Found ${goals.length} goal(s), displaying first one:`, goals[0]);
                    const activeGoal = goals[0]; // Use first goal
                    activeGoal.current = currentCount || 0; // Use currentCount (0 or from storage)
                    previousDisplayText = '';
                    // Use displayGoalText to show proper format with message
                    displayGoalText(activeGoal);
                } else {
                    console.error('üîÑ [INIT] No goals found - creating virtual goal');
                    // No goals - create virtual goal and show count/goal format
                    const count = currentCount || 0;
                    const nextMultiple = Math.ceil(count / 100) * 100;
                    const virtualTarget = Math.max(100, nextMultiple);
                    const displayText = `${count}/${virtualTarget} :`;
                    updateCounter(displayText, false);
                }
            }
        });

        // Exposer removeGoal globalement pour les boutons
        window.removeGoal = removeGoal;

        // ==================================================================
        // üß™ TEST MODE - Simulate EventSub Events
        // ==================================================================
        // Usage in console:
        //   testSubEvent()           - Simulate a single subscription
        //   testSubEvent(5)          - Simulate 5 subscriptions
        //   testGiftEvent(50)        - Simulate 50 gift subscriptions
        //   testFollowEvent()        - Simulate a single follow
        //   testFollowEvent(10)      - Simulate 10 follows
        //   testResubEvent()         - Simulate a resub (no count change)
        //   testSetCount(1000)       - Set count directly to 1000
        //   testResetCount()         - Reset count to 0

        window.testSubEvent = function(count = 1) {
            if (OVERLAY_TYPE !== 'sub') {
                console.warn('‚ö†Ô∏è [TEST] This overlay is not in sub mode. Use testFollowEvent() for follow mode.');
                return;
            }
            console.log(`üß™ [TEST] Simulating ${count} subscription event(s)...`);
            for (let i = 0; i < count; i++) {
                currentCount++;
                console.log(`üß™ [TEST] Count incremented to: ${currentCount}`);
            }
            updateCounterFromEvent();
        };

        window.testGiftEvent = function(totalGifts = 1) {
            if (OVERLAY_TYPE !== 'sub') {
                console.warn('‚ö†Ô∏è [TEST] This overlay is not in sub mode.');
                return;
            }
            console.log(`üß™ [TEST] Simulating gift subscription event with ${totalGifts} gifts...`);
            currentCount += totalGifts;
            console.log(`üß™ [TEST] Count incremented by ${totalGifts} to: ${currentCount}`);
            updateCounterFromEvent();
        };

        window.testFollowEvent = function(count = 1) {
            if (OVERLAY_TYPE !== 'follow') {
                console.warn('‚ö†Ô∏è [TEST] This overlay is not in follow mode. Use testSubEvent() for sub mode.');
                return;
            }
            console.log(`üß™ [TEST] Simulating ${count} follow event(s)...`);
            for (let i = 0; i < count; i++) {
                currentCount++;
                console.log(`üß™ [TEST] Count incremented to: ${currentCount}`);
            }
            updateCounterFromEvent();
        };

        window.testResubEvent = function() {
            if (OVERLAY_TYPE !== 'sub') {
                console.warn('‚ö†Ô∏è [TEST] This overlay is not in sub mode.');
                return;
            }
            console.log('üß™ [TEST] Simulating resub message event (no count change)...');
            console.log('üß™ [TEST] Count remains:', currentCount);
            // Resub doesn't change count, just acknowledge it
        };

        window.testSetCount = function(newCount) {
            if (typeof newCount !== 'number' || newCount < 0) {
                console.error('‚ùå [TEST] Invalid count. Must be a positive number.');
                return;
            }
            const oldCount = currentCount;
            currentCount = newCount;
            console.log(`üß™ [TEST] Count changed from ${oldCount} to ${newCount}`);
            setStorage(STORAGE_KEYS.COUNTER, currentCount);
            updateCounterFromEvent();
        };

        window.testResetCount = function() {
            const oldCount = currentCount;
            currentCount = 0;
            previousCount = null;
            console.log(`üß™ [TEST] Count reset from ${oldCount} to 0`);
            setStorage(STORAGE_KEYS.COUNTER, 0);
            updateCounterFromEvent();
        };

        window.testGetCount = function() {
            console.log(`üìä [TEST] Current count: ${currentCount}`);
            console.log(`üìä [TEST] Previous count: ${previousCount}`);
            console.log(`üìä [TEST] Overlay type: ${OVERLAY_TYPE}`);
            return currentCount;
        };

        // Simulate real EventSub WebSocket messages
        // delayMs: delay between messages (default 50ms for realistic timing, use 0 for instant)
        window.testEventSubMessage = function(count = 1, eventType = null, delayMs = 50) {
            if (!eventType) {
                eventType = OVERLAY_TYPE === 'sub' ? 'channel.subscribe' : 'channel.follow';
            }

            console.log(`üß™ [TEST] Simulating ${count} real EventSub message(s) of type: ${eventType} (${delayMs}ms delay between messages)`);

            for (let i = 0; i < count; i++) {
                // Create a realistic EventSub notification message
                const mockMessage = {
                    metadata: {
                        message_id: `test-${Date.now()}-${i}`,
                        message_type: 'notification',
                        message_timestamp: new Date().toISOString(),
                        subscription_type: eventType,
                        subscription_version: eventType === 'channel.follow' ? '2' : '1'
                    },
                    payload: {
                        subscription: {
                            id: `test-sub-${i}`,
                            status: 'enabled',
                            type: eventType,
                            version: eventType === 'channel.follow' ? '2' : '1',
                            condition: {
                                broadcaster_user_id: userId || '123456789',
                                ...(eventType === 'channel.follow' ? { moderator_user_id: userId || '123456789' } : {})
                            },
                            transport: {
                                method: 'websocket',
                                session_id: eventSubSessionId || 'test-session-id'
                            },
                            created_at: new Date().toISOString()
                        },
                        event: {
                            user_id: `test-user-${i}`,
                            user_login: `testuser${i}`,
                            user_name: `TestUser${i}`,
                            broadcaster_user_id: userId || '123456789',
                            broadcaster_user_login: broadcasterUsername || 'testbroadcaster',
                            broadcaster_user_name: broadcasterUsername || 'TestBroadcaster',
                            ...(eventType === 'channel.subscribe' ? {
                                tier: '1000',
                                is_gift: false
                            } : {
                                followed_at: new Date().toISOString()
                            })
                        }
                    }
                };

                // Simulate receiving the message through the WebSocket handler with delay
                setTimeout(() => {
                    console.log(`üß™ [TEST] Sending EventSub message ${i + 1}/${count}:`, mockMessage);
                    handleEventSubMessage(mockMessage);
                }, i * delayMs);
            }
        };

        // Simulate multiple gift subs (each recipient gets a channel.subscribe event)
        // delayMs: delay between messages (default 30ms for gift subs to simulate rapid arrival)
        window.testEventSubGiftSubs = function(totalGifts = 1, delayMs = 30) {
            if (OVERLAY_TYPE !== 'sub') {
                console.warn('‚ö†Ô∏è [TEST] This overlay is not in sub mode.');
                return;
            }
            console.log(`üß™ [TEST] Simulating ${totalGifts} gift subscriptions (each triggers a channel.subscribe event)`);
            testEventSubMessage(totalGifts, 'channel.subscribe', delayMs);
        };

        // Log test mode availability
        console.log('üß™ [TEST] Test mode enabled! Available commands:');
        console.log('   testSubEvent(count)           - Simulate subscription(s) (direct increment)');
        console.log('   testGiftEvent(total)            - Simulate gift subscriptions (direct increment)');
        console.log('   testFollowEvent(count)          - Simulate follow(s) (direct increment)');
        console.log('   testResubEvent()                - Simulate resub (no count change)');
        console.log('   testSetCount(number)            - Set count directly');
        console.log('   testResetCount()                - Reset count to 0');
        console.log('   testGetCount()                  - Get current count');
        console.log('   testEventSubMessage(count, type) - Simulate REAL EventSub WebSocket message(s)');
        console.log('   testEventSubGiftSubs(total)     - Simulate gift subs via EventSub messages');
    </script>
</body>
</html>
