<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Valorant Rank Widget - fugu_fps</title>
  <style>
    @font-face {
      font-family: 'Sea Regular Fugu';
      src: url('https://raw.githubusercontent.com/scorpio74890-alt/test-twitch/main/police/sea-regular-fugu.otf') format('opentype');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Sea Regular Fugu', 'Arial', sans-serif;
      background: transparent;
      color: #ffffff;
      overflow: hidden;
    }

    .rank-container {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .rank-icon {
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .rank-icon img {
      width: 60px;
      height: 60px;
      object-fit: contain;
    }

    .rr-display {
      font-size: 24px;
      font-weight: bold;
      color: #ffffff;
    }

    .loading {
      font-size: 16px;
    }

    .error {
      color: #ff0000;
    }
  </style>
</head>
<body>
  <div class="rank-container" id="rankContainer">
    <div class="rank-icon" id="rankIcon">
      <div class="loading">Chargement...</div>
    </div>
    <div class="rr-display" id="rrDisplay">--- RR</div>
  </div>

  <script>
    class ValorantRankWidget {
      constructor() {
        this.playerName = 'ANAKINSKYWALKER';
        this.playerTag = 'HARR';
        this.apiKey = 'HDEV-6e8ce2b6-0be9-4653-81f6-ee2f4faf32a4';
        this.updateInterval = 120000; // 2 minutes
        this.failureCount = 0; // Compteur d'√©checs pour adaptation

        this.currentRankData = {
          rank: 'Ascendant 2',
          rr: 44,
          tier: 22
        };

        this.rankImages = {
          3: 'images/Iron_1_Rank.png',
          4: 'images/Iron_2_Rank.png',
          5: 'images/Iron_3_Rank.png',
          6: 'images/Bronze_1_Rank.png',
          7: 'images/Bronze_2_Rank.png',
          8: 'images/Bronze_3_Rank.png',
          9: 'images/Silver_1_Rank.png',
          10: 'images/Silver_2_Rank.png',
          11: 'images/Silver_3_Rank.png',
          12: 'images/Gold_1_Rank.png',
          13: 'images/Gold_2_Rank.png',
          14: 'images/Gold_3_Rank.png',
          15: 'images/Platinum_1_Rank.png',
          16: 'images/Platinum_2_Rank.png',
          17: 'images/Platinum_3_Rank.png',
          18: 'images/Diamond_1_Rank.png',
          19: 'images/Diamond_2_Rank.png',
          20: 'images/Diamond_3_Rank.png',
          21: 'images/Ascendant_1_Rank.png',
          22: 'images/Ascendant_2_Rank.png',
          23: 'images/Ascendant_3_Rank.png',
          24: 'images/Immortal_1_Rank.png',
          25: 'images/Immortal_2_Rank.png',
          26: 'images/Immortal_3_Rank.png',
          27: 'images/Radiant_Rank.png'
        };

        this.rankNameToId = {
          'Iron 1': 3, 'Iron 2': 4, 'Iron 3': 5,
          'Bronze 1': 6, 'Bronze 2': 7, 'Bronze 3': 8,
          'Silver 1': 9, 'Silver 2': 10, 'Silver 3': 11,
          'Gold 1': 12, 'Gold 2': 13, 'Gold 3': 14,
          'Platinum 1': 15, 'Platinum 2': 16, 'Platinum 3': 17,
          'Diamond 1': 18, 'Diamond 2': 19, 'Diamond 3': 20,
          'Ascendant 1': 21, 'Ascendant 2': 22, 'Ascendant 3': 23,
          'Immortal 1': 24, 'Immortal 2': 25, 'Immortal 3': 26,
          'Radiant': 27
        };

        this.init();
      }

      async init() {
        console.log('üéÆ Initialisation...');
        await this.loadRankData();
        
        // Tentative de r√©cup√©ration des donn√©es API
        const apiSuccess = await this.fetchHenrikAPIData();
        
        if (!apiSuccess) {
          this.displayCurrentRank();
        }
        
        this.connectToTwitchChat();

        // Mise √† jour p√©riodique via API avec adaptation
        this.startPeriodicUpdate();
      }

      startPeriodicUpdate() {
        const updateFunction = async () => {
          const success = await this.fetchHenrikAPIData();
          
          if (success) {
            // Succ√®s : reset du compteur et intervalle normal
            this.failureCount = 0;
            setTimeout(updateFunction, this.updateInterval);
          } else {
            // √âchec : augmentation progressive de l'intervalle
            this.failureCount++;
            const adaptedInterval = this.updateInterval * Math.min(this.failureCount, 5); // Max 10 minutes
            console.log(`‚è±Ô∏è Adaptation intervalle: ${adaptedInterval / 1000}s (√©chec #${this.failureCount})`);
            
            this.displayCurrentRank();
            setTimeout(updateFunction, adaptedInterval);
          }
        };
        
        // Premier appel apr√®s l'intervalle initial
        setTimeout(updateFunction, this.updateInterval);
      }

      async fetchHenrikAPIData() {
        try {
          console.log('üì° R√©cup√©ration des donn√©es API via proxy CORS...');
          
          const proxies = [
            'https://cors.eu.org/',
            'https://cors-anywhere.herokuapp.com/',
            'https://api.codetabs.com/v1/proxy?quest=',
            'https://api.allorigins.win/get?url=',
            'https://yacdn.org/proxy/',
            'https://cors-proxy.fringe.zone/',
            'https://thingproxy.freeboard.io/fetch/'
          ];
          
          for (let i = 0; i < proxies.length; i++) {
            const proxy = proxies[i];
            try {
              console.log(`Essai ${i+1}/${proxies.length} avec proxy: ${proxy}`);
              
              const baseUrl = `https://api.henrikdev.xyz/valorant/v3/mmr/eu/pc/${this.playerName}/${this.playerTag}`;
              let url;
              let headers = {
                'Content-Type': 'application/json',
                'Authorization': this.apiKey
              };
              
              if (proxy.includes('allorigins')) {
                url = proxy + encodeURIComponent(baseUrl);
                // Pour allorigins, pas besoin d'auth header
                headers = { 'Content-Type': 'application/json' };
              } else if (proxy.includes('codetabs')) {
                url = proxy + baseUrl;
              } else if (proxy.includes('thingproxy')) {
                url = proxy + baseUrl;
              } else {
                url = proxy + baseUrl;
              }
              
              const response = await fetch(url, {
                method: 'GET',
                headers: headers
              });
              
              if (!response.ok) {
                // D√©tection sp√©cifique des limitations
                if (response.status === 429) {
                  console.warn(`‚è±Ô∏è Rate limit atteint avec ${proxy} - Pause prolong√©e`);
                  this.failureCount += 2; // P√©nalit√© plus forte pour rate limit
                } else {
                  console.warn(`‚ùå ${proxy} - HTTP ${response.status}`);
                }
                continue;
              }
              
              let data = await response.json();
              
              // Si c'est allorigins, parse le contenu
              if (proxy.includes('allorigins')) {
                if (data.contents) {
                  data = JSON.parse(data.contents);
                }
              }
              
              if (data.status === 200 && data.data && data.data.current) {
                const current = data.data.current;
                
                this.currentRankData = {
                  rank: current.tier.name,
                  rr: current.rr,
                  tier: current.tier.id
                };
                
                console.log(`‚úÖ Donn√©es API r√©cup√©r√©es via ${proxy}:`, this.currentRankData);
                this.saveRankData();
                this.displayCurrentRank();
                return true;
              } else {
                console.warn(`‚ùå ${proxy} - Format de donn√©es invalide`);
                continue;
              }
              
            } catch (error) {
              console.warn(`‚ùå ${proxy} - ${error.message}`);
              continue;
            }
          }
          
          throw new Error('Tous les proxies ont √©chou√©');
          
        } catch (error) {
          console.warn('‚ö†Ô∏è Erreur API, utilisation des donn√©es du chat/localStorage:', error.message);
          return false;
        }
      }

      async loadRankData() {
        try {
          const savedData = localStorage.getItem('valorant-rank-data');
          if (savedData) {
            this.currentRankData = JSON.parse(savedData);
            console.log('‚úÖ Donn√©es charg√©es depuis localStorage:', this.currentRankData);
          }
        } catch (err) {
          console.warn('‚ö†Ô∏è Lecture localStorage impossible.');
        }
      }

      async saveRankData() {
        try {
          localStorage.setItem('valorant-rank-data', JSON.stringify(this.currentRankData));
          console.log('üíæ Donn√©es sauvegard√©es.');
        } catch (err) {
          console.error('‚ùå Erreur sauvegarde localStorage:', err);
        }
      }

      displayCurrentRank() {
        const rrDisplay = document.getElementById('rrDisplay');
        const rankIcon = document.getElementById('rankIcon');
        const { rank, rr, tier } = this.currentRankData;

        rrDisplay.textContent = `${rr} RR`;

        if (this.rankImages[tier]) {
          rankIcon.innerHTML = `<img src="${this.rankImages[tier]}" alt="${rank}">`;
        } else {
          rankIcon.innerHTML = `<div>${rank}</div>`;
        }
      }

      connectToTwitchChat() {
        const socket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');

        socket.onopen = () => {
          socket.send('CAP REQ :twitch.tv/tags twitch.tv/commands');
          socket.send('PASS SCHMOOPIIE');
          socket.send('NICK justinfan12345');
          socket.send('JOIN #fugu_fps');
          console.log('üîå Connect√© au chat Twitch');
        };

        socket.onmessage = (event) => {
          const message = event.data;
          if (message.startsWith('PING')) {
            socket.send('PONG :tmi.twitch.tv');
            return;
          }

          this.parseRankMessage(message);
        };

        socket.onerror = (error) => {
          console.error('‚ùå WebSocket error:', error);
        };

        socket.onclose = () => {
          console.log('üîå Reconnexion pr√©vue dans 10s...');
          setTimeout(() => this.connectToTwitchChat(), 10000);
        };
      }

      parseRankMessage(rawMessage) {
        if (!rawMessage.includes('wzbot!wzbot@wzbot.tmi.twitch.tv') || !rawMessage.includes('PRIVMSG')) return;

        const privmsgIndex = rawMessage.indexOf('PRIVMSG #fugu_fps :');
        if (privmsgIndex === -1) return;

        let messageText = rawMessage.substring(privmsgIndex + 'PRIVMSG #fugu_fps :'.length).trim();

        const rankPattern = /^(.+?)\s*:\s*(\d+)\s*RR/i;
        const match = messageText.match(rankPattern);

        if (match) {
          const rankName = match[1].trim();
          const rrValue = parseInt(match[2]);
          const rankId = this.rankNameToId[rankName];

          if (rankId) {
            console.log(`üéØ Rang mis √† jour via chat: ${rankName} - ${rrValue} RR`);
            this.currentRankData = { rank: rankName, rr: rrValue, tier: rankId };
            this.saveRankData();
            this.displayCurrentRank();
          }
        }
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      new ValorantRankWidget();
    });
  </script>
</body>
</html>