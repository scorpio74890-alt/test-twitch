<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Match Overlay - fugu_fps</title>
    <!--
    ========================================
    COMMANDES DE CHAT DISPONIBLES
    ========================================

    üîÑ !matchrefresh - Force le rechargement de la page (Mod√©rateurs + VIPs uniquement)
    üîÑ !matchreload  - Force le rechargement de la page (Mod√©rateurs + VIPs uniquement)
    üëÅÔ∏è !showmatches - Affiche l'overlay des matchs (Mod√©rateurs + VIPs uniquement)
    üôà !hidematches - Cache l'overlay des matchs (Mod√©rateurs + VIPs uniquement)

    üëÆ MOD√âRATEURS AUTORIS√âS:
    fugu_fps, wizebot, wzbot, emmamachou, gamlno, d3vilsfr,
    pogo__fps, babouille__, spoutnik_le_puant, z4apox, kudji__,
    kc_biolxzy, silaaaxe, streamelements, nutelloush, mustee___,
    ze1sh, vincent_maes12, dragonk_fps, chloedsx, maeniiaaa,
    g4li_fps, xiress_gp, prodigymarketing, chaima_2808,
    lea_ackermann, darkoootv

    üëë VIPS AUTORIS√âS:
    sc0rpio74890

    üß™ TESTS (Console):
    window.matchOverlay.testCommandPermissions('username')
    window.matchOverlay.testRefresh()
    window.matchOverlay.testHide()
    window.matchOverlay.testShow()
    window.matchOverlay.clearProcessedMatches()
    window.matchOverlay.showProcessedMatchesCount()
    window.matchOverlay.testStreamOffline()
    window.matchOverlay.testStreamOnline()
    ========================================
    -->
    <style>
        @font-face {
            font-family: 'Sea Regular Fugu';
            src: url('https://raw.githubusercontent.com/scorpio74890-alt/test-twitch/main/police/sea-regular-fugu.otf') format('opentype'),
                 url('../../police/sea-regular-fugu.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Sea Regular Fugu', 'Comic Sans MS', 'Trebuchet MS', 'Arial Black', Arial, sans-serif;
            background: transparent;
            color: #ffffff;
            overflow: hidden;
        }

        #match-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 0;
            font-size: 48px;
            font-weight: bold;
            text-shadow: none;
            z-index: 9999;
            min-width: auto;
            text-align: left;
        }

        .wins {
            color: #00ff88;
        }

        .losses {
            color: #ff4444;
        }

        .separator {
            color: #ffffff;
            margin: 0 10px;
        }
    </style>
</head>
<body>
    <div id="match-overlay">
        <div class="score">
            <span class="wins">0W</span>
            <span class="separator">/</span>
            <span class="losses">0L</span>
        </div>
    </div>

    <script>
        class MatchOverlay {
            constructor() {
                this.wins = 0;
                this.losses = 0;
                this.processedMatches = new Set();
                this.isLive = false;
                this.isVisible = true;
                this.matchCheckInterval = null;
                this.playerName = 'ANAKINSKYWALKER';
                this.playerTag = 'HARR';
                this.apiKey = 'HDEV-6e8ce2b6-0be9-4653-81f6-ee2f4faf32a4';
                this.clientId = 'gp762nuuoqcoxypju8c569th9wz7q5';
                this.authToken = 'xrugdtwxy33q6p1dw0tg3nlkehj422';

                // Listes des utilisateurs autoris√©s
                this.moderators = [
                    'fugu_fps', 'wizebot', 'wzbot', 'emmamachou', 'gamlno', 'd3vilsfr',
                    'pogo__fps', 'babouille__', 'spoutnik_le_puant', 'z4apox', 'kudji__',
                    'kc_biolxzy', 'silaaaxe', 'streamelements', 'nutelloush', 'mustee___',
                    'ze1sh', 'vincent_maes12', 'dragonk_fps', 'chloedsx', 'maeniiaaa',
                    'g4li_fps', 'xiress_gp', 'prodgymarketing', 'chaima_2808',
                    'lea_ackermann', 'darkoootv'
                ];

                this.vips = ['sc0rpio74890'];
                this.blacklist = ['bot1', 'bot2'];

                this.init();
            }

            init() {
                console.log('üöÄ D√©marrage du Match Overlay avec syst√®me de commandes...');
                this.loadScoreFromStorage();
                this.loadProcessedMatchesFromStorage();
                this.loadVisibilityFromStorage();
                this.checkStreamStatus();
                this.connectToTwitchChat();
                // Ne pas d√©marrer l'intervalle ici, il sera d√©marr√© seulement si le stream est en direct

                // V√©rifier le statut du stream toutes les 30 secondes
                setInterval(() => {
                    this.checkStreamStatus();
                }, 30000);

                // Rendre accessible depuis la console pour les tests
                window.matchOverlay = this;
                console.log('üîß Overlay accessible via window.matchOverlay pour les tests');
            }

            loadScoreFromStorage() {
                try {
                    const savedScore = localStorage.getItem('match-overlay-score');
                    if (savedScore) {
                        const score = JSON.parse(savedScore);
                        this.wins = score.wins || 0;
                        this.losses = score.losses || 0;
                        console.log('‚úÖ Score charg√© depuis localStorage:', { wins: this.wins, losses: this.losses });
                    }
                } catch (error) {
                    console.log('üìÑ Impossible de charger le score sauvegard√©');
                }
                this.updateDisplay();
            }

            loadProcessedMatchesFromStorage() {
                try {
                    const savedMatches = localStorage.getItem('match-overlay-processed-matches');
                    if (savedMatches) {
                        const matchIds = JSON.parse(savedMatches);
                        this.processedMatches = new Set(matchIds);
                        console.log('‚úÖ Match IDs trait√©s charg√©s depuis localStorage:', this.processedMatches.size, 'matches');
                    }
                } catch (error) {
                    console.log('üìÑ Impossible de charger les match IDs trait√©s sauvegard√©s');
                }
            }

            saveScoreToStorage() {
                try {
                    const scoreToSave = {
                        wins: this.wins,
                        losses: this.losses,
                        lastUpdated: new Date().toISOString()
                    };
                    localStorage.setItem('match-overlay-score', JSON.stringify(scoreToSave));
                    console.log('üíæ Score sauvegard√© dans localStorage:', scoreToSave);
                } catch (error) {
                    console.error('‚ùå Erreur lors de la sauvegarde du score:', error);
                }
            }

            saveProcessedMatchesToStorage() {
                try {
                    const matchIdsArray = Array.from(this.processedMatches);
                    localStorage.setItem('match-overlay-processed-matches', JSON.stringify(matchIdsArray));
                    console.log('üíæ Match IDs trait√©s sauvegard√©s dans localStorage:', matchIdsArray.length, 'matches');
                } catch (error) {
                    console.error('‚ùå Erreur lors de la sauvegarde des match IDs trait√©s:', error);
                }
            }

            loadVisibilityFromStorage() {
                try {
                    const savedVisibility = localStorage.getItem('match-overlay-visibility');
                    if (savedVisibility) {
                        this.isVisible = JSON.parse(savedVisibility);
                        console.log('‚úÖ Visibilit√© charg√©e depuis localStorage:', this.isVisible);
                    }
                } catch (error) {
                    console.log('üìÑ Impossible de charger la visibilit√© sauvegard√©e');
                }
            }

            saveVisibilityToStorage() {
                try {
                    localStorage.setItem('match-overlay-visibility', JSON.stringify(this.isVisible));
                    console.log('üíæ Visibilit√© sauvegard√©e dans localStorage:', this.isVisible);
                } catch (error) {
                    console.error('‚ùå Erreur lors de la sauvegarde de la visibilit√©:', error);
                }
            }

            displayOverlay() {
                const overlayElement = document.getElementById('match-overlay');
                if (overlayElement) {
                    if (this.isVisible) {
                        overlayElement.style.display = 'block';
                        console.log('üëÅÔ∏è Overlay affich√©');
                    } else {
                        overlayElement.style.display = 'none';
                        console.log('üôà Overlay masqu√©');
                    }
                }
            }

            updateDisplay() {
                const winsElement = document.querySelector('.wins');
                const lossesElement = document.querySelector('.losses');

                if (winsElement) winsElement.textContent = `${this.wins}W`;
                if (lossesElement) lossesElement.textContent = `${this.losses}L`;

                console.log(`üìä Affichage mis √† jour: ${this.wins}W/${this.losses}L`);

                // Appliquer l'√©tat de visibilit√©
                this.displayOverlay();
            }

            async checkStreamStatus() {
                try {
                    console.log('üîç V√©rification du statut du stream...');

                    const response = await fetch('https://api.twitch.tv/helix/streams?user_login=fugu_fps', {
                        headers: {
                            'Client-Id': this.clientId,
                            'Authorization': `Bearer ${this.authToken}`
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`Erreur HTTP: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('üì° R√©ponse API Twitch:', data);

                    const wasLive = this.isLive;

                    if (data.data && data.data.length > 0) {
                        const stream = data.data[0];
                        this.isLive = stream.type === 'live';

                        if (this.isLive) {
                            console.log('üü¢ Stream en direct d√©tect√©');
                            if (!wasLive) {
                                console.log('üîÑ Stream remis en ligne, reprise de la v√©rification des matchs');
                                this.startMatchCheckInterval();
                            }
                        } else {
                            console.log('‚ö´ Stream en pause');
                            if (wasLive) {
                                console.log('‚è∏Ô∏è Stream mis en pause, arr√™t de la v√©rification des matchs');
                                this.stopMatchCheckInterval();
                            }
                        }
                    } else {
                        this.isLive = false;
                        console.log('‚ö´ Aucun stream actif');

                        if (wasLive) {
                            console.log('üî¥ Stream hors ligne, arr√™t de la v√©rification des matchs');
                            this.stopMatchCheckInterval();

                            // Reset score to 0W/0L when stream goes offline
                            console.log('üîÑ Score r√©initialis√© √† 0W/0L (stream hors ligne)');
                            this.wins = 0;
                            this.losses = 0;
                            this.updateDisplay();
                            this.saveScoreToStorage();
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Erreur lors de la v√©rification du statut du stream:', error);
                    this.isLive = false;
                }
            }

            async checkMatchData() {
                if (!this.isLive) {
                    console.log('‚è∏Ô∏è Stream hors ligne, pas de v√©rification de match');
                    return;
                }

                try {
                    console.log('üéÆ V√©rification des donn√©es de match...');

                    const apiUrl = `https://api.henrikdev.xyz/valorant/v3/matches/eu/${this.playerName}/${this.playerTag}?size=1&api_key=${this.apiKey}`;
                    console.log('üåê URL API Match:', apiUrl);

                    const response = await fetch(apiUrl);

                    if (!response.ok) {
                        throw new Error(`Erreur HTTP: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('üì¶ Donn√©es de match re√ßues:', data);

                    if (data.data && data.data.length > 0) {
                        const match = data.data[0];
                        const matchId = match.metadata?.matchid;

                        if (matchId) {
                            console.log(`üéØ Match ID trouv√©: ${matchId}`);

                            if (!this.processedMatches.has(matchId)) {
                                console.log('üÜï Nouveau match d√©tect√©, traitement...');
                                this.processMatch(match);
                                this.processedMatches.add(matchId);
                                this.saveProcessedMatchesToStorage();

                                // Limiter la taille du Set pour √©viter la surcharge m√©moire
                                if (this.processedMatches.size > 100) {
                                    const firstKey = this.processedMatches.keys().next().value;
                                    this.processedMatches.delete(firstKey);
                                    this.saveProcessedMatchesToStorage();
                                }
                            } else {
                                console.log('üîÑ Match d√©j√† trait√©, pas de changement');
                            }
                        } else {
                            console.log('‚ùå Pas de Match ID dans les donn√©es');
                        }
                    } else {
                        console.log('üìÑ Aucune donn√©e de match disponible');
                    }
                } catch (error) {
                    console.error('‚ùå Erreur lors de la v√©rification des donn√©es de match:', error);
                }
            }

            processMatch(match) {
                try {
                    console.log('üîç Traitement du match...');

                    // Trouver le joueur dans le match
                    let playerTeam = null;
                    let playerFound = false;

                    if (match.players && Array.isArray(match.players.all_players)) {
                        for (const player of match.players.all_players) {
                            if (player.name === this.playerName && player.tag === this.playerTag) {
                                playerTeam = player.team;
                                playerFound = true;
                                console.log(`üë§ Joueur trouv√© dans l'√©quipe: ${playerTeam}`);
                                break;
                            }
                        }
                    }

                    if (!playerFound) {
                        console.log('‚ùå Joueur non trouv√© dans le match');
                        return;
                    }

                    // D√©terminer le r√©sultat
                    if (match.teams && match.teams.red && match.teams.blue) {
                        const redTeam = match.teams.red;
                        const blueTeam = match.teams.blue;

                        let playerWon = false;

                        if (playerTeam === 'Red') {
                            playerWon = redTeam.has_won;
                        } else if (playerTeam === 'Blue') {
                            playerWon = blueTeam.has_won;
                        }

                        console.log(`üèÜ R√©sultat: ${playerWon ? 'VICTOIRE' : 'D√âFAITE'} (√âquipe: ${playerTeam})`);

                        // Mettre √† jour le score
                        if (playerWon) {
                            this.wins++;
                            console.log(`‚úÖ Victoire! Score: ${this.wins}W/${this.losses}L`);
                        } else {
                            this.losses++;
                            console.log(`‚ùå D√©faite! Score: ${this.wins}W/${this.losses}L`);
                        }

                        this.updateDisplay();
                        this.saveScoreToStorage();
                    } else {
                        console.log('‚ùå Donn√©es d\'√©quipe manquantes dans le match');
                    }
                } catch (error) {
                    console.error('‚ùå Erreur lors du traitement du match:', error);
                }
            }

            startMatchCheckInterval() {
                // V√©rifier les matchs toutes les 15 secondes
                this.matchCheckInterval = setInterval(() => {
                    this.checkMatchData();
                }, 15000);

                console.log('‚è∞ V√©rification des matchs programm√©e toutes les 15 secondes');
            }

            stopMatchCheckInterval() {
                if (this.matchCheckInterval) {
                    clearInterval(this.matchCheckInterval);
                    this.matchCheckInterval = null;
                    console.log('‚è∏Ô∏è V√©rification des matchs arr√™t√©e');
                }
            }

            connectToTwitchChat() {
                console.log('üîó Connexion au chat Twitch pour √©couter les commandes...');

                const socket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');

                socket.onopen = () => {
                    console.log('‚úÖ Connect√© au chat Twitch de fugu_fps');
                    socket.send('CAP REQ :twitch.tv/tags twitch.tv/commands');
                    socket.send('PASS SCHMOOPIIE');
                    socket.send('NICK justinfan12345');
                    socket.send('JOIN #fugu_fps');
                };

                socket.onmessage = (event) => {
                    const message = event.data;

                    if (message.startsWith('PING')) {
                        socket.send('PONG :tmi.twitch.tv');
                        return;
                    }

                    this.parseChatMessage(message);
                };

                socket.onerror = (error) => {
                    console.error('‚ùå Erreur de connexion au chat Twitch:', error);
                };

                socket.onclose = () => {
                    console.log('üîå Connexion au chat Twitch ferm√©e');
                    setTimeout(() => {
                        console.log('üîÑ Tentative de reconnexion...');
                        this.connectToTwitchChat();
                    }, 10000);
                };
            }

            parseChatMessage(rawMessage) {
                try {
                    if (!rawMessage.includes('PRIVMSG #fugu_fps :')) {
                        return;
                    }

                    const tagsMatch = rawMessage.match(/@([^ ]+) /);
                    let userTags = '';
                    if (tagsMatch) {
                        userTags = tagsMatch[1];
                    }

                    const usernameMatch = rawMessage.match(/:(.*?)!/);
                    const messageMatch = rawMessage.match(/PRIVMSG #fugu_fps :(.+)$/);

                    if (usernameMatch && messageMatch) {
                        const username = usernameMatch[1];
                        const message = messageMatch[1].trim();

                        this.handleChatCommand(username, message, userTags);
                    }
                } catch (error) {
                    console.error('‚ùå Erreur lors du parsing du message:', error);
                }
            }

            handleChatCommand(username, message, userTags) {
                const lowerMessage = message.toLowerCase();
                const lowerUsername = username.toLowerCase();

                if (lowerMessage === '!matchrefresh' || lowerMessage === '!matchreload') {
                    if (this.hasPermission(username, userTags)) {
                        console.log(`üîÑ Commande ${message} re√ßue de ${username} - Rechargement forc√© des donn√©es...`);

                        // Forcer la v√©rification des matchs
                        this.checkMatchData();
                    } else {
                        console.log(`‚ùå ${username} a tent√© d'utiliser ${message} sans permission`);
                    }
                    return;
                }

                if (lowerMessage === '!hidematches') {
                    if (this.hasPermission(username, userTags)) {
                        console.log(`üôà Commande !hidematches re√ßue de ${username} - Masquage de l'overlay...`);
                        this.isVisible = false;
                        this.saveVisibilityToStorage();
                        this.displayOverlay();
                    } else {
                        console.log(`‚ùå ${username} a tent√© d'utiliser !hidematches sans permission`);
                    }
                    return;
                }

                if (lowerMessage === '!showmatches') {
                    if (this.hasPermission(username, userTags)) {
                        console.log(`üëÅÔ∏è Commande !showmatches re√ßue de ${username} - Affichage de l'overlay...`);
                        this.isVisible = true;
                        this.saveVisibilityToStorage();
                        this.displayOverlay();
                    } else {
                        console.log(`‚ùå ${username} a tent√© d'utiliser !showmatches sans permission`);
                    }
                    return;
                }
            }

            hasPermission(username, userTags) {
                const lowerUsername = username.toLowerCase();

                // V√©rifier la blacklist
                if (this.blacklist.includes(lowerUsername)) {
                    return false;
                }

                // V√©rifier les mod√©rateurs
                if (this.moderators.includes(lowerUsername)) {
                    return true;
                }

                // V√©rifier les VIPs
                if (this.vips.includes(lowerUsername)) {
                    return true;
                }

                return false;
            }

            // M√©thode de test pour v√©rifier les permissions (√† appeler depuis la console)
            testCommandPermissions(username) {
                console.log(`üß™ Test des permissions pour: ${username}`);
                console.log(`   üëÆ Mod√©rateur: ${this.moderators.includes(username.toLowerCase())}`);
                console.log(`   üëë VIP: ${this.vips.includes(username.toLowerCase())}`);
                console.log(`   üö´ Blacklist√©: ${this.blacklist.includes(username.toLowerCase())}`);
                console.log(`   ‚úÖ Peut utiliser les commandes: ${this.hasPermission(username, '')}`);
            }

            // M√©thode de test pour d√©clencher un refresh manuellement
            testRefresh() {
                console.log('üß™ Test de refresh manuel des donn√©es de match...');
                this.checkMatchData();
            }

            // M√©thode de test pour masquer l'overlay
            testHide() {
                console.log('üß™ Test de masquage de l\'overlay...');
                this.isVisible = false;
                this.saveVisibilityToStorage();
                this.displayOverlay();
            }

            // M√©thode de test pour afficher l'overlay
            testShow() {
                console.log('üß™ Test d\'affichage de l\'overlay...');
                this.isVisible = true;
                this.saveVisibilityToStorage();
                this.displayOverlay();
            }

            // M√©thode pour r√©initialiser le score (pour les tests)
            resetScore() {
                this.wins = 0;
                this.losses = 0;
                this.processedMatches.clear();
                this.updateDisplay();
                this.saveScoreToStorage();
                this.saveProcessedMatchesToStorage();
                console.log('üîÑ Score r√©initialis√© √† 0W/0L');
            }

            // M√©thode de test pour effacer les matchs trait√©s (pour les tests)
            clearProcessedMatches() {
                this.processedMatches.clear();
                this.saveProcessedMatchesToStorage();
                console.log('üßπ Matchs trait√©s effac√©s');
            }

            // M√©thode de test pour afficher le nombre de matchs trait√©s (pour les tests)
            showProcessedMatchesCount() {
                console.log(`üìä Nombre de matchs trait√©s: ${this.processedMatches.size}`);
                console.log('üìã Match IDs trait√©s:', Array.from(this.processedMatches));
            }

            // M√©thode de test pour simuler le stream hors ligne
            testStreamOffline() {
                console.log('üß™ Test: Simulation du stream hors ligne...');
                const wasLive = this.isLive;
                this.isLive = false;

                if (wasLive) {
                    console.log('üîÑ Score r√©initialis√© √† 0W/0L (stream hors ligne simul√©)');
                    this.wins = 0;
                    this.losses = 0;
                    this.updateDisplay();
                    this.saveScoreToStorage();
                    this.stopMatchCheckInterval();
                }
            }

            // M√©thode de test pour simuler le stream en ligne
            testStreamOnline() {
                console.log('üß™ Test: Simulation du stream en ligne...');
                const wasLive = this.isLive;
                this.isLive = true;

                if (!wasLive) {
                    console.log('üîÑ Stream remis en ligne simul√©, reprise de la v√©rification des matchs');
                    this.startMatchCheckInterval();
                }
            }
        }

        // Initialiser l'overlay quand la page est charg√©e
        document.addEventListener('DOMContentLoaded', () => {
            new MatchOverlay();
        });
    </script>
</body>
</html>
