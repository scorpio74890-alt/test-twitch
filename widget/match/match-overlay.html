<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Match Overlay - fugu_fps</title>
    <!--
    ========================================
    COMMANDES DE CHAT DISPONIBLES
    ========================================

    ðŸ”„ !matchrefresh - Force le rechargement de la page (ModÃ©rateurs + VIPs uniquement)
    ðŸ”„ !matchreload  - Force le rechargement de la page (ModÃ©rateurs + VIPs uniquement)
    ðŸ‘ï¸ !showmatches - Affiche l'overlay des matchs (ModÃ©rateurs + VIPs uniquement)
    ðŸ™ˆ !hidematches - Cache l'overlay des matchs (ModÃ©rateurs + VIPs uniquement)

    ðŸ‘® MODÃ‰RATEURS AUTORISÃ‰S:
    fugu_fps, wizebot, wzbot, emmamachou, gamlno, d3vilsfr,
    pogo__fps, babouille__, spoutnik_le_puant, z4apox, kudji__,
    kc_biolxzy, silaaaxe, streamelements, nutelloush, mustee___,
    ze1sh, vincent_maes12, dragonk_fps, chloedsx, maeniiaaa,
    g4li_fps, xiress_gp, prodigymarketing, chaima_2808,
    lea_ackermann, darkoootv

    ðŸ‘‘ VIPS AUTORISÃ‰S:
    sc0rpio74890

    ðŸ§ª TESTS (Console):
    window.matchOverlay.testCommandPermissions('username')
    window.matchOverlay.testRefresh()
    window.matchOverlay.testHide()
    window.matchOverlay.testShow()
    window.matchOverlay.clearProcessedMatches()
    window.matchOverlay.showProcessedMatchesCount()
    window.matchOverlay.testStreamOffline()
    window.matchOverlay.testStreamOnline()
    ========================================
    -->
    <style>
        @font-face {
            font-family: 'Sea Regular Fugu';
            src: url('https://raw.githubusercontent.com/scorpio74890-alt/test-twitch/main/police/sea-regular-fugu.otf') format('opentype'),
                 url('../../police/sea-regular-fugu.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Sea Regular Fugu', 'Comic Sans MS', 'Trebuchet MS', 'Arial Black', Arial, sans-serif;
            background: transparent;
            color: #ffffff;
            overflow: hidden;
        }

        #match-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 0;
            font-size: 48px;
            font-weight: bold;
            text-shadow: none;
            z-index: 9999;
            min-width: auto;
            text-align: left;
        }

        .wins {
            color: #00ff88;
        }

        .losses {
            color: #ff4444;
        }

        .separator {
            color: #ffffff;
            margin: 0 10px;
        }
    </style>
</head>
<body>
    <div id="match-overlay">
        <div class="score">
            <span class="wins">0W</span>
            <span class="separator">/</span>
            <span class="losses">0L</span>
        </div>
    </div>

    <script>
        class MatchOverlay {
            constructor() {
                this.wins = 0;
                this.losses = 0;
                this.processedMatches = new Set();
                this.isLive = false;
                this.isVisible = true;
                this.matchCheckInterval = null;
                this.playerName = 'ANAKINSKYWALKER';
                this.playerTag = 'HARR';
                this.apiKey = 'HDEV-6e8ce2b6-0be9-4653-81f6-ee2f4faf32a4';
                this.clientId = 'gp762nuuoqcoxypju8c569th9wz7q5';
                this.authToken = 'xrugdtwxy33q6p1dw0tg3nlkehj422';

                // Listes des utilisateurs autorisÃ©s
                this.moderators = [
                    'fugu_fps', 'wizebot', 'wzbot', 'emmamachou', 'gamlno', 'd3vilsfr',
                    'pogo__fps', 'babouille__', 'spoutnik_le_puant', 'z4apox', 'kudji__',
                    'kc_biolxzy', 'silaaaxe', 'streamelements', 'nutelloush', 'mustee___',
                    'ze1sh', 'vincent_maes12', 'dragonk_fps', 'chloedsx', 'maeniiaaa',
                    'g4li_fps', 'xiress_gp', 'prodgymarketing', 'chaima_2808',
                    'lea_ackermann', 'darkoootv'
                ];

                this.vips = ['sc0rpio74890'];
                this.blacklist = ['bot1', 'bot2'];

                this.init();
            }

            init() {
                console.log('ðŸš€ DÃ©marrage du Match Overlay avec systÃ¨me de commandes...');
                this.loadScoreFromStorage();
                this.loadProcessedMatchesFromStorage();
                this.loadVisibilityFromStorage();
                this.checkStreamStatus();
                this.connectToTwitchChat();
                // Ne pas dÃ©marrer l'intervalle ici, il sera dÃ©marrÃ© seulement si le stream est en direct

                // VÃ©rifier le statut du stream toutes les 30 secondes
                setInterval(() => {
                    this.checkStreamStatus();
                }, 30000);

                // Rendre accessible depuis la console pour les tests
                window.matchOverlay = this;
                console.log('ðŸ”§ Overlay accessible via window.matchOverlay pour les tests');
            }

            loadScoreFromStorage() {
                try {
                    const savedScore = localStorage.getItem('match-overlay-score');
                    if (savedScore) {
                        const score = JSON.parse(savedScore);
                        this.wins = score.wins || 0;
                        this.losses = score.losses || 0;
                        console.log('âœ… Score chargÃ© depuis localStorage:', { wins: this.wins, losses: this.losses });
                    }
                } catch (error) {
                    console.log('ðŸ“„ Impossible de charger le score sauvegardÃ©');
                }
                this.updateDisplay();
            }

            loadProcessedMatchesFromStorage() {
                try {
                    const savedMatches = localStorage.getItem('match-overlay-processed-matches');
                    if (savedMatches) {
                        const matchIds = JSON.parse(savedMatches);
                        this.processedMatches = new Set(matchIds);
                        console.log('âœ… Match IDs traitÃ©s chargÃ©s depuis localStorage:', this.processedMatches.size, 'matches');
                    }
                } catch (error) {
                    console.log('ðŸ“„ Impossible de charger les match IDs traitÃ©s sauvegardÃ©s');
                }
            }

            saveScoreToStorage() {
                try {
                    const scoreToSave = {
                        wins: this.wins,
                        losses: this.losses,
                        lastUpdated: new Date().toISOString()
                    };
                    localStorage.setItem('match-overlay-score', JSON.stringify(scoreToSave));
                    console.log('ðŸ’¾ Score sauvegardÃ© dans localStorage:', scoreToSave);
                } catch (error) {
                    console.error('âŒ Erreur lors de la sauvegarde du score:', error);
                }
            }

            saveProcessedMatchesToStorage() {
                try {
                    const matchIdsArray = Array.from(this.processedMatches);
                    localStorage.setItem('match-overlay-processed-matches', JSON.stringify(matchIdsArray));
                    console.log('ðŸ’¾ Match IDs traitÃ©s sauvegardÃ©s dans localStorage:', matchIdsArray.length, 'matches');
                } catch (error) {
                    console.error('âŒ Erreur lors de la sauvegarde des match IDs traitÃ©s:', error);
                }
            }

            loadVisibilityFromStorage() {
                try {
                    const savedVisibility = localStorage.getItem('match-overlay-visibility');
                    if (savedVisibility) {
                        this.isVisible = JSON.parse(savedVisibility);
                        console.log('âœ… VisibilitÃ© chargÃ©e depuis localStorage:', this.isVisible);
                    }
                } catch (error) {
                    console.log('ðŸ“„ Impossible de charger la visibilitÃ© sauvegardÃ©e');
                }
            }

            saveVisibilityToStorage() {
                try {
                    localStorage.setItem('match-overlay-visibility', JSON.stringify(this.isVisible));
                    console.log('ðŸ’¾ VisibilitÃ© sauvegardÃ©e dans localStorage:', this.isVisible);
                } catch (error) {
                    console.error('âŒ Erreur lors de la sauvegarde de la visibilitÃ©:', error);
                }
            }

            displayOverlay() {
                const overlayElement = document.getElementById('match-overlay');
                if (overlayElement) {
                    if (this.isVisible) {
                        overlayElement.style.display = 'block';
                        console.log('ðŸ‘ï¸ Overlay affichÃ©');
                    } else {
                        overlayElement.style.display = 'none';
                        console.log('ðŸ™ˆ Overlay masquÃ©');
                    }
                }
            }

            updateDisplay() {
                const winsElement = document.querySelector('.wins');
                const lossesElement = document.querySelector('.losses');

                if (winsElement) winsElement.textContent = `${this.wins}W`;
                if (lossesElement) lossesElement.textContent = `${this.losses}L`;

                console.log(`ðŸ“Š Affichage mis Ã  jour: ${this.wins}W/${this.losses}L`);

                // Appliquer l'Ã©tat de visibilitÃ©
                this.displayOverlay();
            }

            async checkStreamStatus() {
                try {
                    console.log('ðŸ” VÃ©rification du statut du stream...');

                    const response = await fetch('https://api.twitch.tv/helix/streams?user_login=fugu_fps', {
                        headers: {
                            'Client-Id': this.clientId,
                            'Authorization': `Bearer ${this.authToken}`
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`Erreur HTTP: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('ðŸ“¡ RÃ©ponse API Twitch:', data);

                    const wasLive = this.isLive;

                    if (data.data && data.data.length > 0) {
                        const stream = data.data[0];
                        this.isLive = stream.type === 'live';

                        if (this.isLive) {
                            console.log('ðŸŸ¢ Stream en direct dÃ©tectÃ©');
                            if (!wasLive) {
                                console.log('ðŸ”„ Stream remis en ligne, reprise de la vÃ©rification des matchs');
                                this.startMatchCheckInterval();
                            }
                        } else {
                            console.log('âš« Stream en pause');
                            if (wasLive) {
                                console.log('â¸ï¸ Stream mis en pause, arrÃªt de la vÃ©rification des matchs');
                                this.stopMatchCheckInterval();
                            }
                        }
                    } else {
                        this.isLive = false;
                        console.log('âš« Aucun stream actif');

                        if (wasLive) {
                            console.log('ðŸ”´ Stream hors ligne, arrÃªt de la vÃ©rification des matchs');
                            this.stopMatchCheckInterval();

                            // Reset score to 0W/0L when stream goes offline
                            console.log('ðŸ”„ Score rÃ©initialisÃ© Ã  0W/0L (stream hors ligne)');
                            this.wins = 0;
                            this.losses = 0;
                            this.updateDisplay();
                            this.saveScoreToStorage();
                        }
                    }
                } catch (error) {
                    console.error('âŒ Erreur lors de la vÃ©rification du statut du stream:', error);
                    this.isLive = false;
                }
            }

            async checkMatchData() {
                if (!this.isLive) {
                    console.log('â¸ï¸ Stream hors ligne, pas de vÃ©rification de match');
                    return;
                }

                try {
                    console.log('ðŸŽ® VÃ©rification des donnÃ©es de match...');

                    const apiUrl = `https://api.henrikdev.xyz/valorant/v3/matches/eu/${this.playerName}/${this.playerTag}?size=1&api_key=${this.apiKey}`;
                    console.log('ðŸŒ URL API Match:', apiUrl);

                    const response = await fetch(apiUrl);

                    if (!response.ok) {
                        throw new Error(`Erreur HTTP: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('ðŸ“¦ DonnÃ©es de match reÃ§ues:', data);

                    if (data.data && data.data.length > 0) {
                        const match = data.data[0];
                        const matchId = match.metadata?.matchid;

                        if (matchId) {
                            console.log(`ðŸŽ¯ Match ID trouvÃ©: ${matchId}`);

                            if (!this.processedMatches.has(matchId)) {
                                console.log('ðŸ†• Nouveau match dÃ©tectÃ©, traitement...');
                                this.processMatch(match);
                                this.processedMatches.add(matchId);
                                this.saveProcessedMatchesToStorage();

                                // Limiter la taille du Set pour Ã©viter la surcharge mÃ©moire
                                if (this.processedMatches.size > 100) {
                                    const firstKey = this.processedMatches.keys().next().value;
                                    this.processedMatches.delete(firstKey);
                                    this.saveProcessedMatchesToStorage();
                                }
                            } else {
                                console.log('ðŸ”„ Match dÃ©jÃ  traitÃ©, pas de changement');
                            }
                        } else {
                            console.log('âŒ Pas de Match ID dans les donnÃ©es');
                        }
                    } else {
                        console.log('ðŸ“„ Aucune donnÃ©e de match disponible');
                    }
                } catch (error) {
                    console.error('âŒ Erreur lors de la vÃ©rification des donnÃ©es de match:', error);
                }
            }

            processMatch(match) {
                try {
                    console.log('ðŸ” Traitement du match...');

                    // Trouver le joueur dans le match
                    let playerTeam = null;
                    let playerFound = false;

                    if (match.players && Array.isArray(match.players.all_players)) {
                        for (const player of match.players.all_players) {
                            if (player.name === this.playerName && player.tag === this.playerTag) {
                                playerTeam = player.team;
                                playerFound = true;
                                console.log(`ðŸ‘¤ Joueur trouvÃ© dans l'Ã©quipe: ${playerTeam}`);
                                break;
                            }
                        }
                    }

                    if (!playerFound) {
                        console.log('âŒ Joueur non trouvÃ© dans le match');
                        return;
                    }

                    // DÃ©terminer le rÃ©sultat
                    if (match.teams && match.teams.red && match.teams.blue) {
                        const redTeam = match.teams.red;
                        const blueTeam = match.teams.blue;

                        let playerWon = false;

                        if (playerTeam === 'Red') {
                            playerWon = redTeam.has_won;
                        } else if (playerTeam === 'Blue') {
                            playerWon = blueTeam.has_won;
                        }

                        console.log(`ðŸ† RÃ©sultat: ${playerWon ? 'VICTOIRE' : 'DÃ‰FAITE'} (Ã‰quipe: ${playerTeam})`);

                        // Mettre Ã  jour le score
                        if (playerWon) {
                            this.wins++;
                            console.log(`âœ… Victoire! Score: ${this.wins}W/${this.losses}L`);
                        } else {
                            this.losses++;
                            console.log(`âŒ DÃ©faite! Score: ${this.wins}W/${this.losses}L`);
                        }

                        this.updateDisplay();
                        this.saveScoreToStorage();
                    } else {
                        console.log('âŒ DonnÃ©es d\'Ã©quipe manquantes dans le match');
                    }
                } catch (error) {
                    console.error('âŒ Erreur lors du traitement du match:', error);
                }
            }

            startMatchCheckInterval() {
                // VÃ©rifier les matchs toutes les 15 secondes
                this.matchCheckInterval = setInterval(() => {
                    this.checkMatchData();
                }, 15000);

                console.log('â° VÃ©rification des matchs programmÃ©e toutes les 15 secondes');
            }

            stopMatchCheckInterval() {
                if (this.matchCheckInterval) {
                    clearInterval(this.matchCheckInterval);
                    this.matchCheckInterval = null;
                    console.log('â¸ï¸ VÃ©rification des matchs arrÃªtÃ©e');
                }
            }

            connectToTwitchChat() {
                console.log('ðŸ”— Connexion au chat Twitch pour Ã©couter les commandes...');

                const socket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');

                socket.onopen = () => {
                    console.log('âœ… ConnectÃ© au chat Twitch de fugu_fps');
                    socket.send('CAP REQ :twitch.tv/tags twitch.tv/commands');
                    socket.send('PASS SCHMOOPIIE');
                    socket.send('NICK justinfan12345');
                    socket.send('JOIN #fugu_fps');
                };

                socket.onmessage = (event) => {
                    const message = event.data;

                    if (message.startsWith('PING')) {
                        socket.send('PONG :tmi.twitch.tv');
                        return;
                    }

                    this.parseChatMessage(message);
                };

                socket.onerror = (error) => {
                    console.error('âŒ Erreur de connexion au chat Twitch:', error);
                };

                socket.onclose = () => {
                    console.log('ðŸ”Œ Connexion au chat Twitch fermÃ©e');
                    setTimeout(() => {
                        console.log('ðŸ”„ Tentative de reconnexion...');
                        this.connectToTwitchChat();
                    }, 10000);
                };
            }

            parseChatMessage(rawMessage) {
                try {
                    if (!rawMessage.includes('PRIVMSG #fugu_fps :')) {
                        return;
                    }

                    const tagsMatch = rawMessage.match(/@([^ ]+) /);
                    let userTags = '';
                    if (tagsMatch) {
                        userTags = tagsMatch[1];
                    }

                    const usernameMatch = rawMessage.match(/:(.*?)!/);
                    const messageMatch = rawMessage.match(/PRIVMSG #fugu_fps :(.+)$/);

                    if (usernameMatch && messageMatch) {
                        const username = usernameMatch[1];
                        const message = messageMatch[1].trim();

                        this.handleChatCommand(username, message, userTags);
                    }
                } catch (error) {
                    console.error('âŒ Erreur lors du parsing du message:', error);
                }
            }

            handleChatCommand(username, message, userTags) {
                const lowerMessage = message.toLowerCase();
                const lowerUsername = username.toLowerCase();

                if (lowerMessage === '!matchrefresh' || lowerMessage === '!matchreload') {
                    if (this.hasPermission(username, userTags)) {
                        console.log(`ðŸ”„ Commande ${message} reÃ§ue de ${username} - Rechargement forcÃ© des donnÃ©es...`);

                        // Forcer la vÃ©rification des matchs
                        this.checkMatchData();
                    } else {
                        console.log(`âŒ ${username} a tentÃ© d'utiliser ${message} sans permission`);
                    }
                    return;
                }

                if (lowerMessage === '!hidematches') {
                    if (this.hasPermission(username, userTags)) {
                        console.log(`ðŸ™ˆ Commande !hidematches reÃ§ue de ${username} - Masquage de l'overlay...`);
                        this.isVisible = false;
                        this.saveVisibilityToStorage();
                        this.displayOverlay();
                    } else {
                        console.log(`âŒ ${username} a tentÃ© d'utiliser !hidematches sans permission`);
                    }
                    return;
                }

                if (lowerMessage === '!showmatches') {
                    if (this.hasPermission(username, userTags)) {
                        console.log(`ðŸ‘ï¸ Commande !showmatches reÃ§ue de ${username} - Affichage de l'overlay...`);
                        this.isVisible = true;
                        this.saveVisibilityToStorage();
                        this.displayOverlay();
                    } else {
                        console.log(`âŒ ${username} a tentÃ© d'utiliser !showmatches sans permission`);
                    }
                    return;
                }
            }

            hasPermission(username, userTags) {
                const lowerUsername = username.toLowerCase();

                // VÃ©rifier la blacklist
                if (this.blacklist.includes(lowerUsername)) {
                    return false;
                }

                // VÃ©rifier les modÃ©rateurs
                if (this.moderators.includes(lowerUsername)) {
                    return true;
                }

                // VÃ©rifier les VIPs
                if (this.vips.includes(lowerUsername)) {
                    return true;
                }

                return false;
            }

            // MÃ©thode de test pour vÃ©rifier les permissions (Ã  appeler depuis la console)
            testCommandPermissions(username) {
                console.log(`ðŸ§ª Test des permissions pour: ${username}`);
                console.log(`   ðŸ‘® ModÃ©rateur: ${this.moderators.includes(username.toLowerCase())}`);
                console.log(`   ðŸ‘‘ VIP: ${this.vips.includes(username.toLowerCase())}`);
                console.log(`   ðŸš« BlacklistÃ©: ${this.blacklist.includes(username.toLowerCase())}`);
                console.log(`   âœ… Peut utiliser les commandes: ${this.hasPermission(username, '')}`);
            }

            // MÃ©thode de test pour dÃ©clencher un refresh manuellement
            testRefresh() {
                console.log('ðŸ§ª Test de refresh manuel des donnÃ©es de match...');
                this.checkMatchData();
            }

            // MÃ©thode de test pour masquer l'overlay
            testHide() {
                console.log('ðŸ§ª Test de masquage de l\'overlay...');
                this.isVisible = false;
                this.saveVisibilityToStorage();
                this.displayOverlay();
            }

            // MÃ©thode de test pour afficher l'overlay
            testShow() {
                console.log('ðŸ§ª Test d\'affichage de l\'overlay...');
                this.isVisible = true;
                this.saveVisibilityToStorage();
                this.displayOverlay();
            }

            // MÃ©thode pour rÃ©initialiser le score (pour les tests)
            resetScore() {
                this.wins = 0;
                this.losses = 0;
                this.processedMatches.clear();
                this.updateDisplay();
                this.saveScoreToStorage();
                this.saveProcessedMatchesToStorage();
                console.log('ðŸ”„ Score rÃ©initialisÃ© Ã  0W/0L');
            }

            // MÃ©thode de test pour effacer les matchs traitÃ©s (pour les tests)
            clearProcessedMatches() {
                this.processedMatches.clear();
                this.saveProcessedMatchesToStorage();
                console.log('ðŸ§¹ Matchs traitÃ©s effacÃ©s');
            }

            // MÃ©thode de test pour afficher le nombre de matchs traitÃ©s (pour les tests)
            showProcessedMatchesCount() {
                console.log(`ðŸ“Š Nombre de matchs traitÃ©s: ${this.processedMatches.size}`);
                console.log('ðŸ“‹ Match IDs traitÃ©s:', Array.from(this.processedMatches));
            }

            // MÃ©thode de test pour simuler le stream hors ligne
            testStreamOffline() {
                console.log('ðŸ§ª Test: Simulation du stream hors ligne...');
                const wasLive = this.isLive;
                this.isLive = false;

                if (wasLive) {
                    console.log('ðŸ”„ Score rÃ©initialisÃ© Ã  0W/0L (stream hors ligne simulÃ©)');
                    this.wins = 0;
                    this.losses = 0;
                    this.updateDisplay();
                    this.saveScoreToStorage();
                    this.stopMatchCheckInterval();
                }
            }

            // MÃ©thode de test pour simuler le stream en ligne
            testStreamOnline() {
                console.log('ðŸ§ª Test: Simulation du stream en ligne...');
                const wasLive = this.isLive;
                this.isLive = true;

                if (!wasLive) {
                    console.log('ðŸ”„ Stream remis en ligne simulÃ©, reprise de la vÃ©rification des matchs');
                    this.startMatchCheckInterval();
                }
            }
        }

        // Initialiser l'overlay quand la page est chargÃ©e
        document.addEventListener('DOMContentLoaded', () => {
            new MatchOverlay();
        });
    </script>
</body>
</html>
