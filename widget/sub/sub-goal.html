<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sub Goal Widget</title>
    <style>
        body {
            background: transparent;
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Arial, sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #subGoalDisplay {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            text-shadow:
                -2px -2px 0 #000,
                2px -2px 0 #000,
                -2px 2px 0 #000,
                2px 2px 0 #000,
                0px 2px 0 #000,
                2px 0px 0 #000,
                0px -2px 0 #000,
                -2px 0px 0 #000;
            white-space: nowrap;
            transition: transform 0.5s ease-in-out;
        }
    </style>
</head>
<body>
    <div id="subGoalDisplay">0 / 100 sub goal 1</div>

    <script>
                // Load goals from local file or URL parameters
        async function loadGoals() {
            try {
                // Try to load from local file first
                const response = await fetch('goals.txt');
                if (response.ok) {
                    const text = await response.text();
                    const lines = text.trim().split('\n');
                    const goals = [];

                    for (const line of lines) {
                        const parts = line.split(' ');
                        if (parts.length >= 3) {
                            const goalNumber = parts[0];
                            const currentCount = parseInt(parts[1].split('/')[0]) || 0;
                            const targetCount = parseInt(parts[1].split('/')[1]) || 0;
                            const description = parts.slice(2).join(' ');

                            goals.push({
                                count: targetCount,
                                desc: description,
                                current: currentCount
                            });
                        }
                    }

                    if (goals.length > 0) {
                        console.log('Loaded goals from file:', goals);
                        return goals;
                    }
                }
            } catch (error) {
                console.log('Could not load goals.txt, trying URL parameters...');
            }

            // Fallback to URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const goals = [];

            let i = 1;
            while (true) {
                const goalCount = urlParams.get(`goal${i}`);
                const goalTitle = urlParams.get(`titre${i}`);

                if (goalCount && goalTitle) {
                    goals.push({
                        count: parseInt(goalCount),
                        desc: goalTitle,
                        current: 0
                    });
                    i++;
                } else {
                    break;
                }
            }

            // If no goals found anywhere, use defaults
            if (goals.length === 0) {
                goals.push(
                    { count: 100, desc: 'sub goal 1', current: 0 },
                    { count: 200, desc: 'sub goal 2', current: 0 },
                    { count: 300, desc: 'sub goal 3', current: 0 }
                );
            }

            return goals;
        }

        let subGoals = [];

        const CHANNEL_NAME = '6899e94be4d575060dde1422'; // YukiBloo's channel ID

                // Get JWT token from URL parameters
        function getUrlParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }

        const JWT_TOKEN = getUrlParameter('token') || 'YOUR_JWT_TOKEN';

        // Twitch API configuration
        const TWITCH_CLIENT_ID = getUrlParameter('twitch_client_id') || 'YOUR_TWITCH_CLIENT_ID';
        const TWITCH_CLIENT_SECRET = getUrlParameter('twitch_client_secret') || 'YOUR_TWITCH_CLIENT_SECRET';
        const TWITCH_CHANNEL_NAME = 'yukibloo'; // Twitch username (lowercase)

        let twitchAccessToken = null;
        let lastSubCount = 0;
        let twitchUpdateInterval = null;

        let currentSubCount = 0;
        let currentGoalIndex = 0;
        let isAnimating = false;

        const display = document.getElementById('subGoalDisplay');

        function updateDisplay() {
            if (currentGoalIndex >= subGoals.length) {
                const lastGoal = subGoals[subGoals.length - 1];
                display.innerHTML = `${currentSubCount} / <span class="goal-completed">${lastGoal.count}</span> ${lastGoal.desc}`;
            } else {
                const goal = subGoals[currentGoalIndex];
                if (currentSubCount >= goal.count) {
                    display.innerHTML = `${currentSubCount} / <span class="goal-completed">${goal.count}</span> ${goal.desc}`;
                } else {
                    display.innerHTML = `${currentSubCount} / ${goal.count} ${goal.desc}`;
                }
            }
        }

        function createStars() {
            const starsContainer = document.getElementById('starsContainer');
            const numStars = 8;

            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.textContent = 'â˜…';

                star.style.left = Math.random() * 300 + 'px';
                star.style.top = Math.random() * 60 + 10 + 'px';

                star.style.animationDelay = Math.random() * 0.5 + 's';

                starsContainer.appendChild(star);


                setTimeout(() => {
                    if (star.parentNode) {
                        star.parentNode.removeChild(star);
                    }
                }, 2500);
            }
        }

        function showGoalCompleted() {
            display.classList.add('goal-completed');

            setTimeout(() => {
                display.classList.remove('goal-completed');
            }, 1000);
        }
        function slideToNextGoal() {
            if (isAnimating) return;
            isAnimating = true;

            display.style.transform = 'translateX(-100vw)';

            setTimeout(() => {
                updateDisplay();

                display.style.transition = 'none';
                display.style.transform = 'translateX(100vw)';

                setTimeout(() => {
                    display.style.transition = 'transform 0.5s ease-in-out';
                    display.style.transform = 'translateX(0)';

                    setTimeout(() => {
                        isAnimating = false;
                    }, 500);
                }, 50);
            }, 500);
        }

        function checkGoalProgress(newSubCount) {
            const oldSubCount = currentSubCount;
            currentSubCount = newSubCount;

            while (currentGoalIndex < subGoals.length && currentSubCount >= subGoals[currentGoalIndex].count) {
                if (currentGoalIndex === subGoals.length - 1) {
                    updateDisplay();
                    return;
                }

                currentGoalIndex++;
                slideToNextGoal();
                return;
            }

            while (currentGoalIndex > 0 && currentSubCount < subGoals[currentGoalIndex - 1].count) {
                currentGoalIndex--;
                slideToNextGoal();
                return;
            }

            updateDisplay();
        }

        function connectStreamElements() {
            if (CHANNEL_NAME === 'YOUR_CHANNEL_NAME' || JWT_TOKEN === 'YOUR_JWT_TOKEN' || !JWT_TOKEN) {
                console.log('Please configure CHANNEL_NAME and JWT_TOKEN');
                startTestSimulation();
                return;
            }

            const socket = new WebSocket('wss://realtime.streamelements.com/socket.io/?EIO=3&transport=websocket');

            socket.onopen = function() {
                console.log('Connected to StreamElements');

                socket.send('42["authenticate",{"method":"jwt","token":"' + JWT_TOKEN + '"}]');
            };

            socket.onmessage = function(event) {
                const data = event.data;
                console.log('Received message:', data);

                if (data.startsWith('42["authenticated"')) {
                    console.log('Authenticated with StreamElements');
                    console.log('Joining channel:', CHANNEL_NAME);

                    socket.send('42["join-channel",{"channel":"' + CHANNEL_NAME + '"}]');
                }

                if (data.startsWith('42["event"')) {
                    try {
                        const eventData = JSON.parse(data.substring(2));
                        const event = eventData[1];
                        console.log('Event received:', event);

                        if (event.type === 'subscriber') {
                            console.log('New subscriber!', event);
                            checkGoalProgress(currentSubCount + 1);
                        }
                    } catch (e) {
                        console.error('Error parsing event:', e);
                    }
                }
            };

            socket.onclose = function() {
                console.log('Disconnected from StreamElements');
                setTimeout(connectStreamElements, 5000);
            };

            socket.onerror = function(error) {
                console.error('StreamElements connection error:', error);
            };
        }

                                // Get Twitch access token (client credentials - limited scope)
        async function getTwitchAccessToken() {
            try {
                const response = await fetch('https://id.twitch.tv/oauth2/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: `client_id=${TWITCH_CLIENT_ID}&client_secret=${TWITCH_CLIENT_SECRET}&grant_type=client_credentials`
                });

                if (response.ok) {
                    const data = await response.json();
                    twitchAccessToken = data.access_token;
                    console.log('Got Twitch access token (limited scope)');
                    return true;
                } else {
                    console.log('Failed to get Twitch access token:', response.status);
                    return false;
                }
            } catch (error) {
                console.error('Error getting Twitch access token:', error);
                return false;
            }
        }

                // Get current sub count from Twitch API (using client credentials - limited data)
        async function getCurrentSubCountFromTwitch() {
            if (!twitchAccessToken) {
                console.log('No Twitch access token, trying to get one...');
                const success = await getTwitchAccessToken();
                if (!success) return;
            }

            try {
                // Get basic channel info (this works with client credentials)
                const userResponse = await fetch(`https://api.twitch.tv/helix/users?login=${TWITCH_CHANNEL_NAME}`, {
                    headers: {
                        'Client-ID': TWITCH_CLIENT_ID,
                        'Authorization': `Bearer ${twitchAccessToken}`
                    }
                });

                if (userResponse.ok) {
                    const userData = await userResponse.json();
                    if (userData.data && userData.data.length > 0) {
                        const broadcasterId = userData.data[0].id;
                        console.log('Got broadcaster ID:', broadcasterId);

                        // Try to get channel info (might have some stats)
                        const channelResponse = await fetch(`https://api.twitch.tv/helix/channels?broadcaster_id=${broadcasterId}`, {
                            headers: {
                                'Client-ID': TWITCH_CLIENT_ID,
                                'Authorization': `Bearer ${twitchAccessToken}`
                            }
                        });

                        if (channelResponse.ok) {
                            const channelData = await channelResponse.json();
                            console.log('Channel data:', channelData);

                            // Note: Client credentials can't read subscription counts
                            // We'll rely on StreamElements for real-time updates
                            console.log('Twitch API: Client credentials limited - using StreamElements for sub count');
                        } else {
                            console.log('Failed to get channel from Twitch:', channelResponse.status);
                        }
                    }
                } else {
                    console.log('Failed to get user from Twitch:', userResponse.status);
                }
            } catch (error) {
                console.error('Error getting data from Twitch:', error);
            }
        }

        // Start Twitch API updates (less frequent since we can't get sub counts)
        function startTwitchUpdates() {
            if (TWITCH_CLIENT_ID !== 'YOUR_TWITCH_CLIENT_ID' && TWITCH_CLIENT_SECRET !== 'YOUR_TWITCH_CLIENT_SECRET') {
                console.log('Starting Twitch API updates every 5 minutes (limited scope)...');
                getCurrentSubCountFromTwitch(); // Get initial data
                twitchUpdateInterval = setInterval(getCurrentSubCountFromTwitch, 300000); // Every 5 minutes
            } else {
                console.log('Twitch API not configured, skipping Twitch updates');
            }
        }

        // Function to manually set initial sub count (since we can't get it from Twitch API)
        function setInitialSubCount() {
            // You can set this manually or get it from YukiBloo
            const initialCount = 0; // Change this to the current sub count
            console.log('Setting initial sub count to:', initialCount);
            checkGoalProgress(initialCount);
        }

        function startTestSimulation() {
            console.log('Starting test simulation - configure StreamElements to disable this');

            setInterval(() => {
                if (currentSubCount < 350) {
                    const increment = Math.floor(Math.random() * 5) + 1;
                    checkGoalProgress(currentSubCount + increment);
                }
            }, 3000);

            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowUp') {
                    checkGoalProgress(currentSubCount + 10);
                } else if (e.key === 'ArrowDown' && currentSubCount > 0) {
                    checkGoalProgress(Math.max(0, currentSubCount - 10));
                } else if (e.key === 'Enter') {
                    // Set a specific number for testing
                    const newCount = prompt('Enter sub count for testing:');
                    if (newCount && !isNaN(newCount)) {
                        checkGoalProgress(parseInt(newCount));
                    }
                }
            });
        }

                async function init() {
            // Load goals first
            subGoals = await loadGoals();
            console.log('Loaded goals:', subGoals);

            updateDisplay();

            // Set initial sub count manually
            setInitialSubCount();

            // Start Twitch API updates (less frequent since we can't get sub counts)
            startTwitchUpdates();

            // Connect to StreamElements for real-time events
            if (CHANNEL_NAME !== 'YOUR_CHANNEL_NAME' && JWT_TOKEN !== 'YOUR_JWT_TOKEN' && JWT_TOKEN) {
                console.log('Connecting to StreamElements with token:', JWT_TOKEN.substring(0, 20) + '...');
                connectStreamElements();
            } else {
                console.log('Starting test simulation - no valid StreamElements token found');
                startTestSimulation();
            }
        }

        window.onload = init;
    </script>
</body>
</html>