<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Widget Streamlabs</title>
    <!--
    ========================================
    COMMANDES DE CHAT DISPONIBLES
    ========================================

    üîÑ !chatreload  - Recharge la page (Mod√©rateurs + VIPs uniquement)
    üîÑ !chatrefresh - Recharge la page (Mod√©rateurs + VIPs uniquement)

    üëÆ MOD√âRATEURS AUTORIS√âS:
    fugu_fps, wizebot, wzbot, emmamachou, gamlno, d3vilsfr,
    pogo__fps, babouille__, spoutnik_le_puant, z4apox, kudji__,
    kc_biolxzy, silaaaxe, streamelements, nutelloush, mustee___,
    ze1sh, vincent_maes12, dragonk_fps, chloedsx, maeniiaaa,
    g4li_fps, xiress_gp, prodigymarketing, chaima_2808,
    lea_ackermann, darkoootv

    üëë VIPS AUTORIS√âS:
    sc0rpio74890

    üß™ TESTS (Console):
    window.chatWidget.testCommandPermissions('username')
    window.chatWidget.testReload()
    ========================================
    -->
    <style>
        @font-face {
            font-family: 'Sea Regular Fugu';
            src: url('https://raw.githubusercontent.com/scorpio74890-alt/test-twitch/main/police/sea-regular-fugu.otf') format('opentype'),
                 url('police/sea-regular-fugu.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        /* Test de chargement de police */
        .font-test {
            font-family: 'Sea Regular Fugu', monospace;
            position: absolute;
            left: -9999px;
            font-size: 72px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Sea Regular Fugu', 'Comic Sans MS', 'Trebuchet MS', 'Arial Black', Arial, sans-serif;
            background: transparent;
            color: #ffffff;
            overflow: hidden;
        }

        #chat-container {
            height: 100vh;
            width: 100%;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: 10px;
            overflow: hidden;
        }

        .chat-message {
            margin-bottom: 10px;
            display: block;
            animation: slideIn 0.3s ease-out;
            opacity: 0;
            transform: translateX(-20px);
            animation-fill-mode: forwards;
        }

        .username {
            font-weight: bold;
            color: #00ff88;
            display: inline;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 28px;
            line-height: 32px; /* Alignement avec la hauteur des badges */
            vertical-align: middle;
        }

        .message-content {
            display: inline;
            word-wrap: break-word;
            word-break: break-word;
            line-height: 1.5;
            font-size: 28px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .separator {
            margin-right: 5px;
            font-weight: bold;
            color: #ffffff;
            font-size: 28px;
        }

        .badge-display {
            margin-right: 5px;
            font-size: 28px;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            height: 32px; /* Hauteur fixe pour aligner avec le username */
            vertical-align: middle;
        }

        .badge-image {
            width: 28px; /* Badges plus grands */
            height: 28px; /* Badges plus grands */
            display: inline-block;
            vertical-align: middle;
            object-fit: contain; /* Garde les proportions */
        }

        .emote-7tv {
            max-height: 28px;
            height: auto;
            max-width: 56px; /* Permet aux emotes larges d'√™tre plus grandes */
            width: auto;
            display: inline-block;
            vertical-align: middle;
            margin: 0 2px;
            object-fit: contain; /* Garde les proportions */
        }

        .emote-twitch {
            width: 28px;
            height: 28px;
            display: inline-block;
            vertical-align: middle;
            margin: 0 2px;
        }

        /* Animation pour l'arriv√©e des messages */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Couleurs diff√©rentes pour les pseudos */
        .username.color-1 { color: #ff6b6b; }
        .username.color-2 { color: #4ecdc4; }
        .username.color-3 { color: #45b7d1; }
        .username.color-4 { color: #96ceb4; }
        .username.color-5 { color: #ffeaa7; }
        .username.color-6 { color: #dda0dd; }
        .username.color-7 { color: #98d8c8; }
        .username.color-8 { color: #f7dc6f; }
        .username.color-9 { color: #bb8fce; }
        .username.color-10 { color: #85c1e9; }

        /* Style pour les messages de mod√©rateurs */
        .moderator {
            color: #00ff00 !important;
        }

        /* Style pour les messages VIP */
        .vip {
            color: #ff69b4 !important;
        }

        /* Style pour les messages de subscribers */
        .subscriber {
            color: #9146ff !important;
        }

        /* Style pour les messages de predictions */
        .predictions {
            color: #ff6600 !important;
        }

        /* Style pour les messages premium/prime */
        .premium {
            color: #9146ff !important;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .username, .separator {
                font-size: 28px;
            }

            .message-content {
                font-size: 26px;
            }

            #chat-container {
                padding: 5px;
            }

            .chat-message {
                margin-bottom: 8px;
            }
        }
    </style>
</head>
<body>
    <div id="chat-container"></div>

    <script>
        class ChatWidget {
            constructor() {
                this.container = document.getElementById('chat-container');
                this.maxMessages = 50; // Nombre maximum de messages affich√©s
                this.userColors = new Map(); // Pour garder une couleur consistente par utilisateur
                this.colorIndex = 0;
                this.colors = ['color-1', 'color-2', 'color-3', 'color-4', 'color-5',
                              'color-6', 'color-7', 'color-8', 'color-9', 'color-10'];

                // Cache pour les emotes 7TV
                this.sevenTVEmotes = new Map();
                this.globalSevenTVEmotes = new Map();

                // Cache pour les infos de cha√Ænes Twitch
                this.channelCache = new Map();

                // Chat partag√© - v√©rifier s'il y a d'autres participants
                this.sharedChatParticipants = new Set();
                this.isSharedChatActive = false;

                // Twitch API credentials pour les badges
                this.twitchClientId = 'gp762nuuoqcoxypju8c569th9wz7q5';
                this.twitchAuthToken = 'xrugdtwxy33q6p1dw0tg3nlkehj422';
                this.broadcasterId = '140846786';

                // Cache pour les badges Twitch
                this.badgeCache = new Map();
                this.globalBadgeCache = new Map();

                // Listes des mod√©rateurs et VIPs pour les commandes
                this.moderators = [
                    'fugu_fps', // Channel owner
                    'wizebot',
                    'wzbot',
                    'emmamachou',
                    'gamlno',
                    'd3vilsfr',
                    'pogo__fps',
                    'babouille__',
                    'spoutnik_le_puant',
                    'z4apox',
                    'kudji__',
                    'kc_biolxzy',
                    'silaaaxe',
                    'streamelements',
                    'nutelloush',
                    'mustee___',
                    'ze1sh',
                    'vincent_maes12',
                    'dragonk_fps',
                    'chloedsx',
                    'maeniiaaa',
                    'g4li_fps',
                    'xiress_gp',
                    'prodigymarketing',
                    'chaima_2808',
                    'lea_ackermann',
                    'darkoootv'
                ];

                this.vips = [
                    'sc0rpio74890',
                ];

                this.blacklist = [
                    'banned_user1',
                    'banned_user2'
                ];

                // Charger les badges Twitch
                this.loadTwitchBadges();

                // Charger les emotes 7TV
                this.loadSevenTVEmotes();

                // D√©marrer la v√©rification du chat partag√©
                this.startSharedChatCheck();

                // Connexion directe au chat Twitch de fugu_fps
                this.connectToTwitchChat();

                // Initialiser l'√©coute des √©v√©nements Streamlabs (en backup)
                this.initStreamlabsEvents();

                // Log des permissions de commandes
                console.log(`üîê Syst√®me de commandes initialis√©:`);
                console.log(`   üëÆ Mod√©rateurs: ${this.moderators.length} (${this.moderators.join(', ')})`);
                console.log(`   üëë VIPs: ${this.vips.length} (${this.vips.join(', ')})`);
                console.log(`   üö´ Blacklist: ${this.blacklist.length} (${this.blacklist.join(', ')})`);
            }

            async startSharedChatCheck() {
                console.log('üîÑ D√©marrage de la v√©rification du chat partag√©...');

                // V√©rifier imm√©diatement
                await this.checkSharedChat();

                // Puis v√©rifier toutes les 5 secondes
                setInterval(async () => {
                    await this.checkSharedChat();
                }, 5000);
            }

            async loadTwitchBadges() {
                try {
                    console.log('üè∑Ô∏è Chargement des badges Twitch...');

                    // Charger les badges de la cha√Æne
                    const channelResponse = await fetch(`https://api.twitch.tv/helix/chat/badges?broadcaster_id=${this.broadcasterId}`, {
                        headers: {
                            'Client-ID': this.twitchClientId,
                            'Authorization': `Bearer ${this.twitchAuthToken}`
                        }
                    });

                    if (channelResponse.ok) {
                        const channelData = await channelResponse.json();
                        console.log('üìä Badges de cha√Æne re√ßus:', channelData);

                        if (channelData.data) {
                            channelData.data.forEach(badge => {
                                this.badgeCache.set(badge.set_id, {
                                    id: badge.set_id,
                                    versions: badge.versions
                                });
                            });
                            console.log(`‚úÖ ${channelData.data.length} badges de cha√Æne charg√©s`);
                        }
                    } else {
                        console.error('‚ùå Erreur lors du chargement des badges de cha√Æne:', channelResponse.status);
                    }

                    // Charger les badges globaux
                    const globalResponse = await fetch('https://api.twitch.tv/helix/chat/badges/global', {
                        headers: {
                            'Client-ID': this.twitchClientId,
                            'Authorization': `Bearer ${this.twitchAuthToken}`
                        }
                    });

                    if (globalResponse.ok) {
                        const globalData = await globalResponse.json();
                        console.log('üìä Badges globaux re√ßus:', globalData);

                        if (globalData.data) {
                            globalData.data.forEach(badge => {
                                this.globalBadgeCache.set(badge.set_id, {
                                    id: badge.set_id,
                                    versions: badge.versions
                                });
                            });
                            console.log(`‚úÖ ${globalData.data.length} badges globaux charg√©s`);
                        }
                    } else {
                        console.error('‚ùå Erreur lors du chargement des badges globaux:', globalResponse.status);
                    }

                    console.log(`üè∑Ô∏è Total badges charg√©s: ${this.badgeCache.size} cha√Æne + ${this.globalBadgeCache.size} globaux`);
                } catch (error) {
                    console.error('üí• Erreur lors du chargement des badges Twitch:', error);
                }
            }

            getBadgeUrl(badgeType, version = '1') {
                try {
                    // Chercher d'abord dans les badges de cha√Æne
                    if (this.badgeCache.has(badgeType)) {
                        const badge = this.badgeCache.get(badgeType);
                        const badgeVersion = badge.versions.find(v => v.id === version) || badge.versions[0];
                        if (badgeVersion) {
                            return badgeVersion.image_url_1x;
                        }
                    }

                    // Chercher dans les badges globaux
                    if (this.globalBadgeCache.has(badgeType)) {
                        const badge = this.globalBadgeCache.get(badgeType);
                        const badgeVersion = badge.versions.find(v => v.id === version) || badge.versions[0];
                        if (badgeVersion) {
                            return badgeVersion.image_url_1x;
                        }
                    }

                    // Fallback: retourner null pour utiliser les images locales
                    return null;
                } catch (error) {
                    console.error('‚ùå Erreur lors de la r√©cup√©ration du badge:', error);
                    return null;
                }
            }

            // M√©thodes pour g√©rer les commandes de chat
            isModerator(username) {
                return this.moderators.includes(username.toLowerCase());
            }

            isVIP(username) {
                return this.vips.includes(username.toLowerCase());
            }

            isBlacklisted(username) {
                return this.blacklist.includes(username.toLowerCase());
            }

            hasCommandPermission(username) {
                const lowerUsername = username.toLowerCase();
                return this.isModerator(lowerUsername) || this.isVIP(lowerUsername);
            }

            handleChatCommand(username, message) {
                const lowerMessage = message.toLowerCase();
                const lowerUsername = username.toLowerCase();

                // V√©rifier si l'utilisateur est mod√©rateur ou VIP
                const hasPermission = this.isModerator(lowerUsername) || this.isVIP(lowerUsername);

                if (!hasPermission) {
                    console.log(`üö´ Commande refus√©e: ${username} n'a pas les permissions (${lowerMessage})`);
                    return false;
                }

                // Commandes de rechargement
                if (lowerMessage === '!chatreload' || lowerMessage === '!chatrefresh') {
                    console.log(`üîÑ Commande de rechargement ex√©cut√©e par ${username}: ${lowerMessage}`);
                    this.executePageReload();
                    return true;
                }

                return false;
            }

            executePageReload() {
                console.log('üîÑ Rechargement forc√© de la page...');

                // Option 1: Rechargement simple
                window.location.reload();

                // Option 2: Rechargement forc√© (ignorer le cache)
                // window.location.reload(true);

                // Option 3: Rechargement avec remplacement d'historique
                // window.location.replace(window.location.href);
            }

            // M√©thode de test pour v√©rifier les permissions (√† appeler depuis la console)
            testCommandPermissions(username) {
                console.log(`üß™ Test des permissions pour: ${username}`);
                console.log(`   üëÆ Mod√©rateur: ${this.isModerator(username)}`);
                console.log(`   üëë VIP: ${this.isVIP(username)}`);
                console.log(`   üö´ Blacklist√©: ${this.isBlacklisted(username)}`);
                console.log(`   ‚úÖ Peut utiliser les commandes: ${this.hasCommandPermission(username)}`);
            }

            // M√©thode de test pour d√©clencher un rechargement manuellement
            testReload() {
                console.log('üß™ Test de rechargement manuel...');
                this.executePageReload();
            }

            async checkSharedChat() {
                try {
                    console.log('üîç V√©rification du chat partag√©...');

                    const response = await fetch('https://api.twitch.tv/helix/shared_chat/session?broadcaster_id=140846786', {
                        headers: {
                            'Authorization': 'Bearer xrugdtwxy33q6p1dw0tg3nlkehj422',
                            'Client-Id': 'gp762nuuoqcoxypju8c569th9wz7q5'
                        }
                    });

                    if (!response.ok) {
                        console.log('‚ùå Erreur API chat partag√©:', response.status, response.statusText);
                        this.isSharedChatActive = false;
                        this.sharedChatParticipants.clear();
                        return;
                    }

                    const data = await response.json();
                    console.log('üìä R√©ponse API chat partag√©:', data);

                    if (data.data && data.data.length > 0) {
                        const session = data.data[0];
                        const participants = session.participants || [];

                        // Mettre √† jour la liste des participants
                        this.sharedChatParticipants.clear();
                        participants.forEach(p => this.sharedChatParticipants.add(p.broadcaster_id));

                        // Chat partag√© actif s'il y a plus d'un participant
                        this.isSharedChatActive = participants.length > 1;

                        console.log(`ü§ù Chat partag√©: ${this.isSharedChatActive ? 'ACTIF' : 'INACTIF'}`);
                        console.log(`üë• Participants: ${participants.length} (${Array.from(this.sharedChatParticipants).join(', ')})`);
                    } else {
                        console.log('‚ö™ Aucune session de chat partag√© trouv√©e');
                        this.isSharedChatActive = false;
                        this.sharedChatParticipants.clear();
                    }
                } catch (error) {
                    console.error('üí• Erreur lors de la v√©rification du chat partag√©:', error);
                    this.isSharedChatActive = false;
                    this.sharedChatParticipants.clear();
                }
            }

            connectToTwitchChat() {
                // Connexion WebSocket au chat IRC de Twitch
                const socket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');

                socket.onopen = () => {
                    console.log('Connect√© au chat Twitch de fugu_fps');
                    // Connexion anonyme au chat IRC de Twitch avec support des tags
                    socket.send('CAP REQ :twitch.tv/tags twitch.tv/commands');
                    socket.send('PASS SCHMOOPIIE');
                    socket.send('NICK justinfan12345'); // Utilisateur anonyme
                    socket.send('JOIN #fugu_fps'); // Rejoindre le canal de fugu_fps
                };

                socket.onmessage = (event) => {
                    const message = event.data;

                    // R√©pondre aux PING pour maintenir la connexion
                    if (message.startsWith('PING')) {
                        socket.send('PONG :tmi.twitch.tv');
                        return;
                    }

                    // Parser les messages de chat
                    this.parseIRCMessage(message);
                };

                socket.onerror = (error) => {
                    console.error('Erreur de connexion au chat Twitch:', error);
                };

                socket.onclose = () => {
                    console.log('Connexion au chat Twitch ferm√©e');
                    // Tentative de reconnexion apr√®s 5 secondes
                    setTimeout(() => {
                        console.log('Tentative de reconnexion...');
                        this.connectToTwitchChat();
                    }, 5000);
                };
            }

            async getChannelInfo(roomId) {
                if (this.channelCache.has(roomId)) {
                    return this.channelCache.get(roomId);
                }

                try {
                    console.log(`üè¢ R√©cup√©ration des infos pour room-id: ${roomId}`);
                    const res = await fetch(`https://api.twitch.tv/helix/users?id=${roomId}`, {
                        headers: {
                            'Client-ID': 'gp762nuuoqcoxypju8c569th9wz7q5',
                            'Authorization': 'Bearer m15k59400wm8tosv4499famn76qpr3'
                        }
                    });

                    if (!res.ok) {
                        console.error(`‚ùå Erreur API Twitch: ${res.status} ${res.statusText}`);
                        return null;
                    }

                    const json = await res.json();
                    console.log(`üìä R√©ponse API pour room-id ${roomId}:`, json);

                    if (json.data && json.data[0]) {
                        const channel = {
                            displayName: json.data[0].display_name,
                            login: json.data[0].login,
                            profileImage: json.data[0].profile_image_url
                        };
                        console.log(`‚úÖ Infos channel r√©cup√©r√©es:`, channel);
                        this.channelCache.set(roomId, channel);
                        return channel;
                    } else {
                        console.log(`‚ùå Aucune donn√©e trouv√©e pour room-id ${roomId}`);
                    }
                } catch (err) {
                    console.error('üí• Erreur lors de la r√©cup√©ration du channel info pour', roomId, err);
                }

                return null;
            }

            async parseIRCMessage(rawMessage) {
                // Parser les messages IRC de Twitch
                if (!rawMessage.includes('PRIVMSG')) return;

                try {
                    // Debug - afficher le message brut
                    console.log('Message brut IRC:', rawMessage);

                    // M√©thode am√©lior√©e pour extraire le nom d'utilisateur
                    // Chercher le pattern :username!username@username.tmi.twitch.tv
                    let username = 'Anonyme';

                    // Chercher le nom d'utilisateur juste avant "PRIVMSG"
                    const privmsgMatch = rawMessage.match(/\s:([^!]+)![^@]+@[^\.]+\.tmi\.twitch\.tv\s+PRIVMSG/);
                    if (privmsgMatch) {
                        username = privmsgMatch[1];
                    } else {
                        // M√©thode de fallback - chercher display-name dans les tags
                        const displayNameMatch = rawMessage.match(/display-name=([^;]*)/);
                        if (displayNameMatch && displayNameMatch[1]) {
                            username = displayNameMatch[1];
                        } else {
                            // Derni√®re m√©thode de fallback
                            const fallbackMatch = rawMessage.match(/:([^!]+)!/);
                            if (fallbackMatch) {
                                username = fallbackMatch[1];
                            }
                        }
                    }

                    // Extraire room-id pour identifier la cha√Æne d'origine
                    const roomIdMatch = rawMessage.match(/room-id=(\d+)/);
                    const roomId = roomIdMatch ? roomIdMatch[1] : null;
                    console.log(`üè† Room ID d√©tect√©: ${roomId}`);

                    // R√©cup√©rer les infos de la cha√Æne d'origine si disponible
                    let channelInfo = null;
                    if (roomId) {
                        channelInfo = await this.getChannelInfo(roomId);
                        if (channelInfo) {
                            console.log(`üè¢ Cha√Æne d'origine: ${channelInfo.displayName}`);
                        }
                    }

                    // Extraire les emotes Twitch depuis les tags IRC
                    let twitchEmotes = null;
                    const emotesMatch = rawMessage.match(/emotes=([^;]*)/);
                    if (emotesMatch && emotesMatch[1] && emotesMatch[1] !== '') {
                        twitchEmotes = emotesMatch[1];
                    }

                    // M√©thode plus simple pour extraire le message
                    // Chercher tout ce qui suit "PRIVMSG #fugu_fps :"
                    const privmsgIndex = rawMessage.indexOf('PRIVMSG #fugu_fps :');
                    let messageText = '';

                    if (privmsgIndex !== -1) {
                        messageText = rawMessage.substring(privmsgIndex + 'PRIVMSG #fugu_fps :'.length);
                        // Nettoyer les caract√®res de fin de ligne
                        messageText = messageText.replace(/\r\n?|\n/g, '');
                    }

                    // Extraire les badges depuis les tags IRC
                    const badges = this.extractBadges(rawMessage);

                    // Extraire la couleur personnalis√©e de l'utilisateur
                    console.log('üéØ Appel extractUserColor pour:', username);
                    let userColor = null;
                    try {
                        userColor = this.extractUserColor(rawMessage);
                        console.log('üéØ R√©sultat extractUserColor pour', username, ':', userColor);
                    } catch (error) {
                        console.error('‚ùå Erreur dans extractUserColor:', error);
                        userColor = null;
                    }

                    // Debug - afficher les messages pars√©s
                    console.log('Message pars√©:', { username, messageText, badges, twitchEmotes, userColor, channelInfo });

                    // V√©rifier et traiter les commandes de chat
                    if (messageText.trim() && (messageText.startsWith('!chatreload') || messageText.startsWith('!chatrefresh'))) {
                        const commandHandled = this.handleChatCommand(username, messageText);
                        if (commandHandled) {
                            console.log(`‚úÖ Commande trait√©e par ${username}: ${messageText}`);
                            return; // Ne pas afficher la commande dans le chat
                        }
                    }

                    // Ajouter le message au chat seulement s'il y a du texte
                    if (messageText.trim()) {
                        this.addMessage({
                            nick: username,
                            text: messageText,
                            badges: badges,
                            twitchEmotes: twitchEmotes,
                            userColor: userColor,
                            originChannel: channelInfo // facultatif si null
                        });
                    }
                } catch (error) {
                    console.error('Erreur lors du parsing du message:', error);
                }
            }

            async loadSevenTVEmotes() {
                try {
                    console.log('üöÄ D√©but du chargement des emotes 7TV...');

                    // Charger les emotes globales 7TV
                    console.log('üì° R√©cup√©ration des emotes globales...');
                    const globalResponse = await fetch('https://7tv.io/v3/emote-sets/global');
                    console.log('üåê R√©ponse globale:', globalResponse.status, globalResponse.statusText);

                    if (globalResponse.ok) {
                        const globalData = await globalResponse.json();
                        console.log('üì¶ Donn√©es globales re√ßues:', globalData);

                        if (globalData.emotes && Array.isArray(globalData.emotes)) {
                            console.log(`üìä Nombre d'emotes globales trouv√©es: ${globalData.emotes.length}`);

                            globalData.emotes.forEach((emote, index) => {
                                if (index < 5) {
                                    console.log(`üîç Emote globale ${index}:`, emote);
                                }

                                // Nouveau format 7TV - structure diff√©rente
                                if (emote.name && emote.data && emote.data.host && emote.data.host.files) {
                                    // Construire les URLs √† partir des fichiers
                                    const urls = emote.data.host.files.map(file => `//${emote.data.host.url}/${file.name}`);

                                    this.globalSevenTVEmotes.set(emote.name, {
                                        id: emote.id,
                                        name: emote.name,
                                        urls: urls
                                    });

                                    if (index < 5) {
                                        console.log(`‚úÖ Emote globale ${index} ajout√©e:`, emote.name, urls);
                                    }
                                } else {
                                    if (index < 5) {
                                        console.log(`‚ùå Emote globale ${index} incompl√®te:`, emote);
                                    }
                                }
                            });
                        } else {
                            console.log('‚ùå Pas d\'emotes dans la r√©ponse globale ou format incorrect');
                        }
                    } else {
                        console.error('‚ùå √âchec de r√©cup√©ration des emotes globales:', globalResponse.status);
                    }

                    // Charger les emotes sp√©cifiques au canal fugu_fps directement via l'ID du set
                    console.log('üì° R√©cup√©ration des emotes du canal fugu_fps via le set ID...');

                    const setResponse = await fetch('https://7tv.io/v3/emote-sets/01GEG2EPE80006SAE3KT92JGK5');
                    console.log('ÔøΩ R√©ponse set d\'emotes:', setResponse.status, setResponse.statusText);

                    if (setResponse.ok) {
                        const setData = await setResponse.json();
                        console.log('üì¶ Donn√©es du set re√ßues:', setData);

                        if (setData.emotes && Array.isArray(setData.emotes)) {
                            console.log(`üìä Nombre d'emotes du canal trouv√©es: ${setData.emotes.length}`);

                            setData.emotes.forEach((emote, index) => {
                                if (index < 10) {
                                    console.log(`üîç Emote canal ${index}:`, emote);
                                }

                                // Nouveau format 7TV - structure diff√©rente
                                if (emote.name && emote.data && emote.data.host && emote.data.host.files) {
                                    // Construire les URLs √† partir des fichiers
                                    const urls = emote.data.host.files.map(file => `//${emote.data.host.url}/${file.name}`);

                                    this.sevenTVEmotes.set(emote.name, {
                                        id: emote.id,
                                        name: emote.name,
                                        urls: urls
                                    });

                                    if (index < 10) {
                                        console.log(`‚úÖ Emote canal ${index} ajout√©e:`, emote.name, urls);
                                    }
                                } else {
                                    if (index < 10) {
                                        console.log(`‚ùå Emote canal ${index} incompl√®te:`, emote);
                                    }
                                }
                            });
                        } else {
                            console.log('‚ùå Pas d\'emotes dans la r√©ponse du set ou format incorrect');
                        }
                    } else {
                        console.error('‚ùå √âchec de r√©cup√©ration des emotes du set:', setResponse.status);
                    }

                    console.log(`‚úÖ 7TV emotes charg√©es: ${this.sevenTVEmotes.size} emotes du canal + ${this.globalSevenTVEmotes.size} emotes globales`);

                    // Debug - afficher toutes les emotes du canal pour v√©rifier
                    if (this.sevenTVEmotes.size > 0) {
                        console.log('üìã Toutes les emotes du canal fugu_fps:', Array.from(this.sevenTVEmotes.keys()).sort());
                    }
                    if (this.globalSevenTVEmotes.size > 0) {
                        console.log('üìã Exemples d\'emotes globales:', Array.from(this.globalSevenTVEmotes.keys()).slice(0, 20));
                    }

                    // V√©rifier sp√©cifiquement certaines emotes
                    const testEmotes = ['WHAT', 'LeaClassic', 'Kappa', 'KEKW', 'CDEC', 'EZ'];
                    testEmotes.forEach(emote => {
                        const inChannel = this.sevenTVEmotes.has(emote);
                        const inGlobal = this.globalSevenTVEmotes.has(emote);
                        console.log(`üîé Emote "${emote}" - Canal: ${inChannel}, Global: ${inGlobal}`);

                        // Afficher l'URL de l'emote si trouv√©e
                        if (inChannel) {
                            const emoteData = this.sevenTVEmotes.get(emote);
                            console.log(`üì∏ URL emote "${emote}":`, emoteData.urls);
                        } else if (inGlobal) {
                            const emoteData = this.globalSevenTVEmotes.get(emote);
                            console.log(`üì∏ URL emote "${emote}":`, emoteData.urls);
                        }
                    });

                } catch (error) {
                    console.error('üí• Erreur lors du chargement des emotes 7TV:', error);
                    console.error('üìç Stack trace:', error.stack);
                }
            }

            parseSevenTVEmotes(message) {
                if (!message) return message;

                console.log('üîç Parsing 7TV emotes pour:', message);

                // Diviser le message en mots et traiter chaque mot individuellement
                const words = message.split(/(\s+)/); // Garde les espaces dans le tableau
                console.log('üìù Mots d√©tect√©s:', words);

                for (let i = 0; i < words.length; i++) {
                    let word = words[i].trim();
                    if (!word) continue; // Ignorer les espaces vides

                    console.log(`üîé V√©rification du mot: "${word}"`);

                    let emoteFound = false;
                    let emoteData = null;

                    // Chercher dans les emotes du canal d'abord (priorit√©)
                    if (this.sevenTVEmotes.has(word)) {
                        emoteData = this.sevenTVEmotes.get(word);
                        emoteFound = true;
                        console.log(`‚úÖ Emote trouv√©e dans le canal: ${word}`, emoteData);
                    }
                    // Chercher dans les emotes globales si pas trouv√© dans le canal
                    else if (this.globalSevenTVEmotes.has(word)) {
                        emoteData = this.globalSevenTVEmotes.get(word);
                        emoteFound = true;
                        console.log(`‚úÖ Emote trouv√©e globalement: ${word}`, emoteData);
                    }

                    if (emoteFound && emoteData && emoteData.urls && Array.isArray(emoteData.urls)) {
                        // Chercher l'URL appropri√©e (priorit√© aux tailles plus grandes)
                        const imageUrl = emoteData.urls.find(url => url.includes('2x.webp')) ||
                                        emoteData.urls.find(url => url.includes('1x.webp')) ||
                                        emoteData.urls[0];

                        if (imageUrl) {
                            const fullUrl = imageUrl.startsWith('//') ? `https:${imageUrl}` : imageUrl;
                            const emoteImg = `<img class="emote-7tv" src="${fullUrl}" alt="${word}" title="${word}">`;
                            words[i] = words[i].replace(word, emoteImg);
                            console.log(`üé® Emote remplac√©e: "${word}" ‚Üí ${fullUrl}`);
                        } else {
                            console.log(`‚ùå Pas d'URL d'image valide pour l'emote ${word}`);
                        }
                    } else {
                        if (word.length > 2) { // √âviter le spam pour les petits mots
                            console.log(`‚ö™ Mot normal: "${word}"`);
                        }
                    }

                    // Debug sp√©cial pour LeaClassic
                    if (word === 'LeaClassic') {
                        console.log('üö® LeaClassic d√©tect√© ! Debug complet:');
                        console.log('Dans canal:', this.sevenTVEmotes.has('LeaClassic'));
                        console.log('Dans global:', this.globalSevenTVEmotes.has('LeaClassic'));

                        if (this.sevenTVEmotes.has('LeaClassic')) {
                            const emote = this.sevenTVEmotes.get('LeaClassic');
                            console.log('Donn√©es de l\'emote LeaClassic:', emote);
                        }

                        // Chercher des emotes similaires
                        const similarEmotes = [];
                        this.sevenTVEmotes.forEach((emote, name) => {
                            if (name.toLowerCase().includes('lea') || name.toLowerCase().includes('classic')) {
                                similarEmotes.push(name);
                            }
                        });
                        console.log('Emotes similaires trouv√©es:', similarEmotes);
                    }
                }

                const parsedMessage = words.join('');

                if (parsedMessage !== message) {
                    console.log('üèÅ Message apr√®s parsing emotes:', parsedMessage);
                }

                return parsedMessage;
            }

            parseTwitchEmotes(message, emoteData) {
                if (!message || !emoteData) return message;

                console.log('üü£ Parsing emotes Twitch pour:', message);
                console.log('üü£ Donn√©es emotes Twitch:', emoteData);

                let result = message;

                // Parser les emotes Twitch depuis les tags IRC
                // Format: emote_id:start_pos-end_pos,start_pos-end_pos/emote_id:start_pos-end_pos
                const emoteEntries = emoteData.split('/');

                // Collecter toutes les positions d'emotes pour les traiter en ordre inverse
                const emoteReplacements = [];

                emoteEntries.forEach(entry => {
                    const [emoteId, positions] = entry.split(':');
                    if (!emoteId || !positions) return;

                    const positionPairs = positions.split(',');
                    positionPairs.forEach(pair => {
                        const [start, end] = pair.split('-').map(Number);
                        if (isNaN(start) || isNaN(end)) return;

                        const emoteName = message.substring(start, end + 1);
                        emoteReplacements.push({
                            start,
                            end: end + 1,
                            emoteId,
                            emoteName
                        });
                    });
                });

                // Trier par position de fin en ordre d√©croissant pour remplacer de droite √† gauche
                emoteReplacements.sort((a, b) => b.start - a.start);

                // Remplacer les emotes
                emoteReplacements.forEach(replacement => {
                    const { start, end, emoteId, emoteName } = replacement;
                    const emoteUrl = `https://static-cdn.jtvnw.net/emoticons/v2/${emoteId}/default/dark/2.0`;
                    const emoteImg = `<img class="emote-twitch" src="${emoteUrl}" alt="${emoteName}" title="${emoteName}" style="width: 28px; height: 28px; vertical-align: middle; margin: 0 2px;">`;

                    result = result.substring(0, start) + emoteImg + result.substring(end);
                    console.log(`üü£ Emote Twitch remplac√©e: "${emoteName}" ‚Üí ${emoteUrl}`);
                });

                return result;
            }

            extractBadges(rawMessage) {
                const badges = {};

                // Extraire les badges depuis les tags IRC (format Twitch)
                if (rawMessage.includes('badges=')) {
                    const badgeMatch = rawMessage.match(/badges=([^;]*)/);
                    if (badgeMatch && badgeMatch[1]) {
                        const badgeList = badgeMatch[1].split(',');
                        badgeList.forEach(badge => {
                            const [type, version] = badge.split('/');
                            if (type === 'moderator') {
                                badges.moderator = true;
                                badges.moderatorVersion = version;
                            }
                            if (type === 'vip') {
                                badges.vip = true;
                                badges.vipVersion = version;
                            }
                            if (type === 'subscriber') {
                                badges.subscriber = true;
                                badges.subscriberVersion = version;
                            }
                            if (type === 'broadcaster') {
                                badges.broadcaster = true;
                                badges.broadcasterVersion = version;
                            }
                            if (type === 'predictions') {
                                badges.predictions = true;
                                badges.predictionsVersion = version;
                            }
                            if (type === 'bits') {
                                badges.bits = true;
                                badges.bitsVersion = version;
                            }
                            if (type === 'sub-gifter') {
                                badges.subGifter = true;
                                badges.subGifterVersion = version;
                            }
                            if (type === 'sub-gift-leader') {
                                badges.subGiftLeader = true;
                                badges.subGiftLeaderVersion = version;
                            }
                            if (type === 'bits-leader') {
                                badges.bitsLeader = true;
                                badges.bitsLeaderVersion = version;
                            }
                            if (type === 'clips-leader') {
                                badges.clipsLeader = true;
                                badges.clipsLeaderVersion = version;
                            }
                            if (type === 'premium') {
                                badges.premium = true;
                                badges.premiumVersion = version;
                            }
                            if (type === 'turbo') {
                                badges.turbo = true;
                                badges.turboVersion = version;
                            }
                            if (type === 'verified') {
                                badges.verified = true;
                                badges.verifiedVersion = version;
                            }
                            if (type === 'partner') {
                                badges.partner = true;
                                badges.partnerVersion = version;
                            }
                            if (type === 'prime') {
                                badges.prime = true;
                                badges.primeVersion = version;
                            }
                            if (type === 'no-audio' || type === 'no_audio') {
                                badges.noAudio = true;
                                badges.noAudioVersion = version;
                            }
                            if (type === 'no-video' || type === 'no_video') {
                                badges.noVideo = true;
                                badges.noVideoVersion = version;
                            }
                            if (type === 'dj') {
                                badges.dj = true;
                                badges.djVersion = version;
                            }
                            if (type === 'ambassador') {
                                badges.ambassador = true;
                                badges.ambassadorVersion = version;
                            }
                            if (type === 'anonymous-cheerer') {
                                badges.anonymousCheerer = true;
                                badges.anonymousCheererVersion = version;
                            }
                            if (type === 'artist-badge') {
                                badges.artist = true;
                                badges.artistVersion = version;
                            }
                            // Badges sp√©ciaux/√©v√©nements
                            if (type.includes('game-award') || type.includes('twitchcon') || type.includes('recap') || type.includes('zevent') || type.includes('pixel-heart') || type.includes('arcane') || type.includes('lol') || type.includes('rplace') || type.includes('glhf') || type.includes('glitchcon') || type.includes('share-the-love') || type.includes('subtember') || type.includes('raging-wolf') || type.includes('gone-bananas') || type.includes('speedons') || type.includes('elden-ring')) {
                                badges.special = true;
                                badges.specialType = type;
                                badges.specialVersion = version;
                            }
                        });
                    }
                }

                return badges;
            }

            extractUserColor(rawMessage) {
                // Extraire la couleur depuis les tags IRC (format: color=#FF4500)
                const colorMatch = rawMessage.match(/color=([^;]*)/);
                console.log('üîç Recherche de couleur dans:', rawMessage.substring(0, 200) + '...');
                console.log('üîç Match couleur trouv√©:', colorMatch);

                if (colorMatch) {
                    const color = colorMatch[1];
                    console.log('üé® Couleur brute extraite:', `"${color}" (longueur: ${color ? color.length : 0})`);

                    if (color && color !== '' && color.trim() !== '') {
                        // V√©rifier que c'est une couleur valide (commence par # et a 6 caract√®res hexad√©cimaux)
                        if (color.match(/^#[0-9A-Fa-f]{6}$/)) {
                            console.log(`‚úÖ Couleur utilisateur extraite valide: ${color}`);
                            return color;
                        } else {
                            console.log(`‚ùå Couleur invalide (format incorrect): "${color}"`);
                        }
                    } else {
                        console.log(`‚ùå Couleur vide d√©tect√©e: "${color}"`);
                    }
                } else {
                    console.log('‚ùå Aucun match trouv√© pour color= dans les tags');
                }

                // Si pas de couleur ou couleur invalide, retourner null pour utiliser le syst√®me de fallback
                console.log('‚ö™ Pas de couleur utilisateur valide, utilisation du syst√®me de fallback');
                return null;
            }

            initStreamlabsEvents() {
                // √âcouter les √©v√©nements de chat de Streamlabs OBS (en backup)
                window.addEventListener('onEventReceived', (obj) => {
                    if (obj.detail.event && obj.detail.event.type === 'message') {
                        // V√©rifier et traiter les commandes de chat
                        const eventData = obj.detail.event.data;
                        const username = eventData.nick || eventData.username || 'Utilisateur';
                        const messageText = eventData.text || eventData.message || '';

                        if (messageText.trim() && (messageText.startsWith('!chatreload') || messageText.startsWith('!chatrefresh'))) {
                            const commandHandled = this.handleChatCommand(username, messageText);
                            if (commandHandled) {
                                console.log(`‚úÖ Commande Streamlabs trait√©e par ${username}: ${messageText}`);
                                return; // Ne pas afficher la commande dans le chat
                            }
                        }

                        this.addMessage(eventData);
                    }
                });

                // Pour les tests avec StreamElements (alternative)
                window.addEventListener('onWidgetLoad', (obj) => {
                    console.log('Widget charg√© pour fugu_fps');
                });

                console.log('Widget de chat initialis√© pour fugu_fps');
            }

            getUserColor(username) {
                if (!this.userColors.has(username)) {
                    this.userColors.set(username, this.colors[this.colorIndex % this.colors.length]);
                    this.colorIndex++;
                }
                return this.userColors.get(username);
            }

            getUserBadgeClass(badges) {
                if (!badges) return '';

                if (badges.moderator) return 'moderator';
                if (badges.vip) return 'vip';
                if (badges.subscriber) return 'subscriber';
                if (badges.predictions) return 'predictions';
                if (badges.partner) return 'partner';
                if (badges.premium || badges.prime) return 'premium';

                return '';
            }

            cleanMessage(text) {
                // Nettoyer le message des caract√®res sp√©ciaux et balises (mais garder les emotes)
                // Supprimer les caract√®res de contr√¥le IRC (notamment \u0001 pour ACTION)
                return text
                    .replace(/\u0001ACTION\s*/g, '') // Supprimer \u0001ACTION au d√©but
                    .replace(/\u0001/g, '') // Supprimer tous les autres \u0001
                    .replace(/\r\n?|\n/g, '') // Supprimer les retours √† la ligne
                    .trim();
            }

            addMessage(data) {
                const messageElement = document.createElement('div');
                messageElement.className = 'chat-message';

                const username = data.nick || data.username || 'Utilisateur';
                let message = this.cleanMessage(data.text || data.message || '');

                // Parser les emotes Twitch en premier (priorit√© aux emotes natives)
                if (data.twitchEmotes) {
                    message = this.parseTwitchEmotes(message, data.twitchEmotes);
                }

                // Ensuite parser les emotes 7TV sur le texte restant
                message = this.parseSevenTVEmotes(message);

                // D√©terminer la couleur - priorit√© √† la couleur utilisateur
                let userColor = '';
                console.log(`üîç Debug couleur pour ${username}:`, {
                    userColorFromData: data.userColor,
                    hasUserColor: !!data.userColor
                });

                if (data.userColor) {
                    // Utiliser la couleur choisie par l'utilisateur
                    userColor = `style="color: ${data.userColor} !important;"`;
                    console.log(`üé® Utilisation de la couleur utilisateur: ${data.userColor} pour ${username}`);
                } else {
                    // Syst√®me de fallback avec couleurs pr√©d√©finies
                    userColor = `class="${this.getUserColor(username)}"`;
                    console.log(`üé≤ Utilisation de la couleur al√©atoire pour ${username}`);
                }

                const badgeClass = this.getUserBadgeClass(data.badges);

                // Cr√©er l'affichage des badges avec l'API Twitch et fallback local
                let badgeDisplay = '';
                if (data.badges) {
                    if (data.badges.broadcaster) {
                        const badgeUrl = this.getBadgeUrl('broadcaster', data.badges.broadcasterVersion);
                        if (badgeUrl) {
                            badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Broadcaster" title="Broadcaster">`;
                        } else {
                            // Fallback local
                            badgeDisplay += `<img class="badge-image" src="broadcaster.png" alt="Broadcaster" title="Broadcaster" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/5527c58c-fb7d-422d-b71b-f309dcb85cc1/1'">`;
                        }
                    }
                    if (data.badges.moderator) {
                        const badgeUrl = this.getBadgeUrl('moderator', data.badges.moderatorVersion);
                        if (badgeUrl) {
                            badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Moderator" title="Moderator">`;
                        } else {
                            // Fallback local
                            badgeDisplay += `<img class="badge-image" src="moderator.png" alt="Moderator" title="Moderator" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/3267646d-33f0-4b17-b3df-f923a41db1d0/1'">`;
                        }
                    }
                    if (data.badges.vip) {
                        const badgeUrl = this.getBadgeUrl('vip', data.badges.vipVersion);
                        if (badgeUrl) {
                            badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="VIP" title="VIP">`;
                        } else {
                            // Fallback local
                            badgeDisplay += `<img class="badge-image" src="vip.png" alt="VIP" title="VIP" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/b817aba4-fad8-49e2-b88a-7cc744dfa6ec/1'">`;
                        }
                    }
                    if (data.badges.subscriber) {
                        // Essayer d'abord l'API Twitch, puis fallback local
                        const subVersion = data.badges.subscriberVersion || '0';
                        const badgeUrl = this.getBadgeUrl('subscriber', subVersion);

                        if (badgeUrl) {
                            badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Subscriber ${subVersion}" title="Abonn√© ${subVersion} mois">`;
                        } else {
                            // Fallback local avec mapping des versions
                            let subBadgeFile = '';

                            // Mapper les versions aux noms de fichiers
                            switch(subVersion) {
                                case '0':
                                case '1':
                                    subBadgeFile = '1-mois.png';
                                    break;
                                case '2':
                                    subBadgeFile = '2-mois.png';
                                    break;
                                case '3':
                                    subBadgeFile = '3-mois.png';
                                    break;
                                case '6':
                                    subBadgeFile = '6-mois.png';
                                    break;
                                case '9':
                                    subBadgeFile = '9-mois.png';
                                    break;
                                case '12':
                                    subBadgeFile = '1-an.png';
                                    break;
                                case '18':
                                    subBadgeFile = '18-mois.png';
                                    break;
                                case '24':
                                    subBadgeFile = '2-ans.png';
                                    break;
                                default:
                                    // Pour les versions non pr√©vues, utiliser le badge 1 mois
                                    subBadgeFile = '1-mois.png';
                            }

                            badgeDisplay += `<img class="badge-image" src="${subBadgeFile}" alt="Subscriber ${subVersion}" title="Abonn√© ${subVersion} mois" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/5d9f2208-5dd8-11e7-8513-2ff4adfae661/1'">`;
                        }
                    }
                    if (data.badges.predictions) {
                        // Essayer d'abord l'API Twitch, puis fallback local
                        const predVersion = data.badges.predictionsVersion || '1';
                        const badgeUrl = this.getBadgeUrl('predictions', predVersion);

                        if (badgeUrl) {
                            badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Prediction ${predVersion}" title="Pr√©diction ${predVersion}">`;
                        } else {
                            // Fallback local avec mapping des versions
                            let predBadgeFile = '';

                            // Mapper les versions de pr√©diction aux fichiers
                            switch(predVersion) {
                                case '1':
                                case 'blue-1':
                                    predBadgeFile = 'predi-1.png';
                                    break;
                                case '2':
                                case 'pink-2':
                                    predBadgeFile = 'predi-2.png';
                                    break;
                                default:
                                    // Par d√©faut, utiliser predi-1
                                    predBadgeFile = 'predi-1.png';
                            }

                            badgeDisplay += `<img class="badge-image" src="${predBadgeFile}" alt="Prediction ${predVersion}" title="Pr√©diction ${predVersion}" onerror="this.src='https://static-cdn.jtvnw.net/badges/v1/73e8b446-2ca8-4dc7-912c-e35fc11d1c4e/1'">`;
                        }
                    }
                    // Badges Bits/Cheers
                    if (data.badges.bits) {
                        const bitsVersion = data.badges.bitsVersion || '1';
                        const badgeUrl = this.getBadgeUrl('bits', bitsVersion);

                        if (badgeUrl) {
                            badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Bits ${bitsVersion}" title="Bits ${bitsVersion}">`;
                        } else {
                            // Fallback local avec mapping des niveaux
                            let bitsBadgeFile = '';

                            // Mapper les niveaux de bits aux fichiers
                            if (parseInt(bitsVersion) >= 5000000) bitsBadgeFile = 'cheer-5000000.png';
                            else if (parseInt(bitsVersion) >= 4500000) bitsBadgeFile = 'cheer-4500000.png';
                            else if (parseInt(bitsVersion) >= 4000000) bitsBadgeFile = 'cheer-4000000.png';
                            else if (parseInt(bitsVersion) >= 3500000) bitsBadgeFile = 'cheer-3500000.png';
                            else if (parseInt(bitsVersion) >= 3000000) bitsBadgeFile = 'cheer-3000000.png';
                            else if (parseInt(bitsVersion) >= 2500000) bitsBadgeFile = 'cheer-2500000.png';
                            else if (parseInt(bitsVersion) >= 2000000) bitsBadgeFile = 'cheer-2000000.png';
                            else if (parseInt(bitsVersion) >= 1750000) bitsBadgeFile = 'cheer-1750000.png';
                            else if (parseInt(bitsVersion) >= 1500000) bitsBadgeFile = 'cheer-1500000.png';
                            else if (parseInt(bitsVersion) >= 1250000) bitsBadgeFile = 'cheer-1250000.png';
                            else if (parseInt(bitsVersion) >= 1000000) bitsBadgeFile = 'cheer-1000000.png';
                            else if (parseInt(bitsVersion) >= 900000) bitsBadgeFile = 'cheer-900000.png';
                            else if (parseInt(bitsVersion) >= 800000) bitsBadgeFile = 'cheer-800000.png';
                            else if (parseInt(bitsVersion) >= 750000) bitsBadgeFile = 'cheer-750000.png';
                            else if (parseInt(bitsVersion) >= 700000) bitsBadgeFile = 'cheer-700000.png';
                            else if (parseInt(bitsVersion) >= 600000) bitsBadgeFile = 'cheer-600000.png';
                            else if (parseInt(bitsVersion) >= 500000) bitsBadgeFile = 'cheer-500000.png';
                            else if (parseInt(bitsVersion) >= 400000) bitsBadgeFile = 'cheer-400000.png';
                            else if (parseInt(bitsVersion) >= 300000) bitsBadgeFile = 'cheer-300000.png';
                            else if (parseInt(bitsVersion) >= 200000) bitsBadgeFile = 'cheer-200000.png';
                            else if (parseInt(bitsVersion) >= 100000) bitsBadgeFile = 'cheer-100000.png';
                            else if (parseInt(bitsVersion) >= 50000) bitsBadgeFile = 'cheer-50000.png';
                            else if (parseInt(bitsVersion) >= 25000) bitsBadgeFile = 'cheer-25000.png';
                            else if (parseInt(bitsVersion) >= 10000) bitsBadgeFile = 'cheer-10000.png';
                            else if (parseInt(bitsVersion) >= 5000) bitsBadgeFile = 'cheer-5000.png';
                            else if (parseInt(bitsVersion) >= 1000) bitsBadgeFile = 'cheer-1000.png';
                            else if (parseInt(bitsVersion) >= 100) bitsBadgeFile = 'cheer-100.png';
                            else bitsBadgeFile = 'cheer-1.png';

                            badgeDisplay += `<img class="badge-image" src="${bitsBadgeFile}" alt="Bits ${bitsVersion}" title="Bits ${bitsVersion}">`;
                        }
                    }
                    // Badges Sub Gift Leader
                    if (data.badges.subGiftLeader) {
                        const giftLeaderVersion = data.badges.subGiftLeaderVersion || '1';
                        const badgeUrl = this.getBadgeUrl('sub-gift-leader', giftLeaderVersion);

                        if (badgeUrl) {
                            badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Gift Leader ${giftLeaderVersion}" title="Gift Leader ${giftLeaderVersion}">`;
                        } else {
                            // Fallback local
                            let gifterBadgeFile = '';

                            // Les gift leaders utilisent les fichiers gifter-1.png, gifter-2.png, gifter-3.png
                            switch(giftLeaderVersion) {
                                case '1':
                                    gifterBadgeFile = 'gifter-1.png';
                                    break;
                                case '2':
                                    gifterBadgeFile = 'gifter-2.png';
                                    break;
                                case '3':
                                    gifterBadgeFile = 'gifter-3.png';
                                    break;
                                default:
                                    // Par d√©faut, utiliser gifter-1.png pour niveau 1
                                    gifterBadgeFile = 'gifter-1.png';
                            }

                            badgeDisplay += `<img class="badge-image" src="${gifterBadgeFile}" alt="Gift Leader ${giftLeaderVersion}" title="Gift Leader ${giftLeaderVersion}">`;
                        }
                    }
                    // Badges Sub Gifter (utilise les fichiers sub-gift-X.png pour les quantit√©s)
                    else if (data.badges.subGifter) {
                        const giftVersion = data.badges.subGifterVersion || '1';
                        const badgeUrl = this.getBadgeUrl('sub-gifter', giftVersion);

                        if (badgeUrl) {
                            badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Sub Gifter ${giftVersion}" title="Sub Gifter ${giftVersion}">`;
                        } else {
                            // Fallback local
                            let giftBadgeFile = '';

                            if (parseInt(giftVersion) >= 5000) giftBadgeFile = 'sub-gift-5000.png';
                            else if (parseInt(giftVersion) >= 4000) giftBadgeFile = 'sub-gift-4000.png';
                            else if (parseInt(giftVersion) >= 3000) giftBadgeFile = 'sub-gift-3000.png';
                            else if (parseInt(giftVersion) >= 2000) giftBadgeFile = 'sub-gift-2000.png';
                            else if (parseInt(giftVersion) >= 1000) giftBadgeFile = 'sub-gift-1000.png';
                            else if (parseInt(giftVersion) >= 950) giftBadgeFile = 'sub-gift-950.png';
                            else if (parseInt(giftVersion) >= 900) giftBadgeFile = 'sub-gift-900.png';
                            else if (parseInt(giftVersion) >= 850) giftBadgeFile = 'sub-gift-850.png';
                            else if (parseInt(giftVersion) >= 800) giftBadgeFile = 'sub-gift-800.png';
                            else if (parseInt(giftVersion) >= 750) giftBadgeFile = 'sub-gift-750.png';
                            else if (parseInt(giftVersion) >= 700) giftBadgeFile = 'sub-gift-700.png';
                            else if (parseInt(giftVersion) >= 650) giftBadgeFile = 'sub-gift-650.png';
                            else if (parseInt(giftVersion) >= 600) giftBadgeFile = 'sub-gift-600.png';
                            else if (parseInt(giftVersion) >= 550) giftBadgeFile = 'sub-gift-550.png';
                            else if (parseInt(giftVersion) >= 500) giftBadgeFile = 'sub-gift-500.png';
                            else if (parseInt(giftVersion) >= 450) giftBadgeFile = 'sub-gift-450.png';
                            else if (parseInt(giftVersion) >= 400) giftBadgeFile = 'sub-gift-400.png';
                            else if (parseInt(giftVersion) >= 350) giftBadgeFile = 'sub-gift-350.png';
                            else if (parseInt(giftVersion) >= 300) giftBadgeFile = 'sub-gift-300.png';
                            else if (parseInt(giftVersion) >= 250) giftBadgeFile = 'sub-gift-250.png';
                            else if (parseInt(giftVersion) >= 200) giftBadgeFile = 'sub-gift-200.png';
                            else if (parseInt(giftVersion) >= 150) giftBadgeFile = 'sub-gift-150.png';
                            else if (parseInt(giftVersion) >= 100) giftBadgeFile = 'sub-gift-100.png';
                            else if (parseInt(giftVersion) >= 50) giftBadgeFile = 'sub-gift-50.png';
                            else if (parseInt(giftVersion) >= 25) giftBadgeFile = 'sub-gift-25.png';
                            else if (parseInt(giftVersion) >= 10) giftBadgeFile = 'sub-gift-10.png';
                            else if (parseInt(giftVersion) >= 5) giftBadgeFile = 'sub-gift-5.png';
                            else giftBadgeFile = 'sub-gift-1.png';

                            badgeDisplay += `<img class="badge-image" src="${giftBadgeFile}" alt="Sub Gifter ${giftVersion}" title="Sub Gifter ${giftVersion}">`;
                        }
                    }
                    // Badges Clips Leader
                    if (data.badges.clipsLeader) {
                        const clipsVersion = data.badges.clipsLeaderVersion || '1';
                        const badgeUrl = this.getBadgeUrl('clips-leader', clipsVersion);

                        if (badgeUrl) {
                            badgeDisplay += `<img class="badge-image" src="${badgeUrl}" alt="Clips Leader ${clipsVersion}" title="Clips Leader ${clipsVersion}">`;
                        } else {
                            // Fallback local
                            let clipsBadgeFile = '';

                            // Mapper les niveaux de clips aux fichiers
                            switch(clipsVersion) {
                                case '1':
                                    clipsBadgeFile = 'clipe-1.png';
                                    break;
                                case '2':
                                    clipsBadgeFile = 'clipe-2.png';
                                    break;
                                case '3':
                                    clipsBadgeFile = 'clipe-3.png';
                                    break;
                                default:
                                    // Par d√©faut, utiliser clipe-1
                                    clipsBadgeFile = 'clipe-1.png';
                            }

                            badgeDisplay += `<img class="badge-image" src="${clipsBadgeFile}" alt="Clips Leader ${clipsVersion}" title="Clips Leader ${clipsVersion}">`;
                        }
                    }
                    // Badge Prime/Premium
                    if (data.badges.prime || data.badges.premium) {
                        badgeDisplay += `<img class="badge-image" src="prime.png" alt="Prime" title="Prime Gaming">`;
                    }
                    // Badge Turbo
                    if (data.badges.turbo) {
                        badgeDisplay += `<img class="badge-image" src="turbo.png" alt="Turbo" title="Turbo">`;
                    }
                    // Badge Verified
                    if (data.badges.verified) {
                        badgeDisplay += `<img class="badge-image" src="verified.png" alt="Verified" title="Verified">`;
                    }
                    if (data.badges.partner) {
                        badgeDisplay += `<img class="badge-image" src="verified.png" alt="Verified" title="Verified">`;
                    }
                    // Badge No Audio (listen only)
                    if (data.badges.noAudio) {
                        badgeDisplay += `<img class="badge-image" src="no-audio.png" alt="No Audio" title="Audio d√©sactiv√© - √âcoute uniquement">`;
                    }
                    // Badge No Video (listen only)
                    if (data.badges.noVideo) {
                        badgeDisplay += `<img class="badge-image" src="listen.png" alt="Listen Only" title="√âcoute uniquement - Pas de vid√©o">`;
                    }
                    // Badge DJ
                    if (data.badges.dj) {
                        badgeDisplay += `<img class="badge-image" src="dj.png" alt="DJ" title="Twitch DJ">`;
                    }
                    // Badge Ambassador
                    if (data.badges.ambassador) {
                        badgeDisplay += `<img class="badge-image" src="ambassador.png" alt="Ambassador" title="Twitch Ambassador">`;
                    }
                    // Badge Anonymous Cheerer
                    if (data.badges.anonymousCheerer) {
                        badgeDisplay += `<img class="badge-image" src="anonymous-cheerer.png" alt="Anonymous Cheerer" title="Cheerer Anonyme">`;
                    }
                    // Badge Artist
                    if (data.badges.artist) {
                        badgeDisplay += `<img class="badge-image" src="Artist.png" alt="Artist" title="Artiste">`;
                    }
                    // Badges sp√©ciaux/√©v√©nements
                    if (data.badges.special) {
                        const specialType = data.badges.specialType;
                        let specialBadgeFile = '';

                        // Mapper les badges sp√©ciaux
                        if (specialType.includes('game-award-2023')) specialBadgeFile = 'game-award-2023.png';
                        else if (specialType.includes('golden-predictor-game-award-2023')) specialBadgeFile = 'golden-predictor-game-award-2023.png';
                        else if (specialType.includes('twitchcon-2025')) specialBadgeFile = 'twitchcon-2025.png';
                        else if (specialType.includes('twitchrecap-2024') || specialType.includes('twitch-recap-2024')) specialBadgeFile = 'twitch-recap-2024.png';
                        else if (specialType.includes('twitch-recap-2023') || specialType.includes('twitchrecap-2023')) specialBadgeFile = 'twitch-recap-2023.png';
                        else if (specialType.includes('twitch-inter-2023')) specialBadgeFile = 'twitch-inter-2023.png';
                        else if (specialType.includes('zevent-2024')) specialBadgeFile = 'zevent-2024.png';
                        else if (specialType.includes('subtember-2024')) specialBadgeFile = 'subtember-2024.png';
                        else if (specialType.includes('lol-mid-season-2025-support')) specialBadgeFile = 'lol-mid-season-2025-support-a-streamer.png';
                        else if (specialType.includes('lol-mid-season-2025')) specialBadgeFile = 'lol-mid-season-2025.png';
                        else if (specialType.includes('premiere-arcane-2') || specialType.includes('arcane-season-2-premiere')) specialBadgeFile = 'premiere-arcane-2.png';
                        else if (specialType.includes('rplace-cake-2023') || specialType.includes('rplace-2023')) specialBadgeFile = 'rplace-cake-2023.png';
                        else if (specialType.includes('share-the-love')) specialBadgeFile = 'share-the-love.png';
                        else if (specialType.includes('gold-pixel-hear-2024')) specialBadgeFile = 'gold-pixel-hear-2024.png';
                        else if (specialType.includes('purple-pixel-hear-2024') || specialType.includes('purple-pixel-heart---together-for-good-24')) specialBadgeFile = 'purple-pixel-heart-2024.png';
                        else if (specialType.includes('ruby-pixel-heart-2024')) specialBadgeFile = 'ruby-pixel-heart-2024.png';
                        else if (specialType.includes('clip-the-hall')) specialBadgeFile = 'clip-the-hall.png';
                        else if (specialType.includes('raging-wolf')) specialBadgeFile = 'raging-wolf.png';
                        else if (specialType.includes('gone-bananas')) specialBadgeFile = 'banana.png';
                        else if (specialType.includes('speedons-5-badge') || specialType.includes('speedons')) specialBadgeFile = 'speedons-5.png';
                        else if (specialType.includes('elden-ring-wylder')) specialBadgeFile = 'elden-ring-wylder.png';
                        else if (specialType.includes('elden-ring-recluse')) specialBadgeFile = 'elden-ring-recluse.png';
                        else if (specialType.includes('glhf') || specialType.includes('GLHF')) specialBadgeFile = 'GLHF.png';
                        else if (specialType.includes('glitchcon') || specialType.includes('Glitchcon')) specialBadgeFile = 'Glitchcon.png';

                        if (specialBadgeFile) {
                            badgeDisplay += `<img class="badge-image" src="${specialBadgeFile}" alt="${specialType}" title="${specialType}">`;
                        }
                    }
                }

                // Cr√©er l'image de la cha√Æne d'origine si disponible ET si le chat partag√© est actif
                let originImageHTML = '';
                if (data.originChannel && data.originChannel.profileImage && this.isSharedChatActive) {
                    console.log(`üè¢ Affichage de l'ic√¥ne de cha√Æne d'origine (chat partag√© actif): ${data.originChannel.displayName}`);
                    originImageHTML = `<img class="badge-image origin-channel" src="${data.originChannel.profileImage}" alt="${data.originChannel.displayName}" title="Cha√Æne d'origine: ${data.originChannel.displayName}" style="width: 22px; height: 22px; border-radius: 4px; margin-right: 6px; object-fit: cover; vertical-align: middle;">`;
                } else if (data.originChannel && data.originChannel.profileImage && !this.isSharedChatActive) {
                    console.log(`üö´ Ic√¥ne de cha√Æne d'origine masqu√©e (chat partag√© inactif): ${data.originChannel.displayName}`);
                }

                messageElement.innerHTML = `
                    <span class="badge-display">
                        ${originImageHTML}
                        ${badgeDisplay}
                    </span>
                    <span class="username ${badgeClass}" ${userColor}>${username}</span>
                    <span class="separator">:</span>
                    <span class="message-content">${message}</span>
                `;

                // Ajouter le message au container
                this.container.appendChild(messageElement);

                // Limiter le nombre de messages
                this.limitMessages();

                // Faire d√©filer vers le bas
                this.scrollToBottom();
            }

            limitMessages() {
                while (this.container.children.length > this.maxMessages) {
                    this.container.removeChild(this.container.firstChild);
                }
            }

            scrollToBottom() {
                this.container.scrollTop = this.container.scrollHeight;
            }

            // Messages de test (√† supprimer en production)
            addTestMessages() {
                setTimeout(() => {
                    const testMessages = [
                        { nick: 'StreamerPro', text: 'Bienvenue dans le stream ! üéÆ', badges: { moderator: true } },
                        { nick: 'ViewerFan', text: 'Salut tout le monde !', badges: { subscriber: true } },
                        { nick: 'GameMaster', text: 'Ce jeu a l\'air vraiment cool, j\'ai h√¢te de voir la suite de cette partie qui s\'annonce √©pique !', badges: { vip: true } },
                        { nick: 'ChatUser', text: 'GG pour ce kill !', badges: {} },
                        { nick: 'FollowerOne', text: 'Premier stream que je regarde et c\'est d√©j√† incroyable, continue comme √ßa !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!', badges: {} }
                    ];

                    testMessages.forEach((msg, index) => {
                        setTimeout(() => {
                            this.addMessage(msg);
                        }, index * 2000);
                    });
                }, 1000);
            }
        }

        // Fonction pour v√©rifier si une police est charg√©e en comparant les largeurs de texte
        function isFontLoaded(fontFamily, fallbackFont = 'monospace') {
            const testString = 'mmmmmmmmmmlli';
            const fontSize = '72px';

            // Cr√©er un √©l√©ment avec la police de fallback
            const fallbackElement = document.createElement('div');
            fallbackElement.style.fontFamily = fallbackFont;
            fallbackElement.style.fontSize = fontSize;
            fallbackElement.style.position = 'absolute';
            fallbackElement.style.left = '-9999px';
            fallbackElement.style.top = '-9999px';
            fallbackElement.style.visibility = 'hidden';
            fallbackElement.textContent = testString;
            document.body.appendChild(fallbackElement);

            const fallbackWidth = fallbackElement.offsetWidth;
            document.body.removeChild(fallbackElement);

            // Cr√©er un √©l√©ment avec notre police
            const testElement = document.createElement('div');
            testElement.style.fontFamily = `"${fontFamily}", ${fallbackFont}`;
            testElement.style.fontSize = fontSize;
            testElement.style.position = 'absolute';
            testElement.style.left = '-9999px';
            testElement.style.top = '-9999px';
            testElement.style.visibility = 'hidden';
            testElement.textContent = testString;
            document.body.appendChild(testElement);

            const testWidth = testElement.offsetWidth;
            document.body.removeChild(testElement);

            const isLoaded = fallbackWidth !== testWidth;
            console.log(`üìê Test de largeur - Fallback: ${fallbackWidth}px, Test: ${testWidth}px, Police charg√©e: ${isLoaded}`);

            return isLoaded;
        }

        // Fonction pour v√©rifier la police charg√©e
        function checkLoadedFonts() {
            console.log('üîç V√©rification des polices charg√©es...');

            // V√©rifier si l'API FontFace est disponible
            if ('fonts' in document) {
                console.log('üìã Toutes les polices charg√©es:', Array.from(document.fonts).map(font => font.family));

                // V√©rifier sp√©cifiquement notre police
                const seaFuguFont = Array.from(document.fonts).find(font =>
                    font.family.includes('Sea Regular Fugu')
                );

                if (seaFuguFont) {
                    console.log('‚úÖ Police "Sea Regular Fugu" trouv√©e:', seaFuguFont);
                    console.log('üìä Status de la police:', seaFuguFont.status);
                } else {
                    console.log('‚ùå Police "Sea Regular Fugu" non trouv√©e dans les polices charg√©es');
                }

                // Utiliser l'API moderne pour v√©rifier le chargement
                document.fonts.check('16px "Sea Regular Fugu"') ?
                    console.log('‚úÖ API fonts.check(): Police "Sea Regular Fugu" charg√©e') :
                    console.log('‚ùå API fonts.check(): Police "Sea Regular Fugu" non charg√©e');
            }

            // Test de largeur pour v√©rifier le chargement
            const fontLoadedByWidth = isFontLoaded('Sea Regular Fugu');

            // V√©rifier la police calcul√©e sur le body
            const bodyElement = document.body;
            const computedStyle = window.getComputedStyle(bodyElement);
            const actualFont = computedStyle.fontFamily;

            console.log('üéØ Police calcul√©e sur le body:', actualFont);

            // Cr√©er un √©l√©ment de test pour v√©rifier la police
            const testElement = document.createElement('div');
            testElement.style.fontFamily = '"Sea Regular Fugu", "Comic Sans MS", "Trebuchet MS", "Arial Black", Arial, sans-serif';
            testElement.style.position = 'absolute';
            testElement.style.left = '-9999px';
            testElement.textContent = 'Test Font';
            document.body.appendChild(testElement);

            const testComputedStyle = window.getComputedStyle(testElement);
            const testActualFont = testComputedStyle.fontFamily;

            console.log('üß™ Police de test calcul√©e:', testActualFont);

            // Nettoyer l'√©l√©ment de test
            document.body.removeChild(testElement);

            // V√©rifier si la police personnalis√©e est utilis√©e
            if (actualFont.includes('Sea Regular Fugu')) {
                console.log('üéâ SUCCESS: La police "Sea Regular Fugu" est active !');
            } else if (actualFont.includes('Comic Sans MS')) {
                console.log('‚ö†Ô∏è WARNING: Utilisation de la police fallback "Comic Sans MS"');
            } else {
                console.log('‚ùå ERROR: Aucune police reconnue d√©tect√©e. Police actuelle:', actualFont);
            }

            // R√©sum√© final
            console.log('üìù R√âSUM√â:');
            console.log(`   - Police charg√©e (test largeur): ${fontLoadedByWidth ? '‚úÖ' : '‚ùå'}`);
            console.log(`   - Police active dans CSS: ${actualFont.includes('Sea Regular Fugu') ? '‚úÖ' : '‚ùå'}`);
        }

        // Initialiser le widget quand la page est charg√©e
        document.addEventListener('DOMContentLoaded', () => {
            // Cr√©er et exposer le widget globalement pour les tests
            window.chatWidget = new ChatWidget();

            // V√©rifier les polices imm√©diatement
            checkLoadedFonts();

            // √âcouter les √©v√©nements de chargement de polices (API moderne)
            if ('fonts' in document) {
                document.fonts.addEventListener('loadingdone', (event) => {
                    console.log('üéâ √âv√©nement loadingdone d√©clench√© - Polices charg√©es:', event.fontfaces.length);
                    event.fontfaces.forEach(font => {
                        console.log(`   - ${font.family} (${font.status})`);
                    });
                    checkLoadedFonts();
                });

                document.fonts.addEventListener('loadingerror', (event) => {
                    console.log('‚ùå Erreur de chargement de police:', event.fontfaces);
                    event.fontfaces.forEach(font => {
                        console.log(`   - ERREUR: ${font.family} (${font.status})`);
                    });
                });

                // Forcer le chargement de notre police
                document.fonts.load('16px "Sea Regular Fugu"').then(() => {
                    console.log('‚úÖ Police "Sea Regular Fugu" charg√©e explicitement via fonts.load()');
                    checkLoadedFonts();
                }).catch((error) => {
                    console.log('‚ùå Erreur lors du chargement explicite de la police:', error);
                });
            }

            // V√©rifier √† nouveau apr√®s 2 secondes (temps pour que les polices se chargent)
            setTimeout(() => {
                console.log('üîÑ Re-v√©rification des polices apr√®s 2 secondes...');
                checkLoadedFonts();
            }, 2000);

            // V√©rifier une derni√®re fois apr√®s 5 secondes
            setTimeout(() => {
                console.log('üîÑ V√©rification finale des polices apr√®s 5 secondes...');
                checkLoadedFonts();
            }, 5000);
        });

        // Fonction globale pour ajouter des messages manuellement (pour les tests)
        function addTestMessage(username, message, badges = {}) {
            if (window.chatWidget) {
                window.chatWidget.addMessage({
                    nick: username,
                    text: message,
                    badges: badges
                });
            }
        }

        // ===== SECTION DE TEST - SUPPRIMER CETTE SECTION EN PRODUCTION =====
        // Test automatique de chat partag√© toutes les 20 secondes
        /*async function testSharedChatMessage() {
            try {
                const widget = window.chatWidget;
                if (!widget || typeof widget.addMessage !== 'function') {
                    console.error('‚ùå Chat widget not found.');
                    return;
                }

                console.log('üß™ Test de message de chat partag√©...');

                // Manually fetch the channel info for room-id 48624276
                const response = await fetch('https://api.twitch.tv/helix/users?id=48624276', {
                    headers: {
                        'Client-ID': 'gp762nuuoqcoxypju8c569th9wz7q5',
                        'Authorization': 'Bearer m15k59400wm8tosv4499famn76qpr3'
                    }
                });

                const json = await response.json();
                const originChannel = json.data?.[0]
                    ? {
                        displayName: json.data[0].display_name,
                        login: json.data[0].login,
                        profileImage: json.data[0].profile_image_url
                    }
                    : null;

                widget.addMessage({
                    nick: 'sc0rpio74890',
                    text: 'Ceci est un test simul√© depuis un autre chat partag√©',
                    badges: { vip: true },
                    userColor: '#FF0000FF',
                    originChannel
                });

                console.log('‚úÖ Message de test ajout√© avec succ√®s');
            } catch (error) {
                console.error('‚ùå Erreur lors du test de chat partag√©:', error);
            }
        }

        // D√©marrer le test automatique apr√®s initialisation du widget
        setTimeout(() => {
            console.log('üöÄ D√©marrage des tests automatiques de chat partag√© (toutes les 20 secondes)');
            // Premier test imm√©diat
            testSharedChatMessage();
            // Puis r√©p√©ter toutes les 20 secondes
            setInterval(testSharedChatMessage, 20000);
        }, 3000); // Attendre 3 secondes pour que le widget soit initialis√©
        // ===== FIN DE LA SECTION DE TEST ===== */
    </script>
</body>
</html>
